/**
 *  This object is in charge of keeping the canvas to the right size
 *  when called with the dragging() method
 */

import _ from 'lodash';

var editorView = null;
$.fn.savePosition = function( selector ) {
    var id = $(this).attr('id');
    if( id ) {
        var jsPlumbElement = editorView.jsPlumbInstance.getElement(id);
        if( jsPlumbElement ) {
            var pos = editorView.jsPlumbInstance.getPosition(jsPlumbElement);
            editorView.view.m.getNode(id).setPosition(pos);
        }
    }
}

class CanvasSizeHandler {
    constructor(parent, canvas) {
        this.parent = editorView = parent;
        this.canvas = canvas;
        this.minWidth  = this.width  = this.canvas.width();
        this.minHeight = this.height = this.canvas.height();

        // arbitrary: number of pixels to expand/shrink the canvas for 1 step
        // if a div is less than 1 step away from the border of the canvas, we expand
        this.treshold = 50;
        this.shiftTreshold = 200;

        // debounced resize
        this.debouncedResize = _.debounce(this.resize.bind(this), 100);

        this.z = 0; // current zoom
    }

    refreshZoom( z ) {
        this.z = z;
    }

    // set the current width and height to the new canvas
    apply() {
        if( this.canvas.width() !== this.width ) {
            console.log('setting canvas width: %s -> %s', this.canvas.width(), this.width);
            this.canvas.width(this.width);
        }
        if( this.canvas.height !== this.height ) {
            console.log('setting canvas height: %s -> %s', this.canvas.height(), this.height);
            this.canvas.height(this.height);
        }
    }

    // method to call when an element is positioned or dragged
    // el: div element
    resize() {
        // dont trigger save
        this.parent.view.m.history.ignore(() => {
            // refresh zoom value, zoom affects width, height and offset calculations
            this.refreshZoom( this.parent.zoomer.getZoom() );

            // find the coord of the 2d box bounding all divs
            var most = {
                top:    +Infinity,
                bottom: -Infinity,
                left:   +Infinity,
                right:  -Infinity
            };
            this.canvas.find('.card').each(function() {
                var rect = this.getBoundingClientRect();
                if( rect.top < most.top ) most.top = Math.floor(rect.top);
                if( rect.bottom > most.bottom ) most.bottom = Math.ceil(rect.bottom);
                if( rect.left < most.left ) most.left = Math.floor(rect.left);
                if( rect.right > most.right ) most.right = Math.ceil(rect.right);
            });

            // compare to the canvas coord
            var canvasRect = this.canvas[0].getBoundingClientRect();

            var r = {
                top:    canvasRect.top - most.top + this.treshold * this.z,
                bottom: most.bottom - canvasRect.bottom + this.treshold * this.z,
                left:   canvasRect.left - most.left + this.treshold * this.z,
                right:  most.right - canvasRect.right + this.treshold * this.z
            }

            // avoid to resize for some pixel roundup
            if( Math.abs(r.top) > 2 || Math.abs(r.left) > 2 || Math.abs(r.bottom) > 2 || Math.abs(r.right) > 2 ) {
                // resize width and height
                this.width += r.left + r.right;
                this.height += r.top + r.bottom;
                if( this.width < this.minWidth ) this.width = this.minWidth;
                if( this.height < this.minHeight ) this.height = this.minHeight;
                this.apply();

                // if we're expanding to the top or shrinking back, move the non-selected divs
                // in the opposite direction
                if( r.top > 0 || (r.top < 0 && this.height > this.minHeight)  ) {
                    // move the non-selected divs to the bottom
                    this.canvas.find('.card:not(.selected)').each(function() {
                        var offset = $(this).offset();
                        offset.top += r.top;
                        $(this).offset(offset);
                        $(this).savePosition();
                    });

                    this.parent.translater.translate({
                        top: -r.top,
                        left: 0,
                    });
                }

                // same for left
                if( r.left > 0 || (r.left < 0 && this.width > this.minWidth) ) {
                    // move the non-selected divs to the right
                    this.canvas.find('.card:not(.selected)').each(function() {
                        var offset = $(this).offset();
                        offset.left += r.left;
                        $(this).offset(offset);
                        $(this).savePosition();
                    });

                    this.parent.translater.translate({
                        top: 0,
                        left: -r.left,
                    });
                }

                this.parent.jsPlumbInstance.repaintEverything();
            }
        });

        // return a Promise if we need to wait for this call
        return new Promise((resolve, reject) => {
            this.canvas.ready(resolve);
        });
    }

    getIncreasedWidth() {
        return this.width - this.minWidth;
    }

    getIncreasedHeight() {
        return this.height - this.minHeight;
    }
}

export default CanvasSizeHandler;
