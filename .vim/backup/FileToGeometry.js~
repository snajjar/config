/* eslint-env es6 */

var description = require('./package.json');
var DualBox = require('@dualbox/dualbox');
var XTHREE = require('@dualbox/dualbox-lib-xthree');
var DualboxTypesAll3D = require('@dualbox/dualbox-type-all3d');

var File = require('@dualbox/dualbox-type-file');

var JSZip = require('jszip');

var getFileInZip = function(file, callback){
    JSZip.loadAsync(file.toArrayBuffer()).then(
        function (zip) {
            // Auto find the file in zip.
            // Note that this module works on zip file only
            // if there is no more than 1 obj / json / stl file.
            var fn;
            zip.forEach(function (relativePath, file){
                // ignore __MACOSX folder
                if(relativePath.search("__MACOSX") === -1){
                    fn = relativePath;
                }
            });

            var f = zip.file(fn);
            var fext = fn.split('.').pop().toLowerCase();
            if(fext === "obj" || fext === "json"){
                f.async("string").then(
                    function(data){
                        callback(data,"string",fext);
                    }
                );
            }else if(fext === "stl"){
                f.async("ArrayBuffer").then(
                    function(data){
                        callback(data,"ArrayBuffer",fext);
                    }
                );
            }else{
                throw new DualBox.errors.RuntimeError('Cannot read file in zip, the file found in the zip is not a supported format, please provide OBJ or STL (not binary). Detected type is '+fext);
            }
        }
    ).catch(
        function(reason) {
            throw new DualBox.errors.RuntimeError('Cannot read zip file ('+ file.getName() + ') : Zip load has been rejected : '+reason+'.');
        }
    );
};

/**
*  This function takes an STL file (as an arrayBuffer), and return true if it's an binary file.
*  @param {ArrayBuffer} binData the STL file in an ArrayBuffer
*  @return {boolean} if it's a binary file return true, else return false
*/
var stlIsBinary = function(binData){
    //First test, based on the convention of binary STL
    var expect, n_faces, reader;
    reader = new DataView(binData, 0 );

    //Read the number of face expected (position 80 in a binary STL file) :
    try
	{
		n_faces=reader.getUint32(80,true);
	}
	catch(err)
	{
        console.warn("The header of the STL binary file is distorded or empty.");
		return false;
	}


    //Compute the length expected for a binary STL file, based on the number of faces :
    expect = 80 /*header*/ + 4 /* n_faces */ + ( n_faces * 50 );

    if ( expect === binData.byteLength ) {
        //It's a binary file :
        return true;
    }

    //Second test to ensure that it's an ASCII STL file. In other case, it will be concidered as a binary.

    // An ASCII STL data must begin with 'solid ' as the first six bytes.
    // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'
    var solid = [ 115, 111, 108, 105, 100 ];

    for ( var i = 0; i < 5; i ++ ) {
        if ( solid[ i ] != reader.getUint8( i, false ) ) {
            //This is not an ASCII file :
            console.warn("Bad STL file : the header seems to be broken");
            return true;
        }
    }

    // First 5 bytes read "solid"; declare it to be an ASCII STL
    return false;
};

/**
*  This function takes an STL file (as a ArrayBuffer), and return it in a string.
*  @param {file} buf the STL file : string or ArrayBuffer
*  @return {string} the file in a string
*/
var ensureString = function ( buf ) {

    if ( typeof buf !== "string" ) {

        var array_buffer = new Uint8Array( buf );

        var str = '';

        for ( var i = 0, il = buf.byteLength; i < il; i ++ ) {

            str += String.fromCharCode( array_buffer[ i ] ); // implicitly assumes little-endian

        }

        return str;

    } else {

        return buf;

    }

};


/**
 *  A simple parsing module for dualbox
 *  @constructor
 *  @extends {DualBox.Module}
 */
var FileToGeometry = function(attrs){
    DualBox.Module.call(this, description, attrs);
    this.setParallel(false);
};

FileToGeometry.prototype = Object.create(DualBox.Module.prototype);
FileToGeometry.prototype.constructor = FileToGeometry;

// [Abstract] See DualBox.Module
FileToGeometry.prototype.compute = function(input, response){
    this.debug( "Computing output of FileToGeometry" );

    var g = new XTHREE.BufferTriGeometry();
    var options ={
        vn:input.vn,
        vt:input.vt,
        fn:input.fn,
        ft:input.ft,
        vc:input.vc
    };
    var reconnect = input.reconnect;

    var done = function(g){

        var output = {
            g:g
        };
        response.send(output);
    };

    if(input.file === null){
        done(g);
    }else{
        switch(input.file.getExtension()){
            case "obj":
                g.fromOBJ(input.file.toUTF8String(), options);
                done(g);
            break;
            case "json":
                g.fromJSON(JSON.parse(input.file.toUTF8String()));
                done(g);
            break;
            case "stl":
                var dt = input.file.toArrayBuffer();

                var isBinary = stlIsBinary(dt);

                if(isBinary){
                    g.fromBinarySTL(dt, reconnect);
                    //No need to indexed the mesh, it will be indexed during the parsing
                    //And the vertices at the exact same position will be merge
                    done(g);
                }else{
                    g.fromSTL(ensureString(input.file.toUTF8String()));
                    if(reconnect){
                        g.toIndexed();
                    }
                    done(g);
                }
            break;
            case "zip":
                getFileInZip(input.file, function(data, type, ext){
                    switch(ext){
                        case "obj":
                            g.fromOBJ(data, options);
                            done(g);
                        break;
                        case "json":
                            g.fromJSON(JSON.parse(data));
                            done(g);
                        break;
                        case "stl":
                            var isBinary = stlIsBinary(data);

                            if(isBinary){
                                g.fromBinarySTL(data);
                                if(reconnect){
                                    g.toIndexed();
                                }
                                done(g);
                            }else{
                                g.fromSTL(ensureString(data));
                                if(reconnect){
                                    g.toIndexed();
                                }
                                done(g);
                            }
                        break;
                        default:
                            throw new DualBox.errors.TypeError("Error in module " + this.id +" the file extension in the zip file. Please provide OBJ or STL (not binary) file. Detected is : "+ext);
                        break;
                    };
                });
            break;
            default:
                throw new DualBox.errors.TypeError("Error in module " + this.id +" the file extension is not supported. Please provide OBJ or STL (not binary) file.");
            break;
        };
    }
};

module.exports = FileToGeometry;
