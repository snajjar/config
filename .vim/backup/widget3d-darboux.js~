import { $, env, Widget3D, Type } from '@dualbox/dualbox';
import { SphereBufferGeometry, BufferTriGeometry, BufferLineGeometry, BufferGeometry, SphereGeometry, Geometry, Mesh, MeshBasicMaterial, Object3D, Vector3, Plane} from '@dualbox/dualbox-lib-xthree';
var pkgDesc = require('../package.json');

var DualboxTypesAll3D = require('@dualbox/dualbox-type-all3d');

var cloneArrayArrayVector3 = function(arr){
    var clone = new Array(arr.length);
    for(var i=0; i<arr.length; ++i){
        clone[i] = new Array(arr[i].length);
        for(var j=0; j<arr[i].length; ++j){
            clone[i][j] = arr[i][j].clone();
        }
    }
    return clone;
};

var specialBindings = {
    drag:true
};

var pAOV = Widget3D.pushArrObjVal;
var rmIAO = Widget3D.rmIdxInArrObj;

/**
 *  Widget to draw a darboux surface from 2 handles and an line.
 *
 */
class Widget3DDarboux extends Widget3D {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options);

         // clone appDesc to be able to redefine the special events.
        this.appDesc = JSON.parse(JSON.stringify(this.appDesc));
        var evts = this.appDesc.attr.mouse || {};
        var to_rm = {};
        var that = this;
        Object.keys(evts).forEach(function (key) {
            for(var i=0; i<evts[key].length; ++i){
                var bind = evts[key][i];
                if(specialBindings[bind]){
                    switch(bind){
                        case "drag":
                            {
                                var touch = key.search("touchstart") === 0;
                                var butt = touch || key[9] === ":" || key[9] === undefined ? "" : key[9];
                                if( (key.search("mousedown") !== 0 ||  (butt !== "0" && butt !== "1" && butt !=="2")) && !touch){
                                    throw "Error : Widget3DImageComposer2D special binding 'slide' has not been made to handle something else than mousedown0, mousdown1 or mousdown2 and touchstart. Please refer to documentation.";
                                }
                                var st_evt = touch ? "touchstart" : "mousedown";
                                var stop_evt = touch ? "touchend" : "mouseup";
                                var mv_evt = touch ? "touchmove" : "mousemove";
                                pAOV(to_rm,key,i);
                                pAOV(evts,st_evt+butt+":widget:"+that.id+":h1mesh","dragHandleInit");
                                pAOV(evts,st_evt+butt+":widget:"+that.id+":h2mesh","dragHandleInit");
                                pAOV(evts,mv_evt,"dragHandleRun");
                                pAOV(evts,stop_evt+butt,"dragHandleStop");
                            }
                        break;
                        default:
                            throw "Error : bind "+bind+" is in the special binding list but is not recognized in the constructor.";
                        break;
                    }
                }
            }
        });

        // remove all the special bindings that have been found
        Object.keys(to_rm).forEach(function (key) {
            var arr = to_rm[key];
            for(var i=0; i<arr.length; ++i){
                rmIAO(evts, key, i);
            }
        });

        var tag = 'mousemove:widget:'+this.id;
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageHover");
        tag = 'mousemove:scene';
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageOut");
        tag = 'mousemove:background';
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageOut");

    }

    manageHover(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.dragging){
            this.h1Mesh.material = this.inputPersist.mat;
            this.h2Mesh.material = this.inputPersist.mat;
            if(under.on[0] === "widget" && under.on[1] === this.id){
                switch(under.on[2]){
                    case "h1mesh":
                        this.h1Mesh.material = this.inputPersist.matHover;
                    break;
                    case "h2mesh":
                        this.h2Mesh.material = this.inputPersist.matHover;;
                    break;
                }
            }else{

            }
        }
        event.cvs3dEvent.doPropagate();
    }
    manageOut(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.dragging){
            this.h1Mesh.material = this.inputPersist.mat;
            this.h2Mesh.material = this.inputPersist.mat;
        }
        event.cvs3dEvent.doPropagate();
    }

    init3D(){

        // Set persistant inputs (inputs kept after evaluation for
        // for 3D preview).
        this.inputPersist = {
            shape:      new BufferLineGeometry(),
            mat:        new MeshBasicMaterial({color:0x009900}),
            matHover:   new MeshBasicMaterial({color:0x009900}),
        };

        // Session variable (will be saved and restored to it's value)
        // Keep initial values (positions, limit...) in order to
        // check when an input has changed and reset the widget accordingly.
        this.initialValues = this.getSession().variable("initialValues", {
            h1Positions:[],
            h2Positions:[]
        });

        this.h1Mesh = new Mesh(
            (new BufferTriGeometry()).copy(
                    (new BufferGeometry()).fromGeometry(
                        new SphereGeometry(
                            1
                        )
                    )
            ),
            this.inputPersist.mat
        );
        this.h1Mesh.name = this.id+"#"+"h1mesh";
        this.h1Mesh.visible = this.visible;

        this.h2Mesh = new Mesh(
            (new BufferTriGeometry()).copy(
                    (new BufferGeometry()).fromGeometry(
                        new SphereGeometry(
                            1
                        )
                    )
            ),
            this.inputPersist.mat
        );
        this.h2Mesh.name = this.id+"#"+"h2mesh";
        this.h2Mesh.visible = this.visible;

        this.canvas3d.widgetGroup.add(this.h1Mesh);
        this.canvas3d.widgetGroup.add(this.h2Mesh);

        this.h1Positions = [];
        this.h2Positions = [];
        this.g = new BufferTriGeometry();

        this.dragging = false;
        this.draggingH = "none";

        this.overrideInputs = ["h1Positions","h2Positions"];
        super.initOverride();
    }

    import( h1positions, h2positions ) {
        var h1p = Type.deserialize( h1positions );
        var h2p = Type.deserialize( h2positions );
        var that = this;
        _.each(h1p, ( arr_v ) => {
            that.h1Positions = h1positions;
            that.h2Positions = h2positions;
        });
    }

    updateGeometry() {

        // Shape is not used for now, considered as a line.
        var shape = this.inputPersist.shape;

        this.g = new BufferTriGeometry();

        var attr = {
            position: new Vector3()
        };

        for(var i=0; i<this.h1Positions.length; ++i){
            var arr1 = this.h1Positions[i];
            var arr2 = this.h2Positions[i];
            if(arr1.length === arr2.length){
                for(var j=0; j<arr1.length; ++j){
                    attr.position.copy(arr1[j]);
                    var idx = this.g.addVertex(attr);
                    attr.position.copy(arr2[j]);
                    var idx = this.g.addVertex(attr);
                    if(i>0){
                        this.g.addFace(idx-3, idx-1, idx-2);
                        this.g.addFace(idx-1, idx, idx-2);
                    }
                }
            }
        }
    }

    setPersistentInputValues(){
        var that = this;

        var pin = this.inputPersist;

        var persKeys = ["mat","matHover","shape"];
        persKeys.forEach(function (key) {
            if( that.inputValid[key] ){
                pin[key] = that.inputValue[key];
            }
        });
        this.h1Mesh.material = pin.mat;
        this.h2Mesh.material = pin.mat;
    }

    // This will override the current position (set by the user)
    // with the position determined from the inputs.
    // this.override contains which inputs must override the current position.
    overrideUserInputs(){
        var inVal = this.inputValue;
        var changed = this.override;

        if(changed.h1Positions){
            this.h1Positions = cloneArrayArrayVector3(inVal.h1Positions);;
            this.initialValues.get().h1Positions = cloneArrayArrayVector3(inVal.h1Positions);
        }
        if(changed.h2Positions){
            this.h2Positions = cloneArrayArrayVector3(inVal.h2Positions);;
            this.initialValues.get().h2Positions = cloneArrayArrayVector3(inVal.h2Positions);
        }

        // Take the last point defined for each list to setup the handle on it.
        for(var i=this.h1Positions.length-1; i>=0; --i){
            var arr = this.h1Positions[i];
            if(arr.length !== 0){
                this.h1Mesh.position.copy(arr[arr.length-1]);
                break;
            }
        }
        for(var i=this.h2Positions.length-1; i>=0; --i){
            var arr = this.h2Positions[i];
            if(arr.length !== 0){
                this.h2Mesh.position.copy(arr[arr.length-1]);
                break;
            }
        }

        // update the output geometry
        this.updateGeometry();
    }

    hide(){
        super.hide();
        this.h1Mesh.visible = false;
        this.h2Mesh.visible = false;
    }

    show(){
        super.show();
        this.h1Mesh.visible = true;
        this.h2Mesh.visible = true;
    }

    // API Function
    dragHandleInit(event){
        if(!this.dragging){
            this.override = null;
            var under = event.cvs3dEvent.mouseData.underMouse;
            if(under.on[0] !== "widget" && under.on[1] !== this.id){
                throw "Error : cannot drag handle since the clicked element is not the expected widget ("+this.id+").";
            }else{

                this.canvas3d.enslaveWidget3D(this);

                if(under.on[2] === "h1mesh"){
                    this.draggingH = this.h2Mesh;
                    if(this.h2Positions[this.h2Positions.length-1].length !== 0){
                        var last_arr1 = this.h1Positions[this.h1Positions.length-1];
                        this.draggingP0 = last_arr1[last_arr1.length-1];
                        this.draggingPList = [];
                        this.h1Positions.push(this.draggingPList);
                        this.h2Positions.push([]);
                    }else{
                        this.draggingPList = this.h1Positions[this.h1Positions.length-1];
                    }
                }else if(under.on[2] === "h2mesh"){
                    this.draggingH = this.h2Mesh;
                    if(this.h1Positions[this.h1Positions.length-1].length !== 0){
                        var last_arr2 = this.h2Positions[this.h2Positions.length-1];
                        this.draggingP0 = last_arr2[last_arr2.length-1];
                        this.draggingPList = [];
                        this.h2Positions.push(this.draggingPList);
                        this.h1Positions.push([]);
                    }else{
                        this.draggingPList = this.h1Positions[this.h1Positions.length-1];
                    }
                }else{
                    // do nothing for now.
                }

                this.draggingHit0 = under.first.point;
                this.draggingOrigPos = this.draggingH.position.clone();

                var caman = this.canvas3d.getCameraMan();
                var viewdir = caman.getCameraWorldDirection();
                viewdir.normalize();

                this.draggingPlane = new Plane(viewdir, -this.draggingHit0.dot(viewdir));

                this.dragging = true;

                //this.updateGeometry();
                //this.trigger({ "g" : this.g });
            }
        }else{
            // resume propagation, as we have finally not captured this event.
            event.cvs3dEvent.doPropagate();
        }
    }
    dragHandleRun(event){
        if(this.dragging){

            this.override = null;

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            // Get ray intersection with dragging plane
            var ray = caman.getRay(canvasX, canvasY);
            var plane_hit = ray.intersectPlane(this.draggingPlane);

            // Compute translation vector
            var transvec = (new Vector3()).subVectors(plane_hit, this.draggingHit0);

            this.draggingH.position.copy(this.draggingOrigPos).add(transvec);

            // Compare position to h1Positions or h2Positions last entry. If close, replace, if far, push.
            var computer = new Vector3();
            var step = computer.subVectors(this.draggingH.position,this.draggingP0);
            if(step >= this.attr.minstep || this.draggingPList.length === 0){
                this.draggingPList.push(this.draggingH.position.clone());
            }else{
                this.draggingPList[this.draggingPList.length-1].copy(this.draggingH.position);
            }

            this.updateGeometry();
            this.trigger({ "g" : this.g });
        }else{
            // resume propagation, as we have finally not captured this event.
            event.cvs3dEvent.doPropagate();
        }
    }
    dragHandleStop(event){
        if(this.dragging){

            this.override = null;

            this.canvas3d.freeWidget3D(this);
            this.dragging = false;
            // If nothing has been added (can happen if run is not called),
            // remove empty arrays to keep a clean geometry
            if(this.h1Positions[this.h1Positions.length-1].length === 0 &&
               this.h2Positions[this.h2Positions.length-1].length === 0){
                this.h1Positions.length = this.h1Positions.length-1;
                this.h2Positions.length = this.h2Positions.length-1;
            }
        }
    }

    onReady() {

        if(this.override){
            this.overrideUserInputs();
        }
        this.setPersistentInputValues();

        this.emit('data', { "g" : this.g });

    }

    static attachTo(appDesc, attrs, div) {
        var dt = new Widget3DDarboux(pkgDesc, appDesc, attrs);
        return dt;
    }
}

module.exports = Widget3DDarboux;
