var Type = require('../../Type');
const _ = require('@dualbox/dualbox-lib-lodash');
var env = require('../../Env');

// require native types
require('@dualbox/dualbox-type-object');
require('@dualbox/dualbox-type-buffer');
require('@dualbox/dualbox-type-map');
require('@dualbox/dualbox-type-array');
require('@dualbox/dualbox-type-nativearray');
require('@dualbox/dualbox-type-number');
require("@dualbox/dualbox-type-boolean");
require("@dualbox/dualbox-type-string");
require("@dualbox/dualbox-type-regexp");
require("@dualbox/dualbox-type-json");

var self;
module.exports = function(o) {
    self = o || this; // browser and node.js compatibility

    // send a log to the main thread for nice display
    // first args should be the level, the rest is like in a module (args and finally option)
    self.log = function() {
        var args = _.toArray(arguments);
        var level = args[0];
        args = args.splice(1);

        self.postMessage({
            "cmd"     : "log",
            "id"      : self.id,
            "args"    : args,
            "level"   : level,
            "origin"  : "worker",
        });
    }

    self.sendOutput = function(data, execTimes) {
        self.log("info", "Worker " + self.id + " posting data");

        // remove node from data, it will be added in worker pool
        delete data.node;

        var d = [];
        var keys = Object.keys(data.output);
        for(var i=0; i<keys.length; i++) {
            var k = keys[i];
            d[k] = Type.toWorkerData(data.output[k]);
        }

        self.postMessage({
            "cmd"    : "computed",
            "id"     : self.id,
            "data"   : d,
            "origin" : "worker",
            "execTimes" : execTimes,
        });
    }

    self.commands = {
        "init" : function(msg) {
            self.id = msg.id;
            env.setOptions( msg.envOptions );

            self.postMessage({
                "cmd"    : "initialized",
                "id"     : self.id,
                "origin" : "worker",
            });
            self.log("info", "worker initialized");
        },

        "compute" : function(msg) {
            // closure to protect global scope
            (function() {
                // require the right module
                try {
                    self.Module = require(msg.desc.name);
                    self.log("debug", "processing module " + msg.desc.name);
                }
                catch(e) {
                    self.log("error", "Unable to load module " + msg.desc.name + ": " + e.toString());
                    debugger;
                    return;
                }

                // initialize it with parallel=false
                self.module = new self.Module({ 'id' : msg.id, 'rootApp': msg.rootApp });
                self.module.setParallel(false);
                self.module.setProfiler(true);

                // copy the jobId from the original module
                self.module.jobId = msg.jobId;
                self.module.execJobId = msg.jobId;

                // deserialize input values
                self.module.inputValid = {};
                self.module.inputValue = {};
                var keys = Object.keys(msg.inputValue);
                for(var i=0; i<keys.length; i++) {
                    var k = keys[i];
                    self.module.inputValid[k] = msg.inputValid[k];
                    self.module.inputValue[k] = Type.fromWorkerData(msg.inputValue[k]);
                }

                // compute the data and send output
                self.module.once(self, 'data', function(data) {
                    // get the computed time
                    self.module.endProfile();
                    var execTimes = self.module.execTimes;

                    self.sendOutput(data, execTimes);
                });

                self.module.startProfile();
                self.module.computeSequential();
            })();
        }
    }

    self.addEventListener('message', function(e) {
        var msg = e.data;
        if( msg.origin == "workerpool" ) {
            if( self.commands[msg.cmd] === undefined ) {
                console.error("Did not recognize command: " + msg.cmd);
            }
            else {
                self.commands[msg.cmd](msg);
            }
        }
    });
};



