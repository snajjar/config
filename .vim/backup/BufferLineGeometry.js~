import { BufferGeometry, BufferAttribute, Matrix4, Vector3, Box3, Raycaster, BufferGeometryLoader} from 'three-full';
import * as ArrayBufferUtils from '../ArrayBufferUtils';
import * as Vector3Utils from '../Vector3Utils';

const BufferTriGeometry = require('./BufferTriGeometry');

/**
 *  This class extends the BufferGeometry to add modeling functions,
 *  setters and getters.
 *  Since modeling generally change geometry dynamicaly, we need to pre allocate
 *  vertices.
 *  This class is restricted to polyline until more is needed.
 *
 *  @extends {BufferGeometry}
 *  @constructor
 *  @param {boolean=} lineSegments True if you want this line to be defined by segments. default is false.
 *                    linesegments means that you will have [Start1,end1,start2,end2...] instead of [start,p1,p2,...,end]
 */
var BufferLineGeometry = function (lineSegments) {

    BufferGeometry.call(this);

    this.type = BufferLineGeometry.type;

    this.addAttribute( 'position', new BufferAttribute( new Float32Array( 3*12 ), 3 ) );

    this.nVertices = 0;

    this.lineSegments = lineSegments ? true : false;
    this.nSegments = 0;

    if(this.lineSegments){
        this.setIndex(new BufferAttribute( new Uint16Array(12), 1 ));
    }

    this.autoSetDrawRange();
};

BufferLineGeometry.type = "BufferLineGeometry";

BufferLineGeometry.prototype = Object.create(BufferGeometry.prototype);
BufferLineGeometry.prototype.constructor = BufferLineGeometry;

BufferLineGeometry.prototype.vertexCount = function () {
    return this.nVertices;
};
BufferLineGeometry.prototype.segmentsCount = function () {
    return this.nSegments;
};

// Note : should be renamed "preallocate vertices" or something like that
BufferLineGeometry.prototype.setVerticesNumber = function (n) {
    if(this.nVertices !== n){
        this.nVertices = n;
        this.resizeBuffers(this.nVertices, null);
    }
};

BufferLineGeometry.prototype.isLineSegments = function (n) {
    return this.lineSegments;
};
BufferLineGeometry.prototype.setSegmentsNumber = function (n) {
    if(this.lineSegments && this.nSegments !== n){
        this.nSegments = n;
        this.resizeBuffers(null, this.nSegments);
    }
};

/**
 *  Adding a new vertex to the geometry, optionnaly set attributes values.
 *  Note that atrributes values must be set as for BufferAttribute.
 *  Exemple : if you want to set uv attribute, you must fill attr.uv.x and attr.uv.y.
 *  @param {Object} attr Attributes for the vertex, attr.position must be defined.
 *  @return {number} return the index of the added vertex
 */
BufferLineGeometry.prototype.addVertex = function (attr) {
    this.nVertices++;
    if(this.attributes.position.count <= this.nVertices){
        this.resizeBuffers(2*this.nVertices, null);
    }
    this.setVertex(this.nVertices-1, attr);
    this.autoSetDrawRange();
    return this.nVertices-1;
};
//
BufferLineGeometry.prototype.addSegment = function (a,b) {
    if(!this.lineSegments){
        throw "Error : cannot add segment to line which is not a line segments";
    }
    var indices = this.getIndex().array;
    var n_seg = Math.floor(indices.length/2);
    this.nSegments++;
    if(this.nSegments >= n_seg){
        this.resizeBuffers(null, 2*this.nSegments);
    }
    this.setSegment(this.nSegments-1, a,b);
};

BufferLineGeometry.prototype.setSegment = function (index, a,b) {
    if(!this.lineSegments){
        throw "Error : cannot add segment to line which is not a line segments";
    }else{
        this.getIndex().array[2*index] = a;
        this.getIndex().array[2*index+1] = b;
        this.getIndex().needsUpdate = true;
    }
};

/**
 *  Set vertex attributes.
 *  @param {number} index
 *  @param {Object.<string,Object>} attr Attribute for the vertex (position, normal... Must have been added first of course)
 */
BufferLineGeometry.prototype.setVertex = function (index, attr) {
    if(index >= this.nVertices){
        console.warn("setVertex : line geometry has only " + this.nVertices + "vertices, cannot set values at index " + index);
    }
    var keys = Object.keys(this.attributes);
    for(var i =0; i<keys.length; ++i){
        var curr_a = attr[keys[i]];
        if(curr_a !== undefined){
            var this_a = this.attributes[keys[i]];
            if(curr_a.w !== undefined){
                this_a.setXYZW(index,curr_a.x,curr_a.y,curr_a.z,curr_a.w);
            }else if(curr_a.z !== undefined){
                this_a.setXYZ(index,curr_a.x,curr_a.y,curr_a.z);
            }else if(curr_a.y !== undefined){
                this_a.setXY(index,curr_a.x,curr_a.y);
            }else if(curr_a.x !== undefined){
                this_a.setX(index,curr_a.x);
            }else{
                console.warning("addVertex : attribute " + keys[i] + " is defined in argument but has no valid value x,y,z,w");
            }
            this_a.needsUpdate = true;
        }else{
            // values are garbage, no guarantee
        }
    }
};


/**
 *  Note : this can extend or shrink the actual buffer sizes.
 *  @param {number} v_resize The new internal size for vertices buffers (attributes)
 *  @param {number} s_resize The new internal size for segments buffers (only used in case of a lineSegments geometry)
 */
BufferLineGeometry.prototype.resizeBuffers = function(v_resize, s_resize){
    this.dispose();
    if(v_resize !== null){
        var keys = Object.keys(this.attributes);
        for(var i=0; i<keys.length; ++i){
            var this_a = this.attributes[keys[i]];
            this.attributes[keys[i]] = new BufferAttribute(
                ArrayBufferUtils.resize(this_a.array, v_resize*this_a.itemSize),
                this_a.itemSize
            );
        }
    }
    if(this.lineSegments && s_resize !== null){
        var indices = this.index.array;
        if(indices instanceof Uint16Array && this.attributes.position.count > 65535){
            indices = new Uint32Array( this.index.array );
        }
        this.index = new BufferAttribute(
            ArrayBufferUtils.resize(indices,2*s_resize),
            this.index.itemSize
        );
        if(this.nSegments>s_resize){
            this.nSegments = s_resize;
        }
    }
    this.autoSetDrawRange();
};
/**
*   Minimize internal buffers to reduce memory print.
*   Note that this will make the object a standard BufferGeometry
*/
BufferLineGeometry.prototype.minimizeBuffers = function(){
    this.resizeBuffers(this.nVertices, this.nSegments);
};

/**
 *  Set drawrange according to the number of vertices or segments.
 */
BufferLineGeometry.prototype.autoSetDrawRange = function(){
    this.setDrawRange(0,(this.isLineSegments() ? 2 : 1)*this.nVertices);
};

/**
 *  Safe alternative to addAttribute. Using this instead of addAttribute ensure that the
 *  created buffer is consistant with the BufferLineGeometry internal structure.
 *  This function will add attribute buffers depending on the actual buffers length.
 *
 *  After this initialization, you can set attribute values by manipulation the attribute array, or
 *  using the easier API setVertex(attr).
 *
 *  @param {string} name The name of the attribute.
*   @param TypeArray The type of the attribute array (Float32Array, Uint16Array, etc...)
 *  @param {number} itemSize The size for the attribute (example : 2 for uv, 3 for normal)
 *
 */
BufferLineGeometry.prototype.addVertexAttribute = function(name, TypeArray, itemSize){
    this.addAttribute(
        name,
        new BufferAttribute(
            new TypeArray(itemSize*this.attributes.position.length/3),
            itemSize
        )
    );
    return this.getAttribute(name);
};


BufferLineGeometry.prototype.deleteVertices = function (varray) {

    var toRemove = {};
    varray.forEach(function(v){
        if(toRemove[v]){
            throw "Error : varray must not contain twice the same vertex index. PLease remove duplicates.";
        }
        toRemove[v] = true;
    });

    var self = this;
    var deleteVertex = function deleteVertex( index ) {
        var attributes = Object.keys(self.attributes);
        var data, buffer, itemSize;

        // delete vertex data from all attributes
        for ( var i = 0; i < attributes.length; i++ ) {
            data = self.getAttribute( attributes[ i ] );
            buffer = data.array;
            itemSize = data.itemSize;

            for ( var j = 0; j < itemSize; j++ ) {
                buffer[itemSize*index+j] = 0;
            }
        }
    };
    var shiftVertex = function(orig_idx, new_idx){
        var attributes = Object.keys(self.attributes);
        var data, buffer, itemSize;

        // delete vertex data from all attributes
        for ( var i = 0; i < attributes.length; i++ ) {
            data = self.getAttribute( attributes[ i ] );
            buffer = data.array;
            itemSize = data.itemSize;

            for ( var j = 0; j < itemSize; j++ ) {
                buffer[itemSize*new_idx+j] = buffer[itemSize*orig_idx+j];
            }
        }
    };

    var nv_removed = 0;
    var stack_idx = 0;
    var replace_map = {};
    for(var i=0; i<this.nVertices; ++i){
        if(toRemove[i]){
            deleteVertex(i);
            nv_removed++;
        }else{
            shiftVertex(i, stack_idx)
            replace_map[i] = stack_idx;
            stack_idx++;
        }
    }
    this.nVertices = this.nVertices-nv_removed;

    if(this.isLineSegments()){
        // in this case we need to reindex
        var indices = this.getIndex().array;

        var last = this.nSegments-1;
        for(var i=0; i<this.nSegments; ++i){
            var a = indices[2*i];
            var b = indices[2*i+1];
            if(toRemove[a] || toRemove[b]){
                indices[2*i] = indices[2*last];
                indices[2*i+1] = indices[2*last+1];
                indices[2*last] = 0;
                indices[2*last+1] = 0;
                last--;
            }else{
                indices[2*i] = replace_map[a];
                indices[2*i+1] = replace_map[b];
            }
        }

        this.getIndex().needsUpdate = true;

        this.nSegments = last+1;
    }

    this.autoSetDrawRange();
};

// Do not return this since later we may need to return the new indexation.
BufferLineGeometry.prototype.cropVertices = function (box) {

    var v = new Vector3();
    var vertices = this.attributes.position.array;
    var toRemove = [];

    for ( var i = 0; i < this.nVertices; i++ ) {

        v.set( vertices[ 3 * i + 0 ], vertices[ 3 * i + 1 ], vertices[ 3 * i + 2 ] );

        if ( !box.containsPoint( v ) ) {
            toRemove.push( i );
        }

    }

    this.deleteVertices( toRemove );
};


// When manpulating the geometry outside this classe, without knowledge of
// internat structure, use this instead of direct access to getAttribute('position').
// Can also be useful when there is a risk of buffer resizing (use of addFace)
BufferLineGeometry.prototype.getPositionX = function (i) {
    return this.attributes.position.getX(i);
};
BufferLineGeometry.prototype.getPositionY = function (i) {
    return this.attributes.position.getY(i);
};
BufferLineGeometry.prototype.getPositionZ = function (i) {
    return this.attributes.position.getZ(i);
};
// Same as above but with normal attribute. Will crash if the attribute is not defined
BufferLineGeometry.prototype.getNormalX = function (i) {
    return this.attributes.normal.getX(i);
};
BufferLineGeometry.prototype.getNormalY = function (i) {
    return this.attributes.normal.getY(i);
};
BufferLineGeometry.prototype.getNormalZ = function (i) {
    return this.attributes.normal.getZ(i);
};

/**
 *  Return an Array of Vector3 representing the line.
 *  @param lineSegments True if the wanted list should be lineSegments. Note that if the LineGeometry
 *                      is lineSegments, returned list will necessary be.
 */
BufferLineGeometry.prototype.getPolylinePoints = function(lineSegments){
    var res = [];
    if(this.isLineSegments()){
        var index = this.getIndex().array;
        for(var i=0; i<this.nSegments; ++i){
            res.push(new Vector3(
                this.getPositionX(index[2*i]),
                this.getPositionY(index[2*i]),
                this.getPositionZ(index[2*i])
            ));
            res.push(new Vector3(
                this.getPositionX(index[2*i+1]),
                this.getPositionY(index[2*i+1]),
                this.getPositionZ(index[2*i+1])
            ));
        }
    }else{
        for(var i=0; i<this.nVertices-1; ++i){
            res.push(new Vector3(
                this.getPositionX(i),
                this.getPositionY(i),
                this.getPositionZ(i)
            ));
            if(lineSegments && i < this.nVertices-1 ){
                res.push(new Vector3(
                    this.getPositionX(i+1),
                    this.getPositionY(i+1),
                    this.getPositionZ(i+1)
                ));
            }
        }
    }
    return res;
}

/**
 *  Compute the geometry boudning box.
 *  Must be rewritten from to take into account the buffering (this.nVertices)
 */
BufferLineGeometry.prototype.computeBoundingBox = function () {

    if ( this.boundingBox === null ) {
        this.boundingBox = new Box3();
    }

    var positions = this.attributes.position.array;

    this.boundingBox.makeEmpty();
    var p = new Vector3();
    var position = this.getAttribute("position");
    if ( positions !== undefined ) {
        for(var i=0; i<this.nVertices; ++i){
            p.set(position.getX(i), position.getY(i),position.getZ(i));
            this.boundingBox.expandByPoint(p);
        }
    }

    if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
        console.error( 'BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
    }
};

/**
 *  @param {BufferGeometry} source
 */
BufferLineGeometry.prototype.copy = function(source){
    BufferGeometry.prototype.copy.call(this, source);

    if(source instanceof BufferLineGeometry){
        this.nVertices = source.nVertices;
        if(source.lineSegments){
            this.lineSegments = source.lineSegments;
            this.nSegments = source.nSegments;
        }else{
            this.index = null;
        }
    }else{
        this.nVertices = this.getAttribute("position").count;
    }

    this.autoSetDrawRange();

    return this;
};

BufferLineGeometry.prototype.clone = function(){
    return (new BufferLineGeometry()).copy(this);
};

BufferLineGeometry.prototype.fromBufferGeometry = function (source) {
    return this.copy(source);
};

/**
 *  Return a new geometry merging all elements in arr_g with this.
 *  If one attribute is defined in a geometry but not in the other,
 *  it will not be present in the resulting geometry.
 *
 *  STATIC
 */
BufferLineGeometry.merge = function(arr_g){
    var arr = arr_g.slice(0,arr_g.length);

    // first, check that the geometries can actually be merged.
    // - same attributes
    // - if one is deindexed, the resulting will be deindexed

    // Compute the total number of vertices, faces, and list all attributes
    var total_vertices = 0;
    var attributes = {};
    var v_offset = [];
    for(var i=0; i<arr.length; ++i){
        total_vertices += arr[i].vertexCount();
        var akeys = Object.keys(arr[i].attributes);
        for(var k=0; k<akeys.length; ++k){
            var attr_name = akeys[k];
            if(i===0){
                attributes[attr_name] = {
                    constructor : arr[i].attributes[attr_name].array.constructor,
                    itemSize : arr[i].attributes[attr_name].itemSize
                };
            }
        }
        if(i!==0){
            akeys = Object.keys(attributes);
            for(var k=0; k<akeys.length; ++k){
                var attr_name = akeys[k];
                if(arr[i].attributes[attr_name] === undefined){
                    delete attributes[attr_name];
                }else if(arr[i].attributes[attr_name].itemSize !== attributes[attr_name].itemSize){
                    console.warn("Merging geometries show same attributes but with different itemSize (attribute concerned : "+attr_name+")")
                    delete attributes[attr_name];
                }
            }
            v_offset.push(v_offset[i-1]+arr[i-1].vertexCount());
        }else{
            v_offset.push(0);
        }
    }

    var res = new BufferLineGeometry();
    res.resizeBuffers(total_vertices, this.nSegments);

    var keys = Object.keys(attributes);
    for(var k=0; k<keys.length; ++k){
        var attr_name = keys[k];
        res.addAttribute(
            keys[k],
            new BufferAttribute(
                new attributes[attr_name].constructor(total_vertices*attributes[attr_name].itemSize),
                attributes[attr_name].itemSize
            )
        );
        var curr_attr = res.getAttribute(attr_name);
        var offset = 0;
        for(var i=0; i<arr.length; ++i){
            curr_attr.array.set(
                arr[i].attributes[attr_name].array.slice(0, arr[i].vertexCount()*curr_attr.itemSize),
                offset*curr_attr.itemSize
            );
            offset += arr[i].vertexCount();
        }
    }
    res.nVertices = total_vertices;

    return res;
};

/**
 *  Copied from DualBox3D
 */
BufferLineGeometry.prototype.normalizeNormals = function () {

    var normals = this.attributes.normal.array;

    var x, y, z, n;

    for ( var i = 0, il = this.nVertices*3; i < il; i += 3 ) {
        x = normals[ i ];
        y = normals[ i + 1 ];
        z = normals[ i + 2 ];

        n = 1.0 / Math.sqrt( x * x + y * y + z * z );

        normals[ i ] *= n;
        normals[ i + 1 ] *= n;
        normals[ i + 2 ] *= n;
    }
};



/**
 *  TODO : implement it. Can fin inspiration in BufferTriGeometry
 *
 *  @return {BufferLineGeometry} The geometry extrusion of the line (a surface)
 */
BufferLineGeometry.prototype.extrude = function(dist, dir, connect){
    throw "Line extrusion not implemented. ";
    //return new BufferLineGeometry();
};

/**
 *  Transform the mesh to get its coordinate in a new basis.
 *  @param {Vector3} O Origin of the new basis
 *  @param {Vector3} newX Origin of the new basis
 *  @param {Vector3} newY Origin of the new basis
 *  @param {Vector3} newZ Origin of the new basis
 */
BufferLineGeometry.prototype.toOrthonormalBasis = function(O, newX, newY, newZ){
    var mat4 = new Matrix4();
    mat4.set(   newX.x, newY.x, newZ.x, O.x,
                newX.y, newY.y, newZ.y, O.y,
                newX.z, newY.z, newZ.z, O.z,
                0,0,0,1);
    mat4.getInverse(mat4.clone());
    this.applyMatrix(mat4);
}

/**
 *  Projection function
 *  @param {Array.<BufferGeometry|HeightMap>} objects The object on
 *         which we want to project.
 *  @param {number} max_dist The maximum projection distance
 *  @param {Vector3=} dir Direction in wich we want to extrude,
 *                              if undefined, vertex normals will be used
 */
BufferLineGeometry.prototype.project = function(objects, max_dist, dir){

    if(this.attributes.position === undefined){
        console.error("Error : BufferLineGeometry.prototype.project needs position");
    }
    if(dir === undefined && this.attributes.normal === undefined){
        console.warn("BufferLineGeometry.project : no normals on the mesh, no projection dir. Computing mesh normals...");
        this.computeVertexNormals();
    }

    var position = this.getAttribute('position');
    var n_vertices = this.nVertices;

    var normal = this.getAttribute('normal');

    var vec = new Vector3();
    var n = new Vector3();
    var raycaster = new Raycaster();
    var origin = new Vector3();
    var direction = new Vector3(0,0,1);

    for(var i=0; i<n_vertices; ++i){
        vec.set(position.getX(i),position.getY(i),position.getZ(i));
        direction.copy(
            dir !== undefined? dir : n.set(normal.getX(i),normal.getY(i),normal.getZ(i))
        );
        origin.set(position.getX(i),position.getY(i),position.getZ(i));
        raycaster.set(origin, direction);
        var intersects = raycaster.intersectObjects(objects);
        var dist = (intersects.length !== 0 ? Math.min(max_dist,intersects[0].distance) : max_dist);
        position.setXYZ(i,
            origin.x + dist*direction.x,
            origin.y + dist*direction.y,
            origin.z + dist*direction.z
        );
    }

    position.needsUpdate = true;
};

/**
 *  Get distance to the line
 *
 *  @param {Vector3} point
 */
BufferLineGeometry.prototype.distanceToPoint = function(point)
{
    throw "distanceToPoint is not implemented";
};


/**
 *  Get distance to the line
 *  Note : if the line has only one point, this function will return an empty geometry.
 *
 *  Note : will not give nice results
 *      - if the radius is greater than half the miniumum segment of the line.
 *      - if the angle between 2 segments is less than 90Â°
 *   In this cases, self intersection can occur and flipped triangles can occur.
 *
 *  @param {
 *      radialSegments number of dsegment around a cut.
 *      caps "round" or "flat"
 *      radius The radius of the tube.
 * }
 */
 // dev notes : passing params as a dictionnary allows for more flexibility later
 // and do not impact performances nor lisibility.
BufferLineGeometry.prototype.makeTube = (function(){
    var createVertexRing = function(g, vec, dir, ort_dir, radius, radial_res){
        var curr_rad = ort_dir.clone();
        var vattr = {
            position : new Vector3()
        };
        for(var i=0; i<radial_res; ++i){
            vattr.position.copy(curr_rad).multiplyScalar(radius).add(vec);
            g.addVertex(vattr);
            Vector3Utils.rotateAroundAxis(curr_rad, dir, -2*Math.PI/radial_res);
        }
    };

    var createFirstRoundVertexRings = function(g, vec, dir, ort_dir, radius, radial_res){

        var l_vec = new Vector3();

        var steps = Math.ceil(radial_res/4);
        for(var i=1; i<steps; ++i){
            var ratio = Math.cos((i/steps)*Math.PI*0.5);;
            l_vec.set(
                vec.x - ratio*radius*dir.x,
                vec.y - ratio*radius*dir.y,
                vec.z - ratio*radius*dir.z
            );
            createVertexRing(g, l_vec, dir, ort_dir, Math.sqrt(1-ratio*ratio)*radius, radial_res);
            if(i!==1){
                connectPrevRing(g, radial_res);
            }
        }
    };

    var createLastRoundVertexRings = function(g, vec, dir, ort_dir, radius, radial_res){

        var l_vec = new Vector3();

        var steps = Math.ceil(radial_res/4);
        for(var i=1; i<steps; ++i){
            var ratio = Math.sin((i/steps)*Math.PI*0.5);
            l_vec.set(
                vec.x + ratio*radius*dir.x,
                vec.y + ratio*radius*dir.y,
                vec.z + ratio*radius*dir.z
            );
            createVertexRing(g, l_vec, dir, ort_dir, Math.sqrt(1-ratio*ratio)*radius, radial_res);
            connectPrevRing(g, radial_res);
        }
    };


    var connectPrevRing = function(g, radial_res){
        // g should be at least 2*radial_res vertices.
        // Connect the last ring with te previous one.
        var nv = g.vertexCount();
        for(var i=0; i<radial_res-1; ++i){
            var idx = nv-2*radial_res+i;
            // quad face : idx, idx+radial_res, idx+radial_res+1, idx+1
            g.addFace(idx, idx+radial_res, idx+radial_res+1);
            g.addFace(idx+radial_res+1, idx+1,idx);
        }
        // nv-radial_res-1, nv-1, nv-radial_res, nv-2*radial_res
        g.addFace(nv-radial_res-1, nv-1, nv-radial_res);
        g.addFace(nv-radial_res, nv-2*radial_res,nv-radial_res-1);
    };

    /**
     *  Next orthogonal direction vector is computed to be the vector on the
     *  next dir orthogonal plane wich is the closer to the previous orthogonal
     *  direction.
     */
    var computeOrtDir = function(vec, dir, prev_ort_dir, res){
        // Get 2 vectors to have a base for the plane of normal dir passing through vec
        var baseX = new Vector3();
        Vector3Utils.GetOrthogonalRandVect(dir, baseX);
        baseX.normalize();
        var baseY = (new Vector3()).crossVectors(dir,baseX);
        baseY.normalize();

        var dotX = prev_ort_dir.dot(baseX);
        var dotY = prev_ort_dir.dot(baseY);

        if(Math.abs(dotX) > 0.001 || Math.abs(dotY) > 0.001){
            res.set(
                dotX*baseX.x+dotY*baseY.x,
                dotX*baseX.y+dotY*baseY.y,
                dotX*baseX.z+dotY*baseY.z
            );
        }else{
            res.copy(baseX);
        }

        res.normalize();

        return res;
    };

    var closeTube = (function(){
        var vattr = {
            position : new Vector3()
        };
        return function(g, radial_res, start, end){
            vattr.position.copy(start);
            var idx_cent_start = g.vertexCount();
            g.addVertex(vattr);
            vattr.position.copy(end);
            var idx_cent_end = g.vertexCount();
            g.addVertex(vattr);
            var idx_end = g.vertexCount()-2-radial_res;
            for(var i=0; i<radial_res-1; ++i){
                g.addFace(idx_end+i+1,idx_end+i,idx_cent_end);
                g.addFace(i,i+1,idx_cent_start);
            }
            g.addFace(idx_end,idx_end+radial_res-1,idx_cent_end);
            g.addFace(radial_res-1,0,idx_cent_start);
        };
    })();

    return function(params) // radius, radialSegments, caps ("flat" or "round")
    {
       // Needs integer for resolution. Convenience rounding.
        var radial_res = params.radialSegments;

        if(radial_res<=2){
            console.warn("Warning : radialSegments must be at least 3.")
            radial_res = 3;
        }

        var g = new BufferTriGeometry();
        // TODO : optim : preallocate the good number of vertices and faces.
        //                then use setFace / setVertex instead of add.
        if(this.nVertices<2){
            return g;
        }


        var position = this.attributes.position;

        var start = new Vector3(position.getX(0),position.getY(0),position.getZ(0));
        var end = new Vector3(position.getX(this.nVertices-1),position.getY(this.nVertices-1),position.getZ(this.nVertices-1));

        // when rounding the extremities, the final tube will start and end earlier/later
        // The difference is "radius" in both directions.
        var real_start = start.clone();
        var real_end = end.clone();

        var vec = start.clone();
        var vec_next = (new Vector3()).set(position.getX(1),position.getY(1),position.getZ(1));
        var dir = (new Vector3()).subVectors(vec_next, vec);
            dir.normalize();
        var ort_dir = new Vector3();
            Vector3Utils.GetOrthogonalRandVect(dir, ort_dir);
            ort_dir.normalize();
        var prev_ort_dir = ort_dir.clone();

        for(var i=0; i<this.nVertices; ++i){
            vec.set(position.getX(i),position.getY(i),position.getZ(i));
            if(i<this.nVertices-1){
                vec_next.set(
                    position.getX(i+1),
                    position.getY(i+1),
                    position.getZ(i+1)
                );
                dir.subVectors(vec_next, vec);
                dir.normalize();
                prev_ort_dir.copy(ort_dir);
                computeOrtDir(vec, dir, prev_ort_dir, ort_dir);
            }
            if(i===0){
                if(params.caps === "round"){
                    real_start.copy(dir).multiplyScalar(-params.radius).add(vec);
                    createFirstRoundVertexRings(g, vec, dir, ort_dir, params.radius, radial_res);
                }else{ // params.caps === "flat"
                    createVertexRing(g, vec, dir, ort_dir, 0.95*params.radius, radial_res);
                }
            }
            createVertexRing(g, vec, dir, ort_dir, params.radius, radial_res);
            connectPrevRing(g, radial_res);
            if(i===this.nVertices-1){
                if(params.caps === "round"){
                    real_end.copy(dir).multiplyScalar(params.radius).add(vec);
                    createLastRoundVertexRings(g, vec, dir, ort_dir, params.radius, radial_res);
                }else{ // params.caps === "flat"
                    createVertexRing(g, vec, dir, ort_dir, 0.95*params.radius, radial_res);
                    connectPrevRing(g, radial_res);
                }

            }
        }

        closeTube(
            g,
            radial_res,
            real_start,
            real_end
        );

        return g;
    };
})();


///////////////////////////////////////////////////////////////////////////////
// FILE FORMAT MANAGEMENT                                                    //
///////////////////////////////////////////////////////////////////////////////

/**
*  Convert into a JSON object.
*  JSON will be the same as BufferGeometrry THREE JSON.
*  @param {Object} options Option dictionnary.
*                  {boolean} vt : export vertex texture uvs
*                  {boolean} vn : export vertex normals, default to true
*                  {number}  min_prec : number of fixed digit to keep after 0.
*                  {number}  prec : precision, ie number of significant digit to keep.
*  @param {boolean} data_only If true, the result will only contain the data, not the type.
*                             data is such that the exported json is THREE.JS compatible.
*/
BufferLineGeometry.prototype.toJSON = function(options, data_only){
    this.minimizeBuffers(); // not optimized, to be better we would need to
    // rewrite toJSON taking vertexCount() and faceCount() into account.
    var t = this.type;
    this.type = (new BufferGeometry()).type;
    var res = BufferGeometry.prototype.toJSON.call(this);
    this.type = t;

    var options = options || {};
    // Apply options
    if(options.vn === false){
        delete res.data.attributes.normal;
    }
    if(options.uv === false){
        delete res.data.attributes.uv;
    }

    var toPrecision = function(n){
        var res = n;
        if(options.min_prec){
            res = parseFloat(n.toFixed(options.min_prec));
        }
        if(options.prec){
            res = parseFloat(res.toPrecision(options.prec));
        }

        return res;
    };
    if(options.min_prec || options.prec){
        var p = res.data.attributes.position.array;
        for(var i=0; i<p.length; ++i){
            p[i] = toPrecision(p[i]);
        }
    }

    res.metadata.__xthree = {
        type:BufferLineGeometry.type,
        lineSegments:this.lineSegments
    };

    return res;
};
/**
*  @param {Object} json A json description, built from a toJSON call
*/
BufferLineGeometry.prototype.fromJSON = function(json){
    this.dispose();

    if(json.metadata && json.metadata.type !== BufferLineGeometry.type){
        throw "Error : the given JSON is obviously not an BufferLineGeometry export.";
    }

    var loader = new BufferGeometryLoader();
    if(json.metadata.__xthree && json.metadata.__xthree.type === BufferLineGeometry.type){
        this.copy(loader.parse(json));
        this.lineSegments = json.metadata.__xthree.lineSegments;
    }else if(json.metadata.type === BufferLineGeometry.type && json.data !== undefined && Object.keys(json).length === 2){
        this.copy(loader.parse(json.data));
        this.lineSegments = json.lineSegments;
    }else{ // else the data must be BufferGeometry data
        this.copy(loader.parse(json));
    }

    return this;
};
BufferLineGeometry.fromJSON = function(json){
    var g = new BufferLineGeometry();
    if(json.metadata === undefined){
        var nv = 0;
        if(json.vertices !== undefined){
            nv = json.vertices.length/3;
            if(Math.round(nv) !== nv){
                throw new errors.TypeError("Error : line geometry default value vertices must be an array with length as a multiple of 3");
            }
            g.setVertexNumber(nv);
            g.setVertexAttribute("position", json.vertices);
        }
        if(json.normals !== undefined){
            var nn = json.normals.length/3;
            if(Math.round(nn) !== nn){
                throw new errors.TypeError("Error : line geometry default value normals must be an array with length as a multiple of 3");
            }
            if(nn != nv){
                throw new errors.TypeError("Error : line geometry default value must have as many normals as vertices");
            }
            g.setVertexAttribute("normal", json.normals);
        }
    }else{
        g.fromJSON(json);
    }
    return g;
};


////////////////////////////////////////////////////////////////////////
// Under development, untested and never used
///////////////////////////////////////////////////////////////////////////////


// Same as for triangular geometries.
// Untested and never used CHEC BEFORE USING..
BufferLineGeometry.prototype.computeAverageUScale = function () {

    var geometry = this;

    var index = geometry.index;
    var attributes = geometry.attributes;

    if ( index === null ||
         attributes.position === undefined ||
         attributes.u === undefined ) {

        console.warn( 'BufferGeometry: Missing required attributes (position, u)' );
        return;

    }

    var positions = attributes.position.array;
    var us = attributes.u.array;

    var nVertices = this.nVertices;

    if ( attributes.uscale === undefined ) {

        geometry.addAttribute( 'uscale', new BufferAttribute( new Float32Array( nVertices ), 1 ) );

    }else{
        attributes.uvscale = new BufferAttribute( new Float32Array( nVertices ), 1 );
    }

    var uscale = attributes.uscale;
    var average = new Float32Array( nVertices );

    var tmp_v = new Vector3();
    var vA = new Vector3();
    var vB = new Vector3();
    var prev_uscale = 0;
    var curr_uscale = 0;

    for(var i=0; i<nVertices-1; ++i){
        vA.set(
            positions.getX(i), positions.getY(i), positions.getZ(i)
        );
        vB.set(
            positions.getX(i+1), positions.getY(i+1), positions.getZ(i+1)
        );
        var lAB = (tmp_v.subVectors(vB,vA)).length();
        curr_uscale = (us.getX(i+1)-us.getX(i))/lAB;

        uscale.setX(i,0.5*(prev_uscale+curr_uscale));
        prev_uscale = curr_uscale;
    }
    uscale.setX(nVertices-1,prev_uscale);

    attributes.uscale.needsUpdate = true;

};
// Same as for triangular geometries.
// Untested and never used CHEC BEFORE USING.,
// NOTE : this function does not take into account uvs if they exists.
//        therefore it is only valid on lines with increasing uvs...
BufferLineGeometry.prototype.computeTangents = function () {

    var geometry = this;

    var index = geometry.index;
    var attributes = geometry.attributes;

    if ( index === null ||
         attributes.position === undefined ||
         attributes.normal === undefined ) {

        console.warn( 'BufferGeometry: Missing required attributes (position, u)' );
        return;

    }

    var positions = attributes.position.array;
    var normals   = attributes.normal.array;

    var nVertices = this.nVertices;

    if ( attributes.tangent === undefined ) {
        geometry.addAttribute( 'tangent', new BufferAttribute( new Float32Array( 3*nVertices ), 3 ) );
    }else{
        attributes.tangent = new BufferAttribute( new Float32Array( 3*nVertices ), 3 );
    }

    var tangent = attributes.tangent;
    var average = new Float32Array( nVertices );

    var tmp_v = new Vector3();
    var vA = new Vector3();
    var vB = new Vector3();
    var prev_tan = new Vector3();
    var curr_tan = new Vector3();

    for(var i=0; i<nVertices-1; ++i){
        vA.set(
            positions.getX(i), positions.getY(i), positions.getZ(i)
        );
        vB.set(
            positions.getX(i+1), positions.getY(i+1), positions.getZ(i+1)
        );
        curr_tan.subVectors(vB,vA);
        curr_tan.normalize();
        tmp_v.addVectors(prev_tan,curr_tan);
        tmp_v.normalize();
        tangent.setXYZ(i,tmp_v.x,prev_tan.y,prev_tan.z);
        prev_tan.copy(curr_tan);
    }
    tangent.setXYZ(nVertices-1,prev_tan.x,prev_tan.y,prev_tan.z);

    attributes.tangent.needsUpdate = true;

};



// Same as for triangular geometries.
// Untested and never used CHEC BEFORE USING..
BufferLineGeometry.prototype.applyDisplacement = function(disp){

    var v = new Vector3();
    var n = new Vector3();
    var tan = new Vector3();
    var u = 0;
    var nu = new Vector2();

    if ( this.attributes.tangent === undefined ) {
        this.computeTangents();
    }
    if ( this.attributes.uscale === undefined ) {
        this.computeAverageUScale();
    }

    var vertices = this.getAttribute('position');
    var normals = this.getAttribute('normal');
    var tangents = this.getAttribute('tangent');
    var us = this.getAttribute('u');
    var uscale = this.getAttribute('uscale');
    for(var i=0; i<this.nVertices; ++i){
        v.set(vertices.getX(i),vertices.getY(i),vertices.getZ(i));
        n.set(normals.getX(i),normals.getY(i),normals.getZ(i));
        tan.set(tangents.getX(i),tangents.getY(i),tangents.getZ(i));
        u.set(us.getX(i), us.getY(i));

        var d = disp.getDispFromU(u.x);
        disp.getNormalFromU(u.x,nu);

        vertices.setX(i, v.x + d*n.x);
        vertices.setY(i, v.y + d*n.y);
        vertices.setZ(i, v.z + d*n.z);
        nu.x *= uscale.getX(i);
        nu.normalize();

        normals.setX(i,nu.x*tan.x + nu.y*n.x);
        normals.setY(i,nu.x*tan.y + nu.y*n.y);
        normals.setZ(i,nu.x*tan.z + nu.y*n.z);
    }

    vertices.needsUpdate = true;
    normals.needsUpdate = true;
};

module.exports = BufferLineGeometry;

