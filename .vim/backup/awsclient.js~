import AWS from 'aws-sdk';
import path from 'path';
import Future from 'fibers/future';
import url from 'url';

const crypto = require('crypto');

// Slingshot directive to allow user->aws direct upload
Slingshot.createDirective("fileUpload", Slingshot.S3Storage, {
    bucket: Meteor.settings.AWS.bucket,
    region: Meteor.settings.AWS.region, // see http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region
    acl: "public-read",
    maxSize: 10 * 1024 * 1024, // 10 MB
    allowedFileTypes: null,

    AWSAccessKeyId: Meteor.settings.AWS.accessKeyId,
    AWSSecretAccessKey: Meteor.settings.AWS.secretAccessKey,

    authorize: function () {
        //Deny uploads if user is not logged in.
        if (!this.userId) {
            var message = "Please login before posting files";
            throw new Meteor.Error("Login Required", message);
        }

        return true;
    },

    key: function (file) {
        var key = this.userId + "_" + file.name + "_" + file.size;
        console.log("retrieving upload path for file " + key + ": " + userUploadPath[key]);
        var userPath = userUploadPath[key] || path.join(this.userId, "drive", file.name)
        var p = path.join(phasePath(), userPath);
        console.log("file upload request: path=" + p);
        return p;
    }
});
userUploadPath = {}; // to be filled by method drive.setUploadPath

AWS.config.update({
    accessKeyId:     Meteor.settings.AWS.accessKeyId,
    secretAccessKey: Meteor.settings.AWS.secretAccessKey,
});

AWSClient = class AWSClient {
    constructor( userId, rootPath = "" ) {
        this.phase    = phasePath();
        this.bucket   = Meteor.settings.AWS.bucket;
        this.region   = Meteor.settings.AWS.region;
        this.cdnRootUrl = "https://" + Meteor.settings.public.cloudfrontHost + "/";
        this.s3RootUrl = "https://" + this.bucket + ".s3." + this.region + ".amazonaws.com/";
        this.cloudfrontDistributionId = Meteor.settings.public.cloudfrontDistributionId;

        if( userId ) {
            // set up the drive for this user
            this.userId   = userId;
            this.userPath = path.join(this.phase, this.userId);
            this.userDrivePath = path.join(this.userPath, "drive");
            this.userAppsPath = path.join(this.userPath, "apps");
        }
        else {
            // general AWS client, set up the base rootpath
            this.userId = null;
            this.rootPath = rootPath ? rootPath : "";
        }

        console.log('setup aws client with cloudfront url: ' + this.cdnRootUrl);
    }

    log(msg) {
        console.log("AWSClient[" + this.userId + "]: " + msg);
    }

    prefixPath( filePath ) {
        var prefix = this.userId ? this.userDrivePath : this.rootPath;

        if( filePath.startsWith(prefix) ) {
            return filePath; // already prefixed
        }
        else {
            return path.join(prefix, filePath);
        }
    }

    list( folderPath, continuationToken, cb ) {
        var fullPath = this.prefixPath( folderPath );
        this.log("listing path: " + fullPath);

        // configure s3 api
        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Prefix: path.join(fullPath, '/'),
            Delimiter: '/',
            MaxKeys: 500,
        }

        // if we are continuing a previous request (i.e: "load more")
        if( continuationToken ) {
            params.ContinuationToken = continuationToken;
        }

        cb = Meteor.bindEnvironment(cb);
        s3.listObjectsV2(params, cb);
    }

    deleteFile( filePath, cb ) {
        var fullPath = this.prefixPath( filePath );

        // configure s3 api
        var s3 = new AWS.S3();
        var params = {
            Bucket: this.bucket,
            Key : fullPath,
        }
        this.log("deleting file " + params.Key);

        // bind meteor environment to callback
        cb = Meteor.bindEnvironment(cb);
        s3.deleteObject(params, cb, s3)
    }

    deleteFolder( folderPath, cb ) {
        var self = this;
        var fullPath = this.prefixPath( folderPath );
        this.log("deleting folder " + fullPath);

        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Prefix: fullPath
        };

        // we need to delete 1 by 1 all items in the folder
        s3.listObjectsV2(params, Meteor.bindEnvironment(function(err, data) {
            if( err ) {
                cb(err, null);
                return;
            }

            var futures = [];
            for(var i=0; i<data.Contents.length; i++) {
                // launch the delete in a closure scope
                (function() {
                    var file = data.Contents[i];
                    var params = {
                        Key: file.Key,
                        Bucket: Meteor.settings.AWS.bucket,
                    }

                    var fut = new Future();
                    var callback = Meteor.bindEnvironment(function(err, r) {
                        if( err ) { fut.throw(err); } else { fut.return(r); }
                    });
                    if( file.Key.endsWith('/') && file.Key != fullPath ) {
                        self.deleteFolder(file.Key, callback);
                    }
                    else {
                        self.deleteFile(file.Key, callback);
                    }

                    futures[i] = fut;
                })();
            }

            // wait for all futures
            for(var i=0; i<futures.length; i++) {
                futures[i].wait();
            }

            cb(null, true);
        }));
    }

    delete( filePath, cb ) {
        if( filePath.endsWith('/') ) {
            return this.deleteFolder(filePath, cb);
        }
        else {
            return this.deleteFile(filePath, cb);
        }
    }

    createFolder(folderPath, cb) {
        var fullPath = this.prefixPath(folderPath);
        fullPath = pathUtils.suffix(fullPath, '/');
        cb = Meteor.bindEnvironment(cb);

        this.log("creating folder: " + fullPath);

        // configure s3 api
        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Key: fullPath,
            CacheControl: 'max-age=86400',
            ACL: 'public-read',
            Body: '.'
        }
        s3.upload(params, cb);
    }

    moveFile(srcPath, dstPath, cb) {
        var srcFullPath = this.prefixPath(srcPath,'/');
        var dstFullPath = pathUtils.suffix(this.prefixPath(dstPath),'/');
        var fileName = path.basename(srcFullPath);
        cb = Meteor.bindEnvironment(cb);

        this.log("moving file " + fileName + " from " + srcFullPath + " to " + dstFullPath);

        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            CopySource: path.join(Meteor.settings.AWS.bucket,srcFullPath),
            Key : path.join(dstFullPath, fileName)
        };

        var self = this;
        var fut = new Future();
        s3.copyObject(params, Meteor.bindEnvironment(function(err, res){
            if(err) {
                fut.throw(err);
            }
            else {
                self.log("copied file " + fileName + " from " + srcFullPath + " to " + dstFullPath);

                // now delete the file
                self.deleteFile(srcFullPath, Meteor.bindEnvironment(function(err, r) {
                    if(err) {
                        fut.throw(err);
                    }
                    else {
                        self.log("deleted file " + srcFullPath);
                        fut.return(r);
                    }
                }));
            }
        }));

        cb(null, fut.wait());
    }

    moveFolder(srcPath, dstPath, cb) {
        var fileName = path.basename(srcPath);
        var srcFullPath = pathUtils.suffix(this.prefixPath(srcPath),'/');
        var dstFullPath = pathUtils.suffix(this.prefixPath(path.join(dstPath, fileName)),'/');
        cb = Meteor.bindEnvironment(cb);

        this.log("moving folder " + fileName + " from " + srcFullPath + " to " + dstFullPath);

        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Prefix: srcFullPath
        };

        var fut = new Future();
        var self = this;

        // we don't need to go recursive since listObjects will list also all subfolders content
        s3.listObjectsV2(params, Meteor.bindEnvironment(function(err, data) {
            if( err ) {
                fut.throw(err);
            }

            var futures = [];
            for(var i=0; i<data.Contents.length; i++) {

                // launch the delete in a closure scope
                (function() {
                    var file = data.Contents[i];
                    var f = new Future();
                    var callback = function(err, r) {
                        if( err ) f.throw(err); else f.return(r);
                    }

                    if( file.Key.endsWith('/') ) {
                        // use deleteFile instead of deleteFolder to avoid recursive delete
                        self.createFolder(file.Key.replace(srcFullPath, dstFullPath), function() {
                            self.deleteFile(file.Key, callback);
                        });
                    }
                    else {
                        let dst = path.dirname(file.Key.replace(srcFullPath, dstFullPath));
                        self.moveFile(file.Key, dst, callback);
                    }
                    futures[i] = f;
                })();
            }

            // wait for all futures
            for(var i=0; i<futures.length; i++) {
                futures[i].wait();
            }

            fut.return(true);
        }));

        cb(null, fut.wait());
    }

    move(srcPath, dstPath, cb) {
        if( srcPath.endsWith('/') ) {
            return this.moveFolder(srcPath, dstPath, cb);
        }
        else {
            return this.moveFile(srcPath, dstPath, cb);
        }
    }

    // p: path to invalidate cache, can countain "*"
    // id: unique id for this invalidation
    invalidateCache(p, cb) {
        var fullPath = this.prefixPath( p );
        fullPath = path.join("/", fullPath); // cloudfront needs to prefix with the bucket
        console.log('fullPath: ' + fullPath);

        var cloudfront = new AWS.CloudFront();
        var params = {
            DistributionId: this.cloudfrontDistributionId,
            InvalidationBatch: {
                CallerReference: this.userId + '#' + (new Date()).getTime(), /* unique id */
                Paths: {
                    Quantity: 1, /* no limit to the number of items to invalidate */
                    Items: [ fullPath ]
                }
            }
        };

        cloudfront.createInvalidation(params, cb);
    }

    uploadAppVersion( appVersion, script, cb) {
        cb = Meteor.bindEnvironment(cb);

        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Key: path.join(
                this.userAppsPath,
                appVersion.appName,
                appVersion.appVersion + '-' + crypto.randomBytes(20).toString('hex') + ".js"
            ),
            ContentType: "application/javascript",
            Body: script
        };
        var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
        s3.upload(params, options, cb);
    }

    deleteAppVersion( appVersion, cb ) {
        cb = Meteor.bindEnvironment(cb);

        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Key: path.join(this.userAppsPath, appVersion.appName, appVersion.appVersion + ".js"),
        };
        s3.deleteObject(params, cb, s3)
    }

    // componentName: name of the package (ex: @dualbox/dualbox)
    // componentVersion: name of the version (ex: 1.0.64)
    // script: the .js script
    // debug: boolean flag (true if the script is the debug .js file, false if it's the .min.js)
    uploadComponentScript( componentName, componentVersion, script, debug, cb ) {
        cb = Meteor.bindEnvironment(cb);

        /*
        if( componentName.indexOf('@') !== -1 ) {
            componentName = componentName.replace('@', '');
        }
        */

        if( componentName.indexOf('/') !== -1 ) {
            var s = componentName.split('/');
            var baseName = s[s.length - 1];
        }
        else {
            var baseName = componentName;
        }

        var extension = debug ? ".js" : ".min.js";
        var fileName = baseName + "-" + componentVersion + extension;

        var s3 = new AWS.S3();
        var params = {
            Bucket: Meteor.settings.AWS.bucket,
            Key: path.join(
                this.rootPath,
                "components",
                componentName,
                fileName
            ),
            ContentType: "application/javascript",
            Body: script
        };
        var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
        s3.upload(params, options, cb);
    }

    rootUrl() {
        return url.resolve("https://" + this.bucket + ".s3." + this.region + ".amazonaws.com/", this.userDrivePath);
    }

    getCdnLocation( url ) {
        return url.replace(/http.*amazonaws.com\//, this.cdnRootUrl);
    }

    resolve(path) {
        console.log('root url: ' + this.rootUrl());
        return url.resolve( this.rootUrl() + "/", path ) + "?nocache=" + (new Date().getTime());
    }
}
