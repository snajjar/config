// File to manage easily a transition from a subscription cache package to another (or back to Meteor).
// Right now, both kadirahq:subsmanager and ccorcos:subs-cache seems to be abandonned
// Fork elvishjerricco:subs-cache might be worth the try

/**
 *   Wrap the Meteor subscription handle in a more handy object
 */
var SubscriptionHandle = function( args ) {
    this.handle     = null;
    this.args       = args;
    this.subName    = args[0];
    this.lastSubscribed = new Date();

    // reactive var that's updated when the sub is ready
    this.subReady   = new ReactiveVar(false);
    this.subDep     = new Deps.Dependency();

    this.computation = null;
    if( Tracker.currentComputation ) {
        var self = this;
        Tracker.afterFlush(function() {
            self.setupTracker();
        });
    }
    else {
        this.setupTracker();
    }
}

SubscriptionHandle.prototype.setupTracker = function() {
    // update subReady when the subscription is ready
    var self = this;
    this.computation = Tracker.autorun(function(c) {
        self.subDep.depend();

        if( self.handle && self.handle.ready() ) {
            self.subReady.set(true);
            c.stop();
        }
    });
}

SubscriptionHandle.prototype.update = function() {
    //console.debug("[Subscription Manager] updating subscription %s", this.subName);
    this.lastSubscribed = new Date();
}

SubscriptionHandle.prototype.ready = function() {
    return this.subReady.get();
}

SubscriptionHandle.prototype.run = function() {
    if( Meteor.isClient ) {
        if( !this.handle ) {
            var self = this;
            Tracker.nonreactive(function() {
                //console.debug("[Subscription Manager] subscribing to %s with %s", self.subName, JSON.stringify(self.args));
                self.handle = Meteor.subscribe.apply(Meteor, self.args);
                self.subDep.changed();
            });
        }
    }
    else {
        self.handle = Meteor.subscribe.apply(Meteor, self.args);
    }
}

SubscriptionHandle.prototype.onReady = function(cb) {
    if( this.handle && this.handle.ready() ) {
        cb();
    }
    else {
        var self = this;
        var t = setInterval( function(c) {
            if( self.handle && self.handle.ready() ) {
                //c.stop(); // stop this computation
                clearInterval(t);
                cb();
            }
        }, 10);
    }
}

SubscriptionHandle.prototype.stop = function() {
    this.handle.stop();
    this.handle = null;
}


/**
 *  Cache a set of subscriptions
 */
var SubscriptionManager = function( attrs ){
    // _cache is a double hash table
    // this._cache[subname][paramsHash] will give the proper handle
    this._cache = {};

    attrs = attrs || {};
    this.cacheLimit    = attrs.cacheLimit || 30;   // max number of subs cached
    this.pubCacheLimit = attrs.pubCacheLimit || 5; // max number of subs per publication
    this.expire        = attrs.expire || 0; // minutes

    this.dep = new Deps.Dependency();
    this.computation = null;

    // launch the tracker
    // this._runSubs();
}

// show debug logs of the subscription manager
SubscriptionManager.prototype.debug = function() {
    var subs = this.getSubs();

    //console.debug("[Subscription Manager] DEBUG: Subscription Manager is in ready state %s", this.ready());
    //_.each(subs, function(sub) {
        //console.debug("[Subscription Manager] DEBUG: %s is currently in ready state %s, and handle is in ready state %s", 
        //    sub.subName, sub.ready(), sub.handle.ready());
    //});
}

// do the effective subscribes, and handle cache expirations and limits
SubscriptionManager.prototype._runSubs = function() {
    var self = this;

    self.handleCacheExpirations();
    self.handleCacheLimits();

    var subs = self.getSubs();
    for(var i=0; i<subs.length; i++) {
        var sub = subs[i];
        sub.run();
    }
}

// add a new subscription to the cache manager
SubscriptionManager.prototype.subscribe = function() {
    if(Meteor.isClient) {
        var args = _.toArray(arguments);

        // extract subname and parameter hash to know when to rerun the sub
        var subName   = args[0];
        var paramsKey = JSON.stringify(args.slice(1));

        // create the subname if it doesn't exist yet
        if( !this._cache[subName] ) {
            this._cache[subName] = {};
        }

        if( !this._cache[subName][paramsKey] ) {
            var handle = Meteor.subscribe.apply(Meteor, args);
            var subHandle = new SubscriptionHandle(args);
            this._cache[subName][paramsKey] = subHandle;
        }
        else {
            this._cache[subName][paramsKey].update();
        }

        // run the subscriptions
        this._runSubs();

        return this._cache[subName][paramsKey];
    }
}

// get all the handle for a given subscription name
// or all handles if called without argument
SubscriptionManager.prototype.getSubs = function( subName ) {
    var subs = [];

    if( subName !== undefined ) {
        var subCache = this._cache[subName];
        if( subCache ) {
            var paramKeys = Object.keys(subCache);
            for(var i=0; i<paramKeys.length; i++) {
                subs.push( subCache[paramKeys[i]] );
            }
        }
    }
    else {
        var subNames = Object.keys(this._cache);
        for(var i=0; i<subNames.length; i++) {
            subs = subs.concat( this.getSubs(subNames[i]) );
        }
    }

    return subs;
}

// return true if all subscriptions are ready
SubscriptionManager.prototype.ready = function() {
    this.dep.depend();
    var subs = this.getSubs();

    for(var i=0; i<subs.length; i++) {
        if( !subs[i].ready() ) {
            return false;
        }
    }

    return true;
}

// call given callback if when all the subscriptions are ready
SubscriptionManager.prototype.onReady = function(cb) {
    var self = this;
    Tracker.autorun(function(c) {
        if( self.ready() ) {
            c.stop();
            cb();
        }
    });
}

// force all pending operations to complete
SubscriptionManager.prototype.flush = function() {
    Tracker.flush();
}

// stop and remove a subscription from the manager
SubscriptionManager.prototype.remove = function( subHandle ) {
    var subCache = this._cache[subHandle.subName];
    if( subCache && subCache[subHandle.paramsKey] ) {
        this._cache[subHandle.subName][subHandle.paramsKeys].stop();
        delete this._cache[subHandle.subName][subHandle.paramsKeys];
    }
}

// clear entirely the subscription manager
SubscriptionManager.prototype.clear = function() {
    var subNames = Object.keys(this._cache);
    for(var i=0; i<subNames.length; i++) {
        var subName = subNames[i];

        var params = Object.keys(this._cache[subName]);
        for(var j=0; j<params.length; j++) {
            var param = params[j];

            this.remove( this._cache[subName][param] );
        }
    }
};

// If cache limit are reached, remove subs that weren't used recently
SubscriptionManager.prototype.handleCacheLimits = function() {
    var self = this;

    // first, remove the publications that have too much subscriptions
    var keys = Object.keys(this._cache);
    for( var i=0; i<keys.length; i++ ) {
        var subName  = keys[i];
        var subCache = this._cache[ subName ];

        var cacheKeys = Object.keys( subCache );
        if( cacheKeys.length > self.pubCacheLimit ) {
            var toRemove = cacheKeys.length - self.pubCacheLimit;

            // sort the subs by date (from the oldest to the newest)  and remove the first 'toRemove' subscriptions
            var subs = self.getSubs(subName);
            subs = subs.sort( function(s1,s2) { return s1.lastSubscribed - s2.lastSubscribed } );
            for( var j=0; j<toRemove; j++ ) {
                //console.debug("[Subscription Manager] pubCacheLimit: too much elements on subscription " +
                //    subs[j].subName + ", removing oldest: " + subs[j].paramsKey);
                self.remove( subs[j] );
            }
        }
    }

    // then, remove the oldest publications if we exceed cacheLimit
    var subs = this.getSubs();
    if( subs.length > self.cacheLimit ) {
        var toRemove = subs.length - self.cacheLimit;

        subs = subs.sort( function(s1,s2) { return s1.lastSubscribed - s2.lastSubscribed } );
        for(var i=0; i<toRemove; i++) {
            //console.debug("[Subscription Manager] pubCacheLimit: too much elements on subscription " +
            //    subs[i].subName + ", removing oldest: " + subs[i].paramsKey);
            self.remove( subs[i] );
        }
    }
}

// Remove subs that are too old (given the cache expiration time)
SubscriptionManager.prototype.handleCacheExpirations = function() {
    var subs = this.getSubs();
    var now  = new Date();

    for(var i=0; i<subs.length; i++) {
        var sub = subs[i];
        var expirationDate = new Date( sub.lastSubscribed.getTime() + this.expire * 60000 );
        if( expirationDate < now ) {
            //console.debug("[Subscription Manager] Subcription expired: " + sub.subName + "(" + sub.paramsKey + ")");
            this.remove( sub );
        }
    }
}


subMgr = new SubscriptionManager();
