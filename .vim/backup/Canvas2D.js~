const DualBox = require('@dualbox/dualbox');
const pkgDesc = require('../package.json');

// for bundle compilation
if( DualBox.env.browser ) {
    require('@dualbox/dualbox-lib-pure-css-loader');
    require('./Canvas2D.css'); // for bundle compilation
}


/**
*   A 2D canvas
*/
class Canvas2D extends DualBox.UIComponent {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options)
        this.div = null;

        this.color = null;
        this.background = null;
    }

    resize(event) {
        if( this._container ) {
            var newWidth  = this._container.clientWidth;
            var newHeight = this._container.clientHeight;
            console.log("resize to " + newWidth + ", " + newHeight);

            // resize the container accordingly
            var innerContainer = DualBox.$('.dualbox-canvas2D-container');
            innerContainer.css('width', newWidth+'px');
            innerContainer.css('height', newHeight+'px');

            // internal available space
            var width  = innerContainer.innerWidth();
            var height = innerContainer.innerHeight();

            this.getCanvas().width = width;
            this.getCanvas().height = height;

            this.draw();
        }
    }

    getCanvas() {
        if( this.div === null ) {
            return null;
        }
        return this.div.find('.Canvas2D')[0];
    }

    draw() {
        var canvas = this.getCanvas();
        var ctx = canvas.getContext("2d");

        if(this.color !== null){
            ctx.fillStyle = "#" + this.color.getHexString();
            ctx.fillRect(0,0,canvas.width, canvas.height);
        }else{
            ctx.clearRect(0,0,canvas.width, canvas.height);
        }

        var drawAfterBG = function(){
            // put drawing code to execute after background drawing here.
        };

        if(this.background !== null){
            var bg = new Image();
            bg.src = this.background;
            bg.onload = function(){
                ctx.drawImage(bg, 0,0,canvas.width,canvas.height);
                drawAfterBG();
            };
        }else{
            drawAfterBG();
        }
    }

    // when all the data is there, display it in the scene
    onReady() {

        if(this.inputValue["background"] !== null){
            this.background = this.inputValue["background"];
        }
        if(this.inputValue["color"] !== null){
            this.color = this.inputValue["color"];
        }

        this.draw();

        // hide loading box
        this.div.find('.dualbox-canvas-loader').removeClass('is-active');

        // emit done to let other UI knows that they can re-enable themselves
        this.emit('done');

        // API - let the canvas now that the compute is finished
        DualBox.$(this._container).trigger('built');
    }

    onTrigger() {
        // show loading box
        this.div.find('.dualbox-canvas-loader').addClass('is-active');
        super.onTrigger();
    }

    /**
     *  Get a Dom element offset in the page
     *  @param {Object} el The dom element
     *  @return {{top:number,left:number}}
     */
    getElementOffset( el ) {
        var _x = 0;
        var _y = 0;
        while( el && !isNaN( el.offsetLeft ) && !isNaN( el.offsetTop ) ) {
            _x += el.offsetLeft;
            _y += el.offsetTop;
            el = el.offsetParent;
        }
        return { top: _y, left: _x };
    }

    computeMouseData(e){
        // Apply the canevas position offset to get
        // pageX and pageY relative to the upper left corner of the canvas
        var offsets = this.getElementOffset(this._renderer.domElement);
        this._canvasX = e.pageX - offsets.left;
        this._canvasY = e.pageY - offsets.top;
    }

    computeTouchData(e){
        // Apply the canevas position offset to get
        // pageX and pageY relative to the upper left corner of the canvas
        var offsets = this.getElementOffset(this._renderer.domElement);
        if( e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0] ) {
            this._canvasX = e.originalEvent.touches[0].pageX - offsets.left;
            this._canvasY = e.originalEvent.touches[0].pageY - offsets.top;
            console.log('x: ' + this._canvasX.toFixed(0) + ", y: " + this._canvasY.toFixed(0));
        }
    }

    onMouseDown(event) {

    }

    onMouseUp(event) {

    }

    onMouseMove(event) {

    }

    onTouchStart(event) {
    }

    onTouchEnd(event) {
    }

    onTouchMove(event) {
    }

    onWheel(e) {
    }

    onContextMenu(e) {
        e.preventDefault();
    }

    static attachTo(appDesc, div) {
        // build slider from package.json desc
        var canvas = new Canvas2D(pkgDesc, appDesc);
        canvas.warn('New Canvas2D instantiated');

        // create canvas div and bind events
        var cdiv = DualBox.$('<canvas/>', { class: "dualbox Canvas2D", style: "width: 100%; height: 100%;" });
        cdiv.mousedown( canvas.onMouseDown.bind(canvas) );
        cdiv.mouseup( canvas.onMouseUp.bind(canvas) );
        cdiv.mousemove( canvas.onMouseMove.bind(canvas) );
        cdiv.contextmenu( canvas.onContextMenu.bind(canvas) );
        cdiv.on("mousewheel", canvas.onWheel.bind(canvas) );

        // bind touch events too
        cdiv.on('touchstart', canvas.onTouchStart.bind(canvas));
        cdiv.on('touchend', canvas.onTouchEnd.bind(canvas));
        cdiv.on('touchmove', canvas.onTouchMove.bind(canvas));

        // get default loader text
        var loaderText = (appDesc.loader && appDesc.loader.text) || "Loading...";
        var loaderClass = (appDesc.loader && appDesc.loader.class) || "loader-default";

        // instanciate div from app.json parameters
        canvas.div = DualBox.$('<div/>', { class : "dualbox-canvas2D-container" }).append(
            cdiv,
            DualBox.$('<div/>', { "class":"dualbox dualbox-canvas-loader loader " + loaderClass + " is-active", "data-text": loaderText })
        );

        // append to param div
        DualBox.$(div).append(canvas.div);
        DualBox.$(div).on("build", canvas.onTrigger.bind(canvas) ); // give a "build" event to trigger computation

        canvas._container = div;
        DualBox.$(document).ready(function() {
            canvas.draw();
        });
        window.addEventListener('resize', canvas.resize.bind(canvas));

        // return the canvas
        return canvas;
    }
};

module.exports = Canvas2D;

