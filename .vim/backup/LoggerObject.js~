/**
 *   DualBox base object.
 *
 *   - has the ability to display smart logs
 *   - can listen/emit events
 *
 *   Design to separate DualBox logs and organize them depending on their origin
 */
"use strict";
const env = require('./Env.js');
const _ = require('lodash');
const colors = env.node ? require('colors') : {};
const errors = require('./Errors');

/*
 *   DualBox Console object definition
 */
var sconsole = {};
sconsole.getOptions = function( options ) {
    var opt = {}
    if( options !== undefined ) {
        opt = JSON.parse(JSON.stringify(options));
    }

    if( env.worker ) {
        opt.workerOrigin = true;
    }
    opt.prefix = "Console";
    return opt;
};

sconsole.logLevels = {
    "debug" : { value: 0, cssColor : "color: #666;", fnColor: colors.grey },
    "log"   : { value: 1, cssColor : "color: #000;", fnColor: colors.white },
    "info"  : { value: 2, cssColor : "color: #90f;", fnColor: colors.cyan },
    "warn"  : { value: 3, cssColor : "color: #ff9900;", fnColor: colors.yellow },
    "error" : { value: 4, cssColor : "color: #f00;", fnColor: colors.red },
}

sconsole.columns = [];
sconsole.columns_length = [];
sconsole.append = function(column, args, styles = [], minSize = 0) {
    this.columns[column] = {
        args   : args,
        styles: styles
    };

    if( this.columns_length[column] === undefined || this.columns_length[column] < minSize ) {
        this.columns_length[column] = minSize;
    }
}

sconsole.flush = function(level) {
    var args = [""];
    var css = [];

    // build the final arguments for the log message by inserting the css styles at the right place
    for(let i=0; i<this.columns.length; i++) {
        var col = this.columns[i];
        if( !col ) continue;

        // handle message alignment for this column
        // col.args[0] is our real string to be displayed, other arguments are sprintf params
        col.args[0] = col.args[0] + "%c ";

        // concat args to main args variable
        // first, add our string to the one already built
        args[0] += col.args[0];

        // then, concat the rest of the arguments:
        // first, the column style (for the first %c placed at begin)
        args = args.concat(col.styles || []);

        // then, sprintf arguments that came with the rest of the args
        args = args.concat( col.args.slice(1) );

        // then, push the column reset style (for the %c placed at the end)
        args.push("background: #fff; color: black;");
    }

    // clean console globals
    sconsole.columns = [];

    // write down the result to console
    console[level].apply(console, args);
}

sconsole.displayBrowser = function(origin, level, args, options) {
    if( options.fileAbsoluteLocation ) {
        sconsole.append(0, [options.fileAbsoluteLocation]);
    }

    if( options.codeLocation ) {
        sconsole.append(1, [options.codeLocation], [], 30 );
    }

    // choose root of the log (DualBox, User or a prefix (like Console))
    if( options.prefix ) {
        sconsole.append(2, ["%c" + options.prefix], ["background: #222; color: yellow;"], 9);
    }
    else if( options.userOrigin ) {
        sconsole.append(2, ["%cUser"], ["background: #222; color: #5d5;"], 9);
    }
    else {
        sconsole.append(2, ["%cDualBox"], ["background: #222; color: #f0f;"], 9);
    }

    if( origin !== null ) {
        sconsole.append(3, ["%c" + origin], ["background: #222; color: #f0f;"], 30);
    }

    // add the message (heighlight user logs)
    var cssColor = this.logLevels[level].cssColor;
    var cssBackgroundColor = "background: #fff;";
    if( options.userOrigin ) {
        cssBackgroundColor = "background: #5d5;";
    }
    else if( options.event ) {
        cssBackgroundColor = "background: ##cecdc8";
    }

    if( options.workerOrigin ) {
        args[0] = "%cworker%c %c" + args[0];
        sconsole.append(4, args, [ "background: #222; color: #0ff;", "background: #fff; color: #000;", cssColor + cssBackgroundColor]);
    }
    else {
        args[0] = "%c" + args[0];
        sconsole.append(4, args, [ cssColor + cssBackgroundColor]);
    }

    sconsole.flush(level); // display the log
};

sconsole.displayNode = function(origin, level, args, options) {
    var msg = args[0];
    var str = "";

    // choose root of the log (DualBox, User or a prefix (like Console))
    if( options.prefix ) {
        str += options.prefix.yellow;
    }
    else if( options.userOrigin ) {
        str += "User".green;
    }
    else {
        str += "DualBox".magenta;
    }

    // then push the origin
    if( origin !== null ) {
        str += "::" + origin.magenta;
    }

    // if we're in a worker, print it
    if( options.workerOrigin ) {
        str += "::" + "worker".cyan;
    }


    // print a small interval
    str += " ";

    // add the message (apply color from log lvl and background if from user origin)
    var msg = this.logLevels[level].fnColor(msg);
    if( options.userOrigin ) {
        msg = msg.bgBlue;
    }
    else if( options.event ) {
        msg = msg.bgMagenta;
    }
    str += msg;
    args[0] = str;

    if( level == "debug" ) level="log"; // node hack, no console.debug on node.js
    console[level].apply(console, args);
}

sconsole.display = function(origin, level, args, options) {
    // if in a worker, send this log to main thread
    if( env.worker ) {
        self.log(msg, level, options);
    }
    else {
        if( env.browser || env.worker ) {
            this.displayBrowser(origin, level, args, options);
        }
        else if( env.node ) {
            this.displayNode(origin, level, args, options);
        }
        else {
            throw new errors.LogError("can't display log in a non-consistent environment");
        }
    }
}


/*
 *   Environment definitions
 */

/*
 *   the real stuff
 */

class LoggerObject {
    constructor( tag, options ) {
        this.options = options || {};
        this.options.userOrigin   = this.options.userOrigin || false;   // true if logs come from a module user code
        this.options.workerOrigin = this.options.workerOrigin || false; // true if logs come from a worker
        this.options.prefix       = this.options.prefix || null;

        // set a minimal log level to display logs (see logLevels)
        if( !this.options.logLevel ) {
            this.options.logLevel = 4;
        }
        else {
            this.options.logLevel = sconsole.logLevels[this.options.logLevel].value;
        }

        if( tag === undefined ) {
            throw new errors.LogError("Every logger object must have a tag, please pass the tag as a parameter");
        }
        else {
            this.tag = tag;
        }
    }

    setLogLevel( logLevel ) {
        if( sconsole.logLevels[logLevel] === undefined ) {
            throw new errors.LogError("Can't set the log level '" + logLevel + "', this log level doesn't exist");
        }
        this.options.logLevel = sconsole.logLevels[logLevel].value;
    }

    _display() {
        if( env.worker ) {
            this._displayWorker.apply(this, arguments);
        }
        else {
            this._displayLocal.apply(this, arguments);
        }
    }

    _displayWorker() {
        var args = _.toArray(arguments);

        // if we're in a worker, we need to set the workerOrigin
        if( args[ args.length-1 ] instanceof Object ) {
            var options = args[ args.length-1 ];
            options.workerOrigin = true;

            if( !options.userOrigin ) {
                // set it so it won't be overriden by the module setting
                options.userOrigin = false;
            }
        }
        else {
            args.push({ workerOrigin : true, userOrigin: false });
        }

        // worker log call
        self.log.apply(self, args);
    }

    _displayLocal() {
        // parse arguments
        var args = _.toArray(arguments);

        // get level (arg 1)
        var level = args[0];
        args = args.splice(1);


        // display log if the logLevel is low enough
        if( this.options.logLevel <= sconsole.logLevels[level].value ) {

            // get options (last arg if it's an object)
            if( args[ args.length-1 ] instanceof Object ) {
                var options = args.pop();
            }
            else {
                var options = undefined;
            }

            var logOptions = JSON.parse(JSON.stringify(this.options)); // clone hack
            if( options !== undefined ) {
                // override object properties
                for( var prop in options ) {
                    logOptions[prop] = options[prop];
                }
            }

            // HEAVY stuff, check dualbox.env to see if it's allowed
            var envLogOptions = env.getLogOptions();
            if( envLogOptions.codeLocation || envLogOptions.fileLocation ) {
                if( !logOptions.fileAbsoluteLocation ) {
                    // 4th line of the stack (3rd call) is the file we want
                    var stack = new Error().stack;
                    var line4 = stack.split('\n')[3];

                    let match = line4.match(/\(.*\)/)
                    if( match ) {
                        // format "at FunctionName (fileLocation)"
                        var fileLocation = line4.match(/\(.*\)/)[0];
                        logOptions.fileAbsoluteLocation = fileLocation.slice(1,-1).replace(/:\d*$/g,"");

                        var codeLocation = line4.match(/at .*\(/) ? line4.match(/at .*\(/)[0].slice(0, -2) : "";
                        logOptions.codeLocation = codeLocation;
                    }
                    else {
                        // format "at fileLocation"
                        var codeLocation = logOptions.codeLocation = "";
                        var fileLocation = logOptions.fileAbsoluteLocation = line4.match(/at .*\(/) ? line4.match(/at .*\(/)[0] : "";
                    }


                    var flSplit = fileLocation.slice(1,-1).split('/');
                    var fileLocation = "(file:///" + flSplit[ flSplit.length - 1 ] + "/)";
                    logOptions.fileLocation = fileLocation
                }
            }

            sconsole.display(this.tag, level, args, logOptions);
        }
    }

    debug() {
        if( this.options.logLevel <= sconsole.logLevels["debug"].value ) {
            var args = _.toArray(arguments);
            args.unshift("debug");
            this._display.apply(this, args);
        }
    }

    log() {
        if( this.options.logLevel <= sconsole.logLevels["log"].value ) {
            var args = _.toArray(arguments);
            args.unshift("log");
            this._display.apply(this, args);
        }
    }

    info() {
        if( this.options.logLevel <= sconsole.logLevels["info"].value ) {
            var args = _.toArray(arguments);
            args.unshift("info");
            this._display.apply(this, args);
        }
    }

    warn() {
        if( this.options.logLevel <= sconsole.logLevels["warn"].value ) {
            var args = _.toArray(arguments);
            args.unshift("warn");
            this._display.apply(this, args);
        }
    }

    error() {
        if( this.options.logLevel <= sconsole.logLevels["error"].value ) {
            var args = _.toArray(arguments);
            args.unshift("error");
            this._display.apply(this, args);
        }
    }

    hasLogLevel( str ) {
        var logLevelInfos = sconsole.logLevels[str];
        if( logLevelInfos === undefined ) {
            throw new errors.ImplementationError("log level: " + str + " doesn't exist");
        }

        return this.options.logLevel <= logLevelInfos.value;
    }
}

module.exports = LoggerObject
