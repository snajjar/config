/**
 *   Command to create a bundle from an app.json
 */
var pjson = require('../package.json');
var colors = require('colors');
var shelljs = require('shelljs');
var globaljs = require('shelljs/global');
var fs = require('fs-extra');
var path = require('path');
var _ = require('lodash');
var os = require('os');
var cp = require('child_process');
var v8 = require('v8');

// build stuff

var DpmCache = require('../lib/dpmcache');
var AppParser = require('@dualbox/dualbox-lib-appparser');
var VersioningError = require('../lib/errors').VersioningError;
//var disc = require('disc'); // to analyze bundle size

var buildDir = path.join(os.tmpdir(), 'dpmbuild');

// show helper for this command
var help = function() {
    var helper = require('./help.js');
    helper.handle(['bundle']);
    process.exit(1);
}

// return the json of the application to bundle
var readApplicationJson = function(filename) {
    var jsonFilePath = process.cwd() + "/" + filename;

    try {
        var app = require(jsonFilePath);
    }
    catch( e ) {
        if( e.code == "MODULE_NOT_FOUND" ) {
            console.error("could not read the file at " + jsonFilePath);
        }
        else {
            console.error("unexpected error: " + e);
        }
        process.exit(1);
    }
    return app;
}



// create and enter a clean build directory
var prepareBuild = function() {
    shelljs.rm("-rf",buildDir);
    shelljs.mkdir(buildDir);
}

// exit and remove the build directory
var cleanBuild = function() {
    shelljs.rm('-rf', buildDir);
}

var build = function(dpmCache, args, app, deps, strategy) {
    // copy necessary files first
    if( strategy == "browserify" ) {
        var buildFilePath = "../lib/browserify.js";
    }
    else if( strategy == "rollup" )  {
        /*
        if( v8.getHeapStatistics().heap_size_limit < 4328521728 ) {
            console.error('Error: heap size is not big enough to run a rollup compilation.'.red)
            console.warn('To solve this, either:'.yellow)
            console.warn('- run dpm with "node --max-old-space-size=4096" option'.yellow)
            console.warn('- use the increase_memory_limit npm package'.yellow)
        }
        */
        var buildFilePath = "../lib/rollup.js";
    }

    shelljs.cp(path.join(__dirname, buildFilePath), path.join(dpmCache.path, "build.js"));
    shelljs.cp(path.join(__dirname, '../_dualbox_init.js'), path.join(dpmCache.path, "_dualbox_init.js"));
    shelljs.cp(args['_'][0], path.join(dpmCache.path, args['_'][0]));

    // we want our child to have more memory available for the compilation
    var env = _.clone(process.env);
    if( strategy == "rollup" ) {
        env.NODE_OPTIONS = "--max-old-space-size=4096";
    }

    var child = cp.fork(path.join(dpmCache.path, 'build.js'), { 'cwd' : dpmCache.path, 'env' : env });
    child.on('message', result => {
        console.warn('[*] computing done!'.green);
        child.kill('SIGINT');
    });
    child.on('close', (code) => {
        // if the build fail, we quit with the same exit code
        process.exit(code);
    });

    // create a write stream to the output file
    child.send({
        args: args,
        app: app,
        deps: deps,
        buildDir: buildDir,
        cwd: process.cwd()
    });
}

var buildPackage = function(dpmCache, args, component, version) {
    shelljs.cp(path.join(__dirname, "../lib/browserify_package.js"), path.join(dpmCache.path, "buildPackage.js"));
    var child = cp.fork(path.join(dpmCache.path, 'buildPackage.js'), { 'cwd' : dpmCache.path });
    child.on('message', result => {
        console.warn('[*] computing done!'.green);
        child.kill('SIGINT');
    });
    child.on('close', (code) => {
        // if the build fail, we quit with the same exit code
        process.exit(code);
    });

    // create a write stream to the output file
    child.send({
        args: args,
        component: component,
        version: version,
        buildDir: buildDir,
        cwd: process.cwd()
    });
}

// get requirements for the build tools
var getBuildToolsDependencies = function( strategy ) {
    // add the requirements for the build
    var deps = {
        "colors" : "*",
        "@babel/core" : "*",
        "@babel/preset-env" : "*",
        "fs-extra" : "*",
        "lodash"   : "*",
    }

    if( strategy == "browserify" || strategy == "browserify_package" ) {
        deps = Object.assign(deps, {
            "browserify" : "*",
            "@babel/core" : "*",
            "@babel/preset-env" : "*",
            "babelify" : "10.0.0",
            "browserify-css" : "*",
            "rollupify": "*",
            "browserify-css": "*",
            "imgurify": "*",
            "svgify": "*",
            "treeify": "*",
            "uglifyify": "*",
            "uglify-js": "*"
        });
    }
    else if( strategy == "rollup" ) {
        deps = Object.assign(deps, {
            "rollup": "*",
            "rollup-plugin-async" : "*",
            "rollup-plugin-commonjs" : "*",
            "rollup-plugin-node-resolve" : "*",
            "rollup-plugin-terser" : "*",
            "rollup-plugin-multi-entry" : "*",
            "rollup-plugin-json" : "*",
            "rollup-plugin-node-globals" : "*",
            "rollup-plugin-node-builtins" : "*",
            "rollup-plugin-postcss": "*",
            "rollup-plugin-babel": "*",
        });
    }

    return deps;
}

var handleCommand = function(args) {
    // check arguments
    var args = require('minimist')(args);

    if( args["o"] === undefined ) {
        help();
    }
    else {
        // ensure path to outfile exists
        var dirPath = path.dirname( args["o"] );
        console.log('Creating dir: ' + dirPath);
        fs.ensureDirSync( args["o"] );
    }

    if( args["_"].length < 1 && args["r"] === undefined ) {
        help();
    }

    var strategy = args.strategy || "browserify";
    if( args["r"] ) {
        strategy = "browserify_package"; // only browserify can work with -r module
    }
    var strictVersioning = args['strict-versioning'] === undefined;

    // prepare the build directory
    prepareBuild();

    // clean the old files if exist
    shelljs.rm("-f", args["o"]);


    // install the application requirements
    var dpmCache = new DpmCache();

    if( args["_"].length < 1 ) {
        if( args['r'].indexOf('@') ) {
            var { component, version } = args['r'].split('@');
        }
        else {
            var component = args['r'];
            var version = "latest";
        }

        // we also need to install the requirements for the build tools
        var additionalDeps = getBuildToolsDependencies(strategy);
        _.each(additionalDeps, (version, name) => {
            dpmCache.addLocalDependency(name, version);
        });
        dpmCache.addDependency(component, version);
        dpmCache.installDeps((err) => {
            if( err ) {
                console.error(('[*] Error installing build dependencies:\n ' + err).red);
                return;
            }

            console.log("[*] building bundle file ".green + args["o"].green);
            buildPackage(dpmCache, args, component, version);
        });
    }
    else {
        // read application json
        var app = readApplicationJson(args["_"][0]);

        // get the required dependencies from the app.json
        var deps = (new AppParser(app)).getDependencies();

        // we also need to install the requirements for the build tools
        var additionalDeps = getBuildToolsDependencies(strategy);

        // we are building an app
        if( !strictVersioning ) {
            console.log('[*] Falling back to cache version of components');
            app = dpmCache.toCacheVersion(app);
        }

        dpmCache.installApp(app, strictVersioning, (err) => {
            if( err ) {
                if( err instanceof VersioningError && !strictVersioning ) {
                    // build
                    console.log("[*] building bundle file ".green + args["o"].green);
                    build(dpmCache, args, app, deps, strategy);
                }
                else {
                    console.error(('[*] Error:\n ' + err).red);
                    return;
                }
            }
            else {
                // build
                console.log("[*] building bundle file ".green + args["o"].green);
                build(dpmCache, args, app, deps, strategy);
            }
        }, additionalDeps);
    }
};

exports.handle = handleCommand;
exports.description = "Creates a bundle from an app json definition";
exports.help =
`
dpm bundle builds a usable javascript bundle file for an application. It will resolve the application dependencies (according to the .json description file) from the locally installed packages first, or from registry if needed.

Create a bundle from a json application definition:
dpm bundle <application.json> -o <output.js>

Create a debug bundle from a json application definition:
dpm bundle <application.json> -o <output.js> --debug

Create a debug bundle from local installed package, even with unmatching versions:
dpm bundle <application.json> -o <output.js> --no-strict-versioning

Create a bundle from a dualbox component (ui, module, lib, etc):
dpm bundle -r @dualbox/[module] -o <output.js>
`;
