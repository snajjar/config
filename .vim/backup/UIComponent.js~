const EventEmitter = require('events');
const IONode = require('./IONode');
const errors = require('../Errors');
const env = require('../Env');
const _ = require('@dualbox/dualbox-lib-lodash');
const Type = require('../Type');


/*
 *   Base class of DualBox UI Component.
 *
 *   Every DualBox UI Component is able to trigger two types of events:
 *   - the "trigger" event to DualBox UI Components:
 *     inform all linked component that they need to ask for a
 *     DualBox computation (with a read event) on their input linked nodes.
 *   - the "data" event to DualBox Modules:
 *     event that push new data to all linked modules
 *
 */

class UIComponent extends IONode {
    constructor(pkgDesc, appDesc, attrs) {
        attrs.loggerOptions = attrs.loggerOptions || {};
        attrs.loggerOptions.logLevel = env.getLogLevel(); // override logLevel with the actual one set in DualBox
        attrs.tag = "UI("+appDesc.id+")";
        attrs.id = appDesc.id;
        attrs.appDesc = appDesc;
        super(pkgDesc, attrs);

        // limit all triggers() to a 60fps limit
        this.lastTrigger = new Date().getTime();
        this.throttlingTimeout = null;

        // Disctionnary for UI events
        this.reactions = {};
        this.registerEvents();

        // this can be used by any subnode to implement initial values as inputs.
        // When not null, the output value will be computed from inputs depending on the ovverride policy.
        //                The override object can contain any data needed to determine this.
        // When null, the input values will be ignored and the current user value used.
        // Usually override will be set to null on a user interaction, and to a valid object when override is
        // emmitted. Arguments to override will determine which inputs must be set for override.
        this.overrideInputs = []; // should list all inputs concerned for override
        this.override = {};

        this.attr = {};

        var that = this;
        // get package.json attr default values
        if(pkgDesc.dualbox.attr){
            Object.keys(pkgDesc.dualbox.attr).forEach(function (key) {
                var a = pkgDesc.dualbox.attr[key];
                if(a.value === undefined){
                    console.warn("UI component "+that.id+" does define an attr called '"+key+"' but no default value. Attributes must have a default value.");
                }else{
                    that.attr[key] = a.type ? Type.loadFromJSON(a.value,a.type) : a.value;
                }
            });
        }

        // get appdesc attr values, overwrite default values if needed
        if(appDesc.attr){
            Object.keys(appDesc.attr).forEach(function (key) {
                var t = pkgDesc.dualbox.attr && pkgDesc.dualbox.attr[key] && pkgDesc.dualbox.attr[key] ? pkgDesc.dualbox.attr[key].type : null;
                that.attr[key] = t ? Type.loadFromJSON(appDesc.attr[key],t) : appDesc.attr[key];
            });
        }
    }

    initialize() {
        super.initialize();
    }

    registerEvents() {
        // register some custom behaviors
        this.registerUIEvent("alert",    this.alert.bind(this));
        this.registerUIEvent("hide",     this.hide.bind(this));
        this.registerUIEvent("show",     this.show.bind(this));
        this.registerUIEvent("enable",   this.enable.bind(this));
        this.registerUIEvent("disable",  this.disable.bind(this));
        this.registerUIEvent("trigger",  this.onTrigger.bind(this));
        this.registerUIEvent("override", this.onOverride.bind(this));
    }

    registerUIEvent(eventName, cb) {
        var createCallback = function(node, eventName, cb) {
            var self = node;
            var eventName = eventName;

            return function(attrs) {
                // only call the handler if the message was for us
                if( attrs.dest === self ) {
                    self.info('[UIEvent] received event %s', eventName);
                    cb(attrs);
                }
            }
        }
        this.reactions[eventName] = createCallback(this, eventName, cb);
    }

    getEventCb(eventName) {
        var cb = this.reactions[eventName];
        if( !cb ) {
            throw new errors.ImplementationError("Event " + eventName + " is not registered in " + this.id);
        }
        else {
            return cb;
        }
    }

    onAfterReady() {
        this.clear(); // clear input
    }

    // UI component can always invalidate
    canInvalidate() {
        return true;
    }

    emit(eventName, eventData) {
        if( eventName == "data" ) {
            this.enableRead();
        }

        super.emit(eventName, eventData);
    }

    performTrigger(output) {
        this.lastTrigger = new Date().getTime();
        this.invalidOutputs(true);
        super.trigger( output );
    }

    // throttle triggers to a limit of 60fps
    trigger( output ) {
        var limit = 20;
        clearTimeout(this.throttlingTimeout);
        var laps = (new Date()).getTime() - this.lastTrigger;
        if(laps > limit){
            this.performTrigger(output);
        }else{
            this.throttlingTimeout = setTimeout(
                () => {
                    this.performTrigger(output);
                    this.throttlingTimeout = null;
                },
                limit-laps
            );
        }
    }

    initOverride(){
        var self = this;
        this.override = {};
        _.forEach(this.overrideInputs, function(v, k) {
            self.override[v] = true;
        });
    }
    onOverride(data){
        var self = this;
        if(data.args === undefined || data.args === null){
            // No arguments, override everything
            this.override = {};
            _.forEach(this.overrideInputs, function(v, k) {
                self.override[v] = true;
            });
        }else{
            // override only the wanted elements
            for(var i=0; i<data.args.length; ++i){
                this.override[data.args[i]] = true;
            }
        }
        this.onTrigger();
    }

    onInterrupt(invalidKeys) {
        // to be redefined by UI if needed
        // (for instance, for UIs with input that need to disabled themselves)
    }

    // allow UI components to have a callback on interrupt
    interrupt(invalidKeys) {
        this.onInterrupt(invalidKeys);
        super.interrupt(invalidKeys);
    }

    /*
     *   DEBUG
     */
    // Shows an alert. Debug purposes
    alert(data) {
        this.warn('[UI-EVENT] receveid alert from ' + data.node.id);

        if( env.browser ) {
            if( data ) {
                alert(data);
            }
            else {
                alert("alert from " + this.id + " !");
            }
        }
        else {
            this.info("Received alert UI event with data: " + data);
        }
    }

    /*
     *   METHODS TO BE OVERRIDEN
     */

    // send data with the getValue() method.
    // can be redefined
    onReady() {
        throw new errors.ImplementationError("onReady should be redefined in the UIComponent " + this.id);
    }

    // instanciate a UIComponent with its desc
    // and attach it to the div
    // return the instanciated UIComponent
    static attachTo(desc, div) {
        throw new errors.ImplementationError("attachTo should be redefined in the UIComponent");
    }

    // Disable HTML elements - to be overridden
    hide() {
        throw new errors.ImplementationError("UIComponent.hide should be overriden in " + this.id);
    }

    // Disable HTML elements - to be overridden
    show() {
        throw new errors.ImplementationError("UIComponent.show should be overriden in " + this.id);
    }

    // Disable HTML elements - to be overridden
    disable() {
        throw new errors.ImplementationError("UIComponent.disable should be overriden in " + this.id);
    }

    // Enable HTML elements - to be overridden
    enable() {
        throw new errors.ImplementationError("UIComponent.enable should be overriden in " + this.id);
    }
}

module.exports = UIComponent;
