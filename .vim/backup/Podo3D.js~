
var XTHREE = require('@dualbox/dualbox-lib-xthree');
var Canvas = require('@dualbox/dualbox-lib-canvas');
var ImageData = require('@dualbox/dualbox-lib-imagedata').ImageData;
var Interpolants = require('@dualbox/dualbox-lib-interpolants');

'use strict';


// Environment tests
var inNode = function() {
    try {
        return module.exports && typeof module == "object" && !inBrowser();
    }
    catch( e ) {
        if( e instanceof ReferenceError ) {
            return false;
        }
        else {
            throw e;
        }
    }
}
var inWorker = function() {
    try {
        importScripts;
        return true;
    }
    catch( e ) {
        if( e instanceof ReferenceError ) {
            return false;
        }
        else {
            throw e;
        }
    }
};
var inBrowser = function() {
    try {
        window;
        return !inWorker(); // return true if we're in a browser but not in a worker
    }
    catch( e ) {
        if( e instanceof ReferenceError ) {
            return false;
        }
        else {
            throw e;
        }
    }
};

var podo3d = {};
//podo3d.version = require('../../package.json').version;

podo3d.AdjustArchHelper = require('./AdjustArchHelper.js');
podo3d.PatternEdgesHelper = require('./PatternEdgesHelper.js');

podo3d.RigiditiesManager = require('./RigiditiesManager.js');

podo3d.FootScan = require('./FootScan.js');


podo3d.out_max_map = (function() {
    var heelMaxFunc = function(footsize){
        // Formula copied from :
        // https://docs.google.com/spreadsheets/d/1NrHEoWp_iXvirjwGqnLjWKpquRULYCtpl9Q2nlNAdyY/edit?ts=57592790#gid=0
        var A1 = 35, A2 = 41, A3 = 46;
        var B1 = 15, B2 = 18, B3 = 20;
        var A5 = (B3-B1)/(A3-A1);
        var B5 = B1-A5*A1;
        return footsize*A5+B5;
    };
    var max12 = function(footsize){
        return 12;
    };
    var max20 = function(footsize){
        return 20;
    };
    var max30 = function(footsize){
        return 30;
    };
    return {
        E:max12,
        C:max30,
        Bx:max30,
        By:max30,
        Bz:max30,
        Dx:max12,
        Dy:max12,
        Dz:max12,
        Fx:max12,
        Fy:max12,
        CenterH:max12,
        A:heelMaxFunc,
        CenterB:heelMaxFunc,
        G:heelMaxFunc
    }
})();

if(inBrowser()){
    window.hackPodo3D = {};
    window.hackPodo3D.out_max_map = podo3d.out_max_map;
}

// Maximum height inside the sole depending on
// the zone
podo3d.in_max_map = {
    A:25, E:20, C:30, G:20,
    Bx:30,By:30,Bz:30,
    Dx:25,Dy:25,Dz:25,
    Fx:20,Fy:20,
    CenterB:25, CenterH:25
};
if(inBrowser()){
    window.hackPodo3D.in_max_map = podo3d.in_max_map;
}

// Global parameters to describe the way the sole is getting to 0 height.
podo3d.to_zero = {
    method:"adaptive", // or "block"
    start:0,
    end:1,
    finalValue:0,
    stepFunc:{
        current:"both",
        // Getting to 0 using a smoothstep function.
        // End is 0 and first order derivative is 0.
        smooth:function(x, xa, xb, ya, yb, yt){
            return Interpolants.Interpolation1.polyStep3(x, xa, xb, ya, yb);
        },
        // Getting to 0 with half a smoothstep function (not smooth then...)
        // End is 0 but first order derivative is not 0, and therefore not continuous
        // Note : since the height map is a smooth grid stepping every cm, result will be
        //        smooth anyway...
        sharp:function(x, xa, xb, ya, yb, yt){
            var sx = xa + (x-xa)/2;
            var res = Interpolants.Interpolation1.polyStep3(sx, xa,xb,ya,yb);
            return ya + (res-ya)/2;
        },
        // Combine sharp and smooth depending on the y position.
        // The more external we are, the more smooth we are.
        // This helps to keep foot shape on the important part (the less flat part)
        both:function(x, xa, xb, ya, yb, yt){
            return yt*podo3d.to_zero.stepFunc.sharp(x, xa, xb, ya, yb, yt) +
                   (1-yt)*podo3d.to_zero.stepFunc.smooth(x, xa, xb, ya, yb, yt);
        }
    },
    stepF:function(){return podo3d.to_zero.stepFunc[podo3d.to_zero.stepFunc.current];}
};

// Size ratio between S,M and L models.
// Useful to scale some elements.
podo3d.gab_ratio = {
    "S":0.92,
    "M":1.0,
    "L":1.1
};

// IN the pattern files, x is the width, and y the length.
podo3d.gab_size_scale = {
    // Largeur (l)  Longueur (L)
    // 2,198*x-3,298    4,282*x-6,426

    25:{y:0.538042,x:0.552879},
    26:{y:0.560562,x:0.576586},
    27:{y:  0.583101,x:0.600224},
    28:{y:  0.605659,x:0.623825},
    29:{y:  0.628233,x:0.6474},
    30:{y:  0.650822,x:0.670957},
    31:{y:  0.673427,x:0.694501},
    32:{y:  0.696047,x:0.718033},
    33:{y:  0.718683,x:0.741557},
    34:{y:  0.741333,x:0.765073},
    35:{y:  0.763999,x:0.788583},
    36:{y:  0.786681,x:0.812088},
    37:{y:  0.809379,x:0.835589},
    38:{y:  0.832095,x:0.859086},
    39:{y:  0.85483,x:0.88258},
    40:{y:  0.877584,x:0.906072},
    41:{y:  0.900359,x:0.929562},
    42:{y:  0.923157,x:0.95305},
    43:{y:  0.94598,x:0.976536},
    44:{y:  0.96883,x:1.000023},
    45:{y:  0.991711,x:1.023509},
    46:{y:  1.014627,x:1.046995},
    47:{y:  1.037582,x:1.070482},
    48:{y:  1.060584,x:1.093972},
    49:{y:  1.083641,x:1.117463},
    50:{y:  1.106766,x:1.140959},
    51:{y:  1.129976,x:1.164461},
    52:{y:  1.153302,x:1.187973},
    53:{y:  1.176793,x:1.211499},
    54:{y:  1.200556,x:1.235055},
    55:{y:  1.224917,x:1.258703}
};

// ref size is the size at which the element to scale has been designed.
podo3d.getGabScale = function(foot_width, foot_size, ref_size){
    var gab_ratio = podo3d.gab_ratio[foot_width];
    var gab_scale = podo3d.gab_size_scale[foot_size];
    var gab_scale_40 = podo3d.gab_size_scale[ref_size];

    var scale = new XTHREE.Vector3(
        gab_scale.x/gab_scale_40.x,
        gab_ratio*gab_scale.y/gab_scale_40.y,
        1
    );

    return scale;
};

/**
 *  @param {XTHREE.Vector3} heel
 *  @param {XTHREE.Vector3} meta1
 *  @param {XTHREE.Vector3} meta5
 */
podo3d.buildInsoleRotationWidget = function(heel, meta1, meta5){
    var geometry = new XTHREE.BufferTriGeometry();

    var vec1 = new XTHREE.Vector3();
    vec1.subVectors(meta1, heel);
    var vec2 = new XTHREE.Vector3();
    vec2.subVectors(meta5, heel);

    var vec_far = vec1.clone().add(vec2).multiplyScalar(0.40);
    var vec_near = vec1.clone().add(vec2).multiplyScalar(0.375);
    var vec_mid = vec1.clone().add(vec2).multiplyScalar(0.388);

    vec1.normalize();
    vec2.normalize();

    var attr = {
        position:heel.clone()
    };

    var angle = Math.PI/30;
    var mat = new XTHREE.Matrix4();
    mat.makeRotationZ(-angle);

    attr.position.copy(vec_near).applyMatrix4(mat).add(heel);
    geometry.addVertex(attr);
    attr.position.copy(vec_far).applyMatrix4(mat).add(heel);
    geometry.addVertex(attr);

    var res = 12;
    var vi = geometry.vertexCount();
    for(var i=1; i<=2*res; ++i){
        mat.makeRotationZ(-angle+i*angle/res);
        attr.position.copy(vec_near).applyMatrix4(mat).add(heel);
        geometry.addVertex(attr);
        attr.position.copy(vec_far).applyMatrix4(mat).add(heel);
        geometry.addVertex(attr);
        vi = geometry.vertexCount();
        geometry.addFace(vi-4,vi-2,vi-1);
        geometry.addFace(vi-4,vi-1,vi-3);
    }

    mat.makeRotationZ(angle+Math.PI/95);
    attr.position.copy(vec_mid).applyMatrix4(mat).add(heel);
    geometry.addVertex(attr);
    vi = geometry.vertexCount();
    geometry.addFace(vi-3,vi-1,vi-2);

    mat.makeRotationZ(-angle-Math.PI/95);
    attr.position.copy(vec_mid).applyMatrix4(mat).add(heel);
    geometry.addVertex(attr);
    vi = geometry.vertexCount();
    geometry.addFace(vi-1,0,1);

    // Rotation center
    //attr.position.copy(vec_near).normalize().applyMatrix4(mat).multiplyScalar(6).add(heel);
    //geometry.addVertex(attr);
    //mat.makeRotationZ(angle);
    //attr.position.copy(vec_near).normalize().applyMatrix4(mat).multiplyScalar(6).add(heel);
    //geometry.addVertex(attr);
    //attr.position.copy(heel);
    //geometry.addVertex(attr);
    //geometry.addFace(geometry.vertexCount()-1,geometry.vertexCount()-2,geometry.vertexCount()-3);

    geometry.computeVertexNormals();

    return geometry;
};


/**
 *  @param {{vertices:Array.<number>, faces:Array.<number>, normals:Array.<number>}} pattern
 *  @param {Object.<string,Array.<{p:{x:number,y:number,z:number},vertices:Array.<number>}>>} holes
 *         Map a zone with its holes, p is the center of the hole, and vertices the list of vertices
 *         index which belong to this hole.
 *  @param {Object.<string,number>} hole_size Size information for the holes in each zone
 */
podo3d.resizeHoles = function(pattern, holes, hole_sizes)
{
    if(!(pattern instanceof XTHREE.BufferTriGeometry)){
        throw "Error, pattern must not be a skimlab data structure here";
    }

    var position = pattern.getAttribute("position");
    var attr = {
        position:new XTHREE.Vector3()
    };

    var center = new XTHREE.Vector3();
    var curr_v = new XTHREE.Vector3();
    var next_v = new XTHREE.Vector3();
    var c_to_v = new XTHREE.Vector3();
    var vec = new XTHREE.Vector3();

    var keys = Object.keys(holes);
    for(var i=0; i<keys.length; ++i){
        var z = holes[keys[i]];
        for(var ci=0; ci<z.length; ++ci){
            center.set(z[ci].p.x, z[ci].p.y, z[ci].p.z);
            var vertices = z[ci].vertices;
            if(vertices.length >=3){

                // We must check that the center is inside the hole.
                var poly_arr = [];
                for(var v_vi=0; v_vi<vertices.length; ++v_vi){
                    var vi = vertices[v_vi];
                    poly_arr.push(new XTHREE.Vector3(
                        position.getX(vi),
                        position.getY(vi),
                        position.getZ(vi)
                    ));
                }

                var poly = new XTHREE.Polygon2(poly_arr);
                if(poly.contains(center) && poly.isStarConvex(center)){
                    var max_d = 0;
                    // First loop we get the max distance, it will be considered the
                    // the norm for scaling the hole
                    for(var v_vi=0; v_vi<vertices.length; ++v_vi){
                        var vi = vertices[v_vi];
                        curr_v.set(
                            position.getX(vi),
                            position.getY(vi),
                            position.getZ(vi)
                        );
                        c_to_v.subVectors(curr_v, center);
                        var d = c_to_v.length();
                        if(d>max_d){
                            max_d = d;
                        }
                    }

                    var ratio = Math.min(max_d,hole_sizes[keys[i]]/2)/max_d;
                    for(var v_vi=0; v_vi<vertices.length; ++v_vi){
                        var vi = vertices[v_vi];
                        curr_v.set(
                            position.getX(vi),
                            position.getY(vi),
                            position.getZ(vi)
                        );
                        c_to_v.subVectors(curr_v, center);
                        var d = c_to_v.length();
                        var new_d = d*ratio;
                        c_to_v.normalize();
                        curr_v.set(
                            center.x+new_d*c_to_v.x,
                            center.y+new_d*c_to_v.y,
                            center.z+new_d*c_to_v.z
                        );
                        // Set the new position
                        // ... The safe and slow way (buffer abstraction)
                        // attr.position.copy(curr_v);
                        // pattern.setVertex(vi, attr);
                        // ... or the fast and unsafe way
                        position.setXYZ(vi, curr_v.x, curr_v.y, curr_v.z);
                    }
                }else{
                    // The center is not inside the hole, or the shape of the
                    // hole is not a star-convex domain with respect to
                    // we could try to do something, but it's tricky so let it be
                    // untouched for now
                }
            }
        }
    }
};

/**
 *  Return the border vertices in an oriented array.
 *  2 subsquent vertices make an edges.
 *  pattern is the sole pattern and MUST NOT be transformed since
 *  this function rely on the ability to find a starting border
 *  point using extreme position in X.
 */
podo3d.getPatternBorderVertices = function(pattern){
    var edges = pattern.getSingularEdgesAsObject();

    var position = pattern.getAttribute('position');

    var vstart = 0;
    var vx_start = position.getX(0);
    var n_vertices = pattern.vertexCount();
    for(var i=0; i<n_vertices; ++i){
        if(vx_start>position.getX(i)){
            vstart = i;
            vx_start = position.getX(i);
        }
    }

    var res = [vstart];

    var safety = 0;
    var curr_v = vstart;
    var finished = false;
    while(!finished && safety<n_vertices){
        var next_v = edges[res[res.length-1]][1];
        if(next_v !== res[0]){
            res.push(next_v);
        }else{
            finished = true;
        }
        safety++;
    }

    return res;
};

podo3d.getHolesCenter = function(holes, mat4){
    var res = [];
    var keys = Object.keys(holes);
    for(var i=0; i<keys.length; ++i){
        var z = holes[keys[i]];
        for(var ci=0; ci<z.length; ++ci){
            if(z[ci].vertices.length >3){
                res.push(new XTHREE.Vector3(z[ci].p.x, z[ci].p.y, z[ci].p.z));
            }
        }
    }

    for(var i=0; i<res.length; ++i){
        res[i].applyMatrix4(mat4);
    }

    return res;
};


podo3d.setScanHeightAboveZero = function(mesh, refpts){

    var tri = new XTHREE.Triangle(refpts.heel, refpts.meta1, refpts.meta5);
    var r = new XTHREE.Vector3().subVectors(refpts.meta1,refpts.meta5).length()/2;


    var position = mesh.getAttribute('position');
    var tmp = new XTHREE.Vector3();
    var r_tmp = new XTHREE.Vector3();
    var min = 0;
    for(var i=0; i<mesh.vertexCount(); ++i){
        tmp.set(
            position.getX(i),
            position.getY(i),
            position.getZ(i)
        );
        if(tri.containsPoint(tmp, tri.a,tri.b, tri.c) || r_tmp.subVectors(tmp,refpts.heel).length() < r){
            if(position.getZ(i) < 0){
                min = Math.min(min, position.getZ(i));
            }
        }
    }

    if (min !== 0){
        min += 0.1; // add 0.1mm to get a fair red zone
    }
    min = Math.min(0, min);
    mesh.translate(0,0,-min);

    return mesh;
};

podo3d.getGeometriesAABB = function(soleMeshes,margin){
    var res = new XTHREE.Box3();

    var keys = Object.keys(soleMeshes);
    for(var i=0; i<keys.length; ++i){
        if(soleMeshes[keys[i]].geometry.boundingBox === null){
            soleMeshes[keys[i]].geometry.computeBoundingBox();
        }
        res.union(soleMeshes[keys[i]].geometry.boundingBox);

        // Also check that the meshes have names, since they will be used
        if(soleMeshes[keys[i]].name === ""){
            soleMeshes[keys[i]].name = keys[i];
        }
    }

    // Add 10mm in X Y
    res.min.x -= margin;
    res.min.y -= margin;
    res.max.x += margin;
    res.max.y += margin;

    return res;
};

podo3d.buildFrontBoxes = function(front_objs, front_aabb, resolution){

    // Check that bounding boxes and bounding sphere of all front_objs do exist and are right.
    // Optim Note : use advanced DualBox BufferTriGeometry for front_objs to know if box recomputing is necessary
    var keys = Object.keys(front_objs);
    for(var i=0; i<keys.length; ++i){
        front_objs[keys[i]].geometry.computeBoundingBox();
        front_objs[keys[i]].geometry.computeBoundingSphere();
    }

    var vec = new XTHREE.Vector3();
    var raycaster = new XTHREE.Raycaster();
    var origin = new XTHREE.Vector3();
    var direction = new XTHREE.Vector3(0,0,1);
    var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
    var boxes = [];
    for(var yy = front_aabb.min.y; yy<front_aabb.max.y+resolution/2; yy+=resolution){
        var box = new XTHREE.Box3();
        box.min.y = yy - resolution/2;
        box.max.y = yy + resolution/2;
        box.min.z = front_aabb.min.z-0.01;
        box.max.z = front_aabb.min.z+0.01;
        for(var xx = front_aabb.min.x; xx<front_aabb.max.x; xx+=resolution/2){
            origin.set(xx,yy,front_aabb.min.z-1);
            raycaster.set(origin, direction);
            var intersects = raycaster.intersectObjects(front_objs);
            if(intersects.length !== 0){
                box.expandByPoint(vec.set(xx,yy,front_aabb.min.z));
            }
        }
        if(!box.isEmpty()){
            boxes.push(box);
            // add some boxes at the beginning  to ensure consistency
            if(boxes.length ==1){
                boxes.push(boxes[0].clone().translate(vec.set(0,-3*resolution,0)));
                boxes.push(boxes[0].clone().translate(vec.set(0,-2*resolution,0)));
                boxes.push(boxes[0].clone().translate(vec.set(0,-resolution,0)));
                boxes.push(boxes[0].clone().translate(vec.set(0,-4*resolution,0)));
                box = boxes[0];
                boxes[0] = boxes[4];
                boxes[4] = box;
            }
        }
    }
    // add some boxes at the end to ensure consistency
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    // 2 subsequent boxes cannot have a x_min difference of more than max_xdiff
    var max_xdiff = resolution;
    for(var k=0; k<boxes.length-1; ++k){
        var b0 = boxes[k];
        var b1 = boxes[k+1];
        if(b0.min.x<b1.min.x-max_xdiff){
            b1.min.x = b0.min.x+max_xdiff;
        }else if(b1.min.x<b0.min.x-max_xdiff){
            b0.min.x = b1.min.x+max_xdiff;
        }
    }

    return boxes;
};

podo3d.buildFrontBoxesOPTIM = function(front_objs, front_aabb, resolution){

    if(front_aabb.min.z !== front_aabb.min.z){
        throw "Error : buildFrontBoxesOPTIM will fail in this case.";
    }

    // build one big mesh merging all front_objs
    var arr = [];

    var keys = Object.keys(front_objs);
    for(var i=0; i<keys.length; ++i){
        arr.push(front_objs[keys[i]].geometry);
    }
    var big_g = XTHREE.BufferTriGeometry.merge(arr);
    // We could "mergeCloseVertices" but there seem to be an issue on the zone file :
    // one zone is flipped.
    // To check that, breakpoint here and call new DualBox.File(big_g.toOBJ({}),"obj","big_g").download();
    big_g.minimizeBuffers();

    // get all "singluar edges", ie border edges in this case.
    var edges = big_g.getSingularEdgesAsObject();
    var eks = Object.keys(edges);
    var tmp_v = new XTHREE.Vector3();
    var tmp_s = new XTHREE.Segment3(new XTHREE.Vector3(), new XTHREE.Vector3());
    var inters = new XTHREE.Vector3();

    // This is the edge 3D raycasting function
    // return true if the big geometry is intersected by the ray, and fill closer and farther intersection points.
    var raycast = function(ray, closer, farther){
        var p = big_g.getAttribute('position');
        var d_c = Number.MAX_VALUE; // closer intersection distance
        var d_f = Number.MIN_VALUE; // farther intersection distance
        var d = 0;
        for(var i=0; i<eks.length; ++i){
            var idx = edges[eks[i]][0];
            tmp_s.start.set(p.getX(idx),p.getY(idx),p.getZ(idx));
            idx = edges[eks[i]][1];
            tmp_s.end.set(p.getX(idx),p.getY(idx),p.getZ(idx));

            // debug check
            var intersects = [];
            tmp_s.raycast(ray, intersects);
            ///////////////////////////////

            //if(ray.intersectSegment(tmp_s, 0.1, 0.01, inters) !== null){
            //    if(intersects.length === 0 || !intersects[0].point.equals(inters)){
            //        throw "Fuck again";
            //    }
            if(intersects.length !== 0){

                inters.copy(intersects[0].point);

                d = tmp_v.subVectors(ray.origin,inters).lengthSq();
                if(d<d_c){
                    d_c = d;
                    closer.copy(inters);
                }
                if(d>d_f){
                    d_f = d;
                    farther.copy(inters);
                }
            }
        }
        if(d_c === Number.MAX_VALUE || d_f === Number.MIN_VALUE){
            return false;
        }else{
            return true;
        }
    }

    var vec = new XTHREE.Vector3();
    var closer = new XTHREE.Vector3();
    var farther = new XTHREE.Vector3();
    var ray = new XTHREE.Ray();
    var raycaster = new XTHREE.Raycaster();
    var origin = new XTHREE.Vector3();
    var direction = new XTHREE.Vector3(1,0,0);
    var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
    var boxes = [];

    /*
    { // optim for 1rst points of each x lines.
        direction.set(0,1,0);
        origin.set(front_aabb.min.x,front_aabb.min.y,front_aabb.min.z);
        ray.set(origin, direction);
        if(!raycast(ray, closer, farther)){
            // In this case we probably are facing an accuracy issue
            // There is an intersection but it is a singular point.
            throw "This should not happen";
        }
        var y_bound_min = closer.y;
        var y_bound_max = farther.y;
        direction.set(1,0,0);
    }
    */
    // above code seems unstable, to check later for now we remove the optimization and it should be fine.
    var y_bound_min = front_aabb.min.y;
    var y_bound_max = front_aabb.max.y;

    for(var yy = front_aabb.min.y; yy<front_aabb.max.y+resolution/2; yy+=resolution){
        var box = new XTHREE.Box3();
        box.min.y = yy - resolution/2;
        box.max.y = yy + resolution/2;
        box.min.z = front_aabb.min.z-0.01;
        box.max.z = front_aabb.min.z+0.01;

        origin.set(front_aabb.min.x,yy,front_aabb.min.z);
        ray.set(origin, direction);
        if(raycast(ray, closer, farther)){
            // Those 2 lines should be enough, more accurate in boxes computation than the previous non-optimize
            // function. However, for now we want to get the same result in buildFrontBoxesOPTIM
            // box.expandByPoint(closer);
            // box.expandByPoint(farther);
            var x_bound_min = yy>=y_bound_min && yy<=y_bound_max ? front_aabb.min.x : closer.x;
            var x_bound_max = farther.x;
            for(var xx = front_aabb.min.x; xx<front_aabb.max.x; xx+=resolution/2){
                if(xx>=x_bound_min && xx<=x_bound_max){
                    box.expandByPoint(vec.set(xx,yy,front_aabb.min.z));
                }
            }
        }

        if(!box.isEmpty()){
            boxes.push(box);
            // add some boxes at the beginning  to ensure consistency
            if(boxes.length ==1){
                boxes.push(boxes[0].clone().translate(vec.set(0,-3*resolution,0)));
                boxes.push(boxes[0].clone().translate(vec.set(0,-2*resolution,0)));
                boxes.push(boxes[0].clone().translate(vec.set(0,-resolution,0)));
                boxes.push(boxes[0].clone().translate(vec.set(0,-4*resolution,0)));
                box = boxes[0];
                boxes[0] = boxes[4];
                boxes[4] = box;
            }
        }
    }
    // add some boxes at the end to ensure consistency
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    boxes.push(boxes[boxes.length-1].clone().translate(vec.set(0,resolution,0)));
    // 2 subsequent boxes cannot have a x_min difference of more than max_xdiff
    var max_xdiff = resolution;
    for(var k=0; k<boxes.length-1; ++k){
        var b0 = boxes[k];
        var b1 = boxes[k+1];
        if(b0.min.x<b1.min.x-max_xdiff){
            b1.min.x = b0.min.x+max_xdiff;
        }else if(b1.min.x<b0.min.x-max_xdiff){
            b0.min.x = b1.min.x+max_xdiff;
        }
    }

    return boxes;
};

/**
 *  This class represent a height map on the plane X/Y.
 *
 *  @param {Object.<string,XTHREE.BufferGeometry>} soleMeshes
 *  @param {XTHREE.BufferGeometry} footgeom
 *  @param {Object<string,function>} out_max_maps Map of maximum heights outside the sole, depending on the zone.
 */
podo3d.buildSoleHeightMap = function(soleMeshes, footgeom, pattern, out_max_map, in_max_map, footsize, footside, flat_heel_data)
{
    var margin = 60;
    var maxheight = 30;
    var resolution = 10;

    // Max heights are smoothed along the edges,
    // this will define the average derivative, from which the smoothing
    // distance will be deduced
    var smooth_deriv = 0.5;

    // Limit inside the outside limit is taken into account.
    var smooth_inside = 25;

    var keys = Object.keys(soleMeshes);
    var m_identity = (new XTHREE.Matrix4()).identity();
    var sm_box = new XTHREE.Box3();
    for(var i=0; i<keys.length; ++i){
        // check that the meshes have names, since they will be used
        if(soleMeshes[keys[i]].name === ""){
            soleMeshes[keys[i]].name = keys[i];
        }
        if(soleMeshes[keys[i]].geometry.boundingBox === null){
            soleMeshes[keys[i]].geometry.computeBoundingBox();
            sm_box.union(soleMeshes[keys[i]].geometry.boundingBox);
        }
        if(soleMeshes[keys[i]].geometry.boundingSphere === null){
            soleMeshes[keys[i]].geometry.computeBoundingSphere();
        }

        if(!soleMeshes[keys[i]].matrixWorld.equals(m_identity)){
            console.error("soleMeshes in  buildSoleHeightMap must not be transformed");
        }
    }

    var position = pattern.getAttribute('position');

    // Return an object with list of points and their weights
    // On the border of the patterns.
    // Weights correspond to the maximum height in the region near
    // a given point. They are taken from out_max_map.
    var getBorderMaxValues = function(){

        var vec = new XTHREE.Vector3();

        var b_vertices = podo3d.getPatternBorderVertices(pattern);
        var res = new Array(b_vertices.length);
        var smk = Object.keys(soleMeshes);
        for(var i=0; i<b_vertices.length; ++i){
            // Get the closer zone and assign its max value to the point
            var min_dist = Number.MAX_VALUE;
            var p = new XTHREE.Vector3(
                position.getX(b_vertices[i]),
                position.getY(b_vertices[i]),
                position.getZ(b_vertices[i])
            );
            var w = out_max_map[smk[0]](footsize);
            for(var k=0; k<smk.length; ++k){
                var dist = soleMeshes[smk[k]].geometry.distanceToPoint(p);
                if(dist < min_dist){
                    min_dist = dist;
                    w = out_max_map[smk[k]](footsize);
                }
            }

            res[i] = {p:p,w:w};
        }

        // Now the weights need to be smoothed.
        // First we find all steps
        var lengths = [];
        var steps = [];
        var curr_w = res[0].w;
        for(var i=1; i<res.length+1; ++i){
            var ii_1 = i-1;
            var ii = i % res.length;
            vec.subVectors(res[ii].p, res[ii_1].p);
            lengths.push(vec.length());
            if(res[ii].w !== curr_w){
                steps.push(ii);
                curr_w = res[ii].w;
            }
        }
        for(var i=0; i<steps.length; ++i){
            var idx = steps[i];
            var idx_m1 = idx-1 >=0 ? idx-1 : steps.length-1;

            // compute the distance over which the smoothing will occur.
            var w_diff = Math.abs(res[idx].w-res[idx_m1].w);
            var smooth_length = w_diff/smooth_deriv;

            var first = idx;
            var last = idx;
            var l = 0;
            while(l<smooth_length){
                first--;
                if(first === -1){first=res.length-1;}
                l+=lengths[first]+lengths[last];
                last++;
                if(last === res.length){last=0;}
            }
            var lk = 0;
            var limit = last+(first>last ? res.length : 0);
            for(var k=first; k<limit; k++){
                var kk = k % res.length;
                res[kk].w = Interpolants.Interpolation1.polyStep3(lk,0,l,res[first].w,res[last].w);
                lk+=lengths[kk];
            }
        }

        return res;
    }
    var border_maxs = getBorderMaxValues();
    var computeBorderMax = function(point){
        var vec = new XTHREE.Vector3();
        var res = border_maxs[0].w;
        var min_d = Number.MAX_VALUE;
        for(var i=0; i<border_maxs.length; ++i){
            vec.subVectors(point,border_maxs[i].p);
            var d = vec.lengthSq();
            if(d<min_d){
                min_d = d;
                res = border_maxs[i].w;
            }
        }
        return {value:res, dist:Math.sqrt(min_d)};
    };

    // tmps
    var vec = new XTHREE.Vector3();

    var soleAABB = podo3d.getGeometriesAABB(soleMeshes,margin);
    var dims = soleAABB.getSize(new XTHREE.Vector3());
    var resX = dims.x/Math.ceil(dims.x/resolution);
    var resY = dims.x/Math.ceil(dims.y/resolution);
    var resMin = Math.min(resX,resY);

    var hmap = new XTHREE.HeightMap(
        new XTHREE.Vector2(soleAABB.min.x, soleAABB.min.y),
        dims.x,
        dims.y,
        resX,
        resY
    );
    // Smoothing data.
    // Store coefficient for smoothing only on the edge of the sole.
    var coeff_map = new XTHREE.HeightMap(
        new XTHREE.Vector2(soleAABB.min.x, soleAABB.min.y),
        dims.x,
        dims.y,
        resX,
        resY
    );
    var hmap_smoothed = new XTHREE.HeightMap(
        new XTHREE.Vector2(soleAABB.min.x, soleAABB.min.y),
        dims.x,
        dims.y,
        resX,
        resY
    );

    // Optim note : use advanced DualBox BufferTriGeometry to ensure a null bounding box
    //              is really invalid
    if(footgeom.boundingBox === null){
        footgeom.computeBoundingBox();
    }
    if(footgeom.boundingSphere === null){
        footgeom.computeBoundingSphere();
    }


    // Take the lower z pooint of the foot mesh to be sure to cast from under the foot
    // offset to be sure to intersect objects at z = 0
    var zoffset = footgeom.boundingBox.min.z-0.1;
    var raycaster = new XTHREE.Raycaster();
    var origin = new XTHREE.Vector3();
    var direction = new XTHREE.Vector3(0,0,1);
    var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
    var foot_objs = [new XTHREE.Mesh(footgeom, mat)];
    var sole_meshes_objs = [soleMeshes.E,
        soleMeshes.Dx, soleMeshes.Dy, soleMeshes.Dz,
        soleMeshes.C,
        soleMeshes.Bx, soleMeshes.By, soleMeshes.Bz,
        soleMeshes.CenterH, soleMeshes.CenterB,
        soleMeshes.Fx, soleMeshes.Fy,
        soleMeshes.A, soleMeshes.G
    ];
    var front_objs = [soleMeshes.E,
        soleMeshes.Dx, soleMeshes.Dy, soleMeshes.Dz,
        soleMeshes.C,
        soleMeshes.Bx, soleMeshes.By, soleMeshes.Bz,
        soleMeshes.CenterH,
        soleMeshes.Fx, soleMeshes.Fy
    ];

    // Build the aabb in the front of the sole.
    var front_aabb = (new XTHREE.Box3()).union(
                soleMeshes.E.geometry.boundingBox).union(
                soleMeshes.Dx.geometry.boundingBox).union(
                soleMeshes.Dy.geometry.boundingBox).union(
                soleMeshes.Dz.geometry.boundingBox).union(
                soleMeshes.C.geometry.boundingBox).union(
                soleMeshes.Bx.geometry.boundingBox).union(
                soleMeshes.By.geometry.boundingBox).union(
                soleMeshes.Bz.geometry.boundingBox).union(
                soleMeshes.CenterH.geometry.boundingBox).union(
                soleMeshes.Fx.geometry.boundingBox).union(
                soleMeshes.Fy.geometry.boundingBox);
    front_aabb.min.x = soleMeshes.Bz.geometry.boundingBox.max.x;
    var boxes = null;
    // depending on the methods, we may either use a set of box slices
    // or one big box
    if(podo3d.to_zero.method === "adaptive"){

        // var boxes = podo3d.buildFrontBoxes(front_objs, front_aabb, resMin);
        var boxes = podo3d.buildFrontBoxesOPTIM(front_objs, front_aabb, resMin);

        /*
        for(var i=0; i<boxes.length; ++i){
            if(boxes[i].min.y !== boxes_o[i].min.y || boxes[i].max.y !== boxes_o[i].max.y ||
                boxes[i].min.x !== boxes_o[i].min.x || boxes[i].max.x !== boxes_o[i].max.x){
                throw "Thre is a bug";
            }

            if( boxes_o[i].min.x<boxes[i].min.x-resMin ||
                boxes_o[i].min.x>boxes[i].min.x+resMin ||
                boxes_o[i].max.x<boxes[i].max.x-resMin ||
                boxes_o[i].max.x>boxes[i].max.x+resMin){
                throw "There is likely a bug";
            }
        }
        */

    }else if(podo3d.to_zero.method === "block"){
        var bbox = front_aabb.clone();
        var faabb_s = front_aabb.getSize(new XTHREE.Vector3());
        bbox.min.y = front_aabb.min.y - 3*resMin;
        bbox.max.y = front_aabb.max.y + 3*resMin;
        bbox.min.z = front_aabb.min.z-0.01;
        bbox.max.z = front_aabb.min.z+0.01;
        boxes = [bbox];
    }else{
        console.error("unknown method for setting sole to 0");
    }
    // Extend or shrink the resulting boxes
    // Order is important here (front_aabb is used in buildFrontBoxes, and extended afterwards)
    var faabb_s = front_aabb.getSize(new XTHREE.Vector3());
    if(podo3d.to_zero.start<0){
        front_aabb.min.x = front_aabb.min.x + podo3d.to_zero.start*faabb_s.x;
    }
    if(podo3d.to_zero.end>1){
        front_aabb.max.x = front_aabb.max.x + (podo3d.to_zero.end-1)*faabb_s.x;
    }
    for(var i=0; i<boxes.length; ++i){
        var b = boxes[i];
        var bs = b.getSize(new XTHREE.Vector3());
        b.min.x = b.min.x + podo3d.to_zero.start*bs.x;
        b.max.x = b.min.x + podo3d.to_zero.end*bs.x;
    }

    /*
    console.time("iteration");
    Original code, using slow raytracing method.
    hmap.iterate(function(x,y){
        origin.set(x,y,zoffset);
        raycaster.set(origin, direction);
        var intersects = raycaster.intersectObjects(foot_objs);
        var ratio = 1.0;
        if(x>front_aabb.max.x){
            ratio = podo3d.to_zero.finalValue;
        }else if(x>front_aabb.min.x){
            var slice_box = null;
            for(var k=0; k<boxes.length; ++k){
                if(boxes[k].containsPoint(vec.set(x,y,front_aabb.min.z))){
                    slice_box = boxes[k];
                    break;
                }else if(boxes[k].min.y<y && y<boxes[k].max.y && x>boxes[k].max.x){
                    ratio = podo3d.to_zero.finalValue;
                    break;
                }
            }
            if(slice_box !== null){
                var yt = 0;
                if(y>front_aabb.max.y){
                    yt = 0;
                }else if(y>front_aabb.min.y){
                    yt = Interpolants.Interpolation1.polyStep3(
                        (y-front_aabb.min.y)/(front_aabb.max.y-front_aabb.min.y),
                        0,1,1,0
                    );
                }else{
                    yt = 1;
                }
                if(footside === "right"){ yt = 1-yt; }

                ratio = podo3d.to_zero.stepF()(
                    (x-slice_box.min.x)/(slice_box.max.x-slice_box.min.x),
                    0,1,1,podo3d.to_zero.finalValue,
                    yt
                );
            }
        }
        var intersects_sm = raycaster.intersectObjects(sole_meshes_objs);
        // origin will be used for distance computation, reset it in the z=0 plane
        origin.z = 0;
        if(intersects.length !== 0){
            if(intersects_sm.length !== 0){
                var in_max = in_max_map[intersects_sm[0].object.name];
                var border_max = computeBorderMax(origin);
                if(border_max.dist<smooth_inside){
                    var t = border_max.dist/smooth_inside;
                    in_max = Interpolants.Interpolation1.polyStep5(
                        t,
                        0,1,border_max.value,in_max
                    );
                    coeff_map.setHeight(x,y,1-t);
                }else{
                    coeff_map.setHeight(x,y,0);
                }
                hmap.setHeight(
                    x,y,
                    Math.max(0,
                        Math.min(
                            ratio*(intersects[0].distance+zoffset),
                            in_max
                        )
                    )
                );

            }else{
                hmap.setHeight(
                    x,y,
                    Math.max(0,
                        Math.min(
                            ratio*(intersects[0].distance+zoffset),
                            computeBorderMax(origin).value
                        )
                    )
                );
                coeff_map.setHeight(x,y,1.0);
            }
        }else{
            if(intersects_sm.length !== 0){
                var in_max = in_max_map[intersects_sm[0].object.name];
                var border_max = computeBorderMax(origin);
                if(border_max.dist<smooth_inside){
                    var t = border_max.dist/smooth_inside;
                    in_max = Interpolants.Interpolation1.polyStep5(
                        t,
                        0,1,border_max.value,in_max
                    );
                    coeff_map.setHeight(x,y,1-t);
                }else{
                    coeff_map.setHeight(x,y,0);
                }
                hmap.setHeight(x,y, ratio*in_max);
            }else{
                hmap.setHeight(x,y, ratio*computeBorderMax(origin).value);
                coeff_map.setHeight(x,y,1.0);
            }
        }
    });
    console.timeEnd("iteration");
    */

    //////////////////////////////////////////////////////////////////
    // OPTIM : instead of iterating through the height map,
    //         we can iterate on the foot triangles to store a map
    //         of the foot instead of the foot mesh.
    //         Points on the map which will not be found under the foot
    //         will map to value footgeom.boundingBox.max.z + 1
    var foothmap = new XTHREE.HeightMap(
        new XTHREE.Vector2(soleAABB.min.x, soleAABB.min.y),
        dims.x,
        dims.y,
        resX,
        resY
    );
    var iterateOnFoot = function(){
        var v0 = new XTHREE.Vector3();
        var v1 = new XTHREE.Vector3();
        var v2 = new XTHREE.Vector3();
        var inters = new XTHREE.Vector3();
        var box = new XTHREE.Box3();
        var size = new XTHREE.Vector3();
        var ray = new XTHREE.Ray(new XTHREE.Vector3(), new XTHREE.Vector3(0,0,1));
        var pos = footgeom.getAttribute("position");

        var mapbox_min = foothmap.getPosition().clone();
        var mapbox = new XTHREE.Box3(
            mapbox_min.clone(),
            mapbox_min.add(new XTHREE.Vector3(
                foothmap.getLengthX(),
                foothmap.getLengthY(),
                0
            ))
        );
        mapbox.min.z = -Number.MAX_VALUE;
        mapbox.max.z = Number.MAX_VALUE;

        // initialize at Number.MAX_VALUE
        // All x/y with this value will later be known not to be under the foot
        foothmap.iterate(function(x,y){
            foothmap.setHeight(x,y,footgeom.boundingBox.max.z + 1);
        });

        footgeom.iterateOnFaces(function(fi, i0, i1, i2){
            v0.set(pos.getX(i0), pos.getY(i0), pos.getZ(i0));
            v1.set(pos.getX(i1), pos.getY(i1), pos.getZ(i1));
            v2.set(pos.getX(i2), pos.getY(i2), pos.getZ(i2));

            box.makeEmpty();
            box.expandByPoint(v0);
            box.expandByPoint(v1);
            box.expandByPoint(v2);
            box.min.z = -Number.MAX_VALUE;
            box.max.z = Number.MAX_VALUE;
            box.getSize(size);

            box.min.max(mapbox.min);
            box.max.min(mapbox.max);

            if(!box.isEmpty()){
                // We must iterate on all (x,y) of the hmap contained in the box
                var start_x = foothmap.getPosition().x + Math.floor((box.min.x - foothmap.getPosition().x)/foothmap.getStepX())*foothmap.getStepX();
                var start_y = foothmap.getPosition().y + Math.floor((box.min.y - foothmap.getPosition().y)/foothmap.getStepY())*foothmap.getStepY();
                for(var xx = start_x; xx<=box.max.x; xx+=foothmap.getStepX()){
                    for(var yy = start_y; yy<=box.max.y; yy+=foothmap.getStepY()){
                        ray.origin.set(xx,yy,zoffset);
                        if(box.containsPoint(ray.origin)){
                            var hint = true;
                        }
                        if(ray.intersectTriangle(v0, v1, v2, false, inters)){
                            if(foothmap.getHeight(xx,yy,XTHREE.HeightMap.NEAREST) > inters.z){
                                foothmap.setHeight(xx,yy,inters.z);
                            }
                        }
                    }
                }
            }
        })
    };
    iterateOnFoot();

    hmap.iterate(function(x,y){
        origin.set(x,y,zoffset);
        raycaster.set(origin, direction);
        var footheight = null;
        var fhp = hmap.getPosition();
        if(x >= fhp.x && y >= fhp.y && x <= fhp.x+hmap.getLengthX() && y <= fhp.y+hmap.getLengthY()){
            footheight = foothmap.getHeight(x,y,XTHREE.HeightMap.NEAREST);
        }
        var ratio = 1.0;
        if(x>front_aabb.max.x){
            ratio = podo3d.to_zero.finalValue;
        }else if(x>front_aabb.min.x){
            var slice_box = null;
            for(var k=0; k<boxes.length; ++k){
                if(boxes[k].containsPoint(vec.set(x,y,front_aabb.min.z))){
                    slice_box = boxes[k];
                    break;
                }else if(boxes[k].min.y<y && y<boxes[k].max.y && x>boxes[k].max.x){
                    ratio = podo3d.to_zero.finalValue;
                    break;
                }
            }
            if(slice_box !== null){
                var yt = 0;
                if(y>front_aabb.max.y){
                    yt = 0;
                }else if(y>front_aabb.min.y){
                    yt = Interpolants.Interpolation1.polyStep3(
                        (y-front_aabb.min.y)/(front_aabb.max.y-front_aabb.min.y),
                        0,1,1,0
                    );
                }else{
                    yt = 1;
                }
                if(footside === "right"){ yt = 1-yt; }

                ratio = podo3d.to_zero.stepF()(
                    (x-slice_box.min.x)/(slice_box.max.x-slice_box.min.x),
                    0,1,1,podo3d.to_zero.finalValue,
                    yt
                );
            }
        }
        var intersects_sm = raycaster.intersectObjects(sole_meshes_objs);
        // origin will be used for distance computation, reset it in the z=0 plane
        origin.z = 0;
        if(footheight !== null && footheight < footgeom.boundingBox.max.z){
            if(intersects_sm.length !== 0){
                var in_max = in_max_map[intersects_sm[0].object.name];
                var border_max = computeBorderMax(origin);
                if(border_max.dist<smooth_inside){
                    var t = border_max.dist/smooth_inside;
                    in_max = Interpolants.Interpolation1.polyStep5(
                        t,
                        0,1,border_max.value,in_max
                    );
                    coeff_map.setHeight(x,y,1-t);
                }else{
                    coeff_map.setHeight(x,y,0);
                }
                hmap.setHeight(
                    x,y,
                    Math.max(0,
                        Math.min(
                            ratio*footheight,
                            in_max
                        )
                    )
                );

            }else{
                hmap.setHeight(
                    x,y,
                    Math.max(0,
                        Math.min(
                            ratio*(footheight),
                            computeBorderMax(origin).value
                        )
                    )
                );
                coeff_map.setHeight(x,y,1.0);
            }
        }else{
            if(intersects_sm.length !== 0){
                var in_max = in_max_map[intersects_sm[0].object.name];
                var border_max = computeBorderMax(origin);
                if(border_max.dist<smooth_inside){
                    var t = border_max.dist/smooth_inside;
                    in_max = Interpolants.Interpolation1.polyStep5(
                        t,
                        0,1,border_max.value,in_max
                    );
                    coeff_map.setHeight(x,y,1-t);
                }else{
                    coeff_map.setHeight(x,y,0);
                }
                hmap.setHeight(x,y, ratio*in_max);
            }else{
                hmap.setHeight(x,y, ratio*computeBorderMax(origin).value);
                coeff_map.setHeight(x,y,1.0);
            }
        }
    });
    // END OPTIM ////////////////////////////////////////////////////////////

    var max_diff = 0;
    for(var i=0; i<hmap.disp_map.data.length; ++i){
        if(Math.abs(hmap.disp_map.data[i]-hmap.disp_map.data[i]) >max_diff){
            max_diff = Math.abs(hmap.disp_map.data[i]-hmap.disp_map.data[i])
        }
    }
    console.log("Maximum diff after optim : " + max_diff);

    console.time("flat_heel");
    if(flat_heel_data){
        // if we want a flat heel, flatten the heel.
        hmap.iterate(function(x,y){
            var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
            var mesh_arr = [new XTHREE.Mesh(flat_heel_data,mat)];

            var origin = new XTHREE.Vector3(0,0,flat_heel_data.boundingBox.min.z);
            var dirZ = new XTHREE.Vector3(0,0,1);
            var raycaster = new XTHREE.Raycaster();
            origin.set(x,y,flat_heel_data.boundingBox.min.z);
            raycaster.set(origin, dirZ);
            var intersects = raycaster.intersectObjects(mesh_arr);

            if(intersects.length !== 0){
                var z = hmap.getHeight(x,y);
                hmap.setHeight(x,y, z*intersects[0].distance);
            }
        });
    }
    console.timeEnd("flat_heel");

    // Apply a gaussian filter everywhere.
    // Note : only lower the height, we do not allow for increasing it.
    // TODO : update thoses lines with call to getStepX and getStepY when updating ExtThree
    var step_x = hmap_smoothed.xlength/(hmap_smoothed.disp_map.width-1); //hmap_smoothed.getStepX();
    var step_y = hmap_smoothed.ylength/(hmap_smoothed.disp_map.height-1); // hmap_smoothed.getStepY();
    hmap_smoothed.iterate(function(x,y){
        var p = hmap_smoothed.position; // hmap2.getPosition();
        var new_value = (
            1 * hmap.getHeight(x-step_x, y-step_y) +
            2 * hmap.getHeight(x       , y-step_y) +
            1 * hmap.getHeight(x+step_x, y-step_y) +
            2 * hmap.getHeight(x-step_x, y       ) +
            4 * hmap.getHeight(x       , y       ) +
            2 * hmap.getHeight(x+step_x, y       ) +
            1 * hmap.getHeight(x-step_x, y+step_y) +
            2 * hmap.getHeight(x       , y+step_y) +
            1 * hmap.getHeight(x+step_x, y+step_y)
        )/16;
        // Only allow lowering
        hmap_smoothed.setHeight(x,y, Math.min(hmap.getHeight(x,y), new_value));
    });
    // Smooth again taking into account the distance to the edge of the sole.
    // We average with coeff_map
    hmap.iterate(function(x,y){
        var p = hmap.position; // hmap2.getPosition();
        var new_value = (
            1 * hmap_smoothed.getHeight(x-step_x, y-step_y) +
            2 * hmap_smoothed.getHeight(x       , y-step_y) +
            1 * hmap_smoothed.getHeight(x+step_x, y-step_y) +
            2 * hmap_smoothed.getHeight(x-step_x, y       ) +
            4 * hmap_smoothed.getHeight(x       , y       ) +
            2 * hmap_smoothed.getHeight(x+step_x, y       ) +
            1 * hmap_smoothed.getHeight(x-step_x, y+step_y) +
            2 * hmap_smoothed.getHeight(x       , y+step_y) +
            1 * hmap_smoothed.getHeight(x+step_x, y+step_y)
        )/16;
        //hmap.setHeight(x,y, Math.min(hmap_smoothed.getHeight(x,y), new_value));
        var t = coeff_map.getHeight(x,y);
        hmap.setHeight(x,y, new_value*t+(1-t)*hmap_smoothed.getHeight(x,y));
    });

    /*
    hmap.iterate(function(x,y){
        hmap.setHeight(x,y, 0);
    });
    */

    return hmap;
};

podo3d.debugHmap = function(hmap, mode){
    hmap.iterate(function(x,y){

        if(mode === "X4"){
            for(var j=0; j<2; ++j){
                for(var k=0; k<2; ++k){
                    var newmesh = new XTHREE.Mesh(
                        new XTHREE.SphereGeometry(2.0, 16, 12),
                        new XTHREE.MeshPhongMaterial( { color: 0xff9999, specular: 0x000000, shininess: 30, shading: XTHREE.SmoothShading } )
                    );
                    var xx = x+j*5;
                    var yy = y+k*5;
                    newmesh.position.set(xx,yy,hmap.getHeight(xx,yy));
                    skim.instances.modeler.sceneManager.addNeutralMesh(
                        "sphere"+xx+yy,
                        newmesh
                    );
                }
            }
        }else{
            var newmesh = new XTHREE.Mesh(
                new XTHREE.SphereGeometry(2.0, 16, 12),
                new XTHREE.MeshPhongMaterial( { color: 0xff9999, specular: 0x000000, shininess: 30, shading: XTHREE.SmoothShading } )
            );
            var xx = x;
            var yy = y;
            newmesh.position.set(xx,yy,hmap.getHeight(xx,yy));
            skim.instances.modeler.sceneManager.addNeutralMesh(
                "sphere"+xx+yy,
                newmesh
            );
        }
    });
};

/**
 *  @param {podo3d.SoleHeightMap} hmap
 *  @param {DualBox.BufferTriGeometry} pattern
 */
podo3d.buildInsole = function(hmap,pattern,soleMeshes, sole_thickness, front_thickness, recess_hole, recess_thickness){

    // Recess thickness variation will occur at this distance from the recess line.
    var recess_dist = 5.0;

    if(front_thickness > sole_thickness){
        throw "Error : when building the insole, the front thickness must be greater or equal to the sole_thickness.";
    }

    var insole = new XTHREE.BufferTriGeometry();
    insole.preAllocate(2*pattern.vertexCount(), 2*pattern.faceCount());
    insole.addVertexAttribute('normal', Float32Array, 3);

    var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});

    var pattern_p = pattern.getAttribute('position');

    // Tmp var
    var attr = {
        position : new XTHREE.Vector3(),
        normal : new XTHREE.Vector3()
    };
    var attr_p = { // position only
        position : attr.position
    };

    for(var i=0; i<pattern.vertexCount(); ++i){
        attr.position.set(pattern_p.getX(i),pattern_p.getY(i),pattern_p.getZ(i));
        attr.position.z = hmap.getHeight(attr.position.x,attr.position.y);
        hmap.getNormal(attr.position.x,attr.position.y,attr.normal);
        insole.addVertex(attr);
    }
    for(var i=0; i<pattern.faceCount(); ++i){
        insole.addFace(pattern.getFaceA(i),pattern.getFaceB(i),pattern.getFaceC(i));
    }

    // Build a set of AABB in which sole thickness will vary
    var x_spread = 10; // size of the chanfrein
    var front_objs = [
        soleMeshes.E,
        soleMeshes.Dx,
        soleMeshes.Dy,
        soleMeshes.Dz,
        soleMeshes.C
    ];
    // build discrete AABBs in x
    var front_aabb = (new XTHREE.Box3()).union(
                soleMeshes.E.geometry.boundingBox).union(
                soleMeshes.Dx.geometry.boundingBox).union(
                soleMeshes.Dy.geometry.boundingBox).union(
                soleMeshes.Dz.geometry.boundingBox).union(
                soleMeshes.C.geometry.boundingBox);

    // var boxes = podo3d.buildFrontBoxes(front_objs, front_aabb, 1);
    var boxes = podo3d.buildFrontBoxesOPTIM(front_objs, front_aabb, 1);
    for(var i=0; i<boxes.length; ++i){
        var b = boxes[i];
        b.min.x = b.max.x-x_spread;
    }

    // Build the polyline along the heel hole
    var recess_polyline = [];
    if(recess_hole){
        for(var i=0; i<recess_hole.length; ++i){
            var vi = recess_hole[i];
            var v = new XTHREE.Vector3(
                pattern_p.getX(vi),
                pattern_p.getY(vi),
                0
            );
            recess_polyline.push(v);
        }
        var recess_box = new XTHREE.Box3().setFromPoints(recess_polyline);
        recess_box.min.z = -1;
        recess_box.max.z = 1;
        recess_box.expandByScalar(recess_dist);
    }

    // Thickness can be smaller in front of the sole, but no smaller than front_thickness
    var computeThickness = function(x,y){
        // Front
        var ratio = 1.0;
        var ratio_min = Math.min(1.0,front_thickness/sole_thickness);
        for(var i=0; i<boxes.length; ++i){
            var b = boxes[i];
            if(b.min.y<y && y<b.max.y){
                if( b.min.x<x && x<b.max.x){
                    ratio = 1-(1.0-ratio_min)*(x-b.min.x)/(b.max.x-b.min.x);
                    break;
                }else if(x>=b.max.x){
                    ratio = ratio_min;
                    break;
                }
            }
        }

        // Recess : should not overlap with front, so only compute if ratio === 1.0
        if(recess_hole && recess_hole.length !== 0 && ratio === 1.0){
            ratio_min = Math.min(1.0,recess_thickness/sole_thickness);
            var v_tmp = new XTHREE.Vector3(x,y,0);
            if(recess_box.containsPoint(v_tmp)){
                var d = XTHREE.PolylineUtils.distanceToPoint(recess_polyline,v_tmp);
                if(d<recess_dist){
                    ratio = 1-(1.0-ratio_min)*(recess_dist-d)/recess_dist;
                }
            }
        }

        return ratio*sole_thickness;
    }

    var v_offset = pattern.vertexCount();
    var tmp_vec = new XTHREE.Vector3();
    for(var i=0; i<pattern.vertexCount(); ++i){
        // preallocation should make those recall useless, could be get out of the loop
        var insole_p = insole.getAttribute('position');
        var insole_n = insole.getAttribute('normal');

        attr.position.set(insole_p.getX(i),insole_p.getY(i),insole_p.getZ(i));
        attr.normal.set(insole_n.getX(i),insole_n.getY(i),insole_n.getZ(i));
        attr.normal.multiplyScalar(-1);
        var t = computeThickness(attr.position.x,attr.position.y);
        attr.position.set(attr.position.x+sole_thickness*attr.normal.x,
                attr.position.y+sole_thickness*attr.normal.y,
                attr.position.z+sole_thickness*attr.normal.z
        );
        insole.addVertex(attr);
        attr_p.position.set(attr.position.x-t*attr.normal.x,
            attr.position.y-t*attr.normal.y,
            attr.position.z-t*attr.normal.z
        );
        insole.setVertex(i,attr_p);
    }
    for(var i=0; i<pattern.faceCount(); ++i){
        insole.addFace(pattern.getFaceC(i)+v_offset,pattern.getFaceB(i)+v_offset,pattern.getFaceA(i)+v_offset);
    }

    // find border edges
    var edges = pattern.getSingularEdgesAsObject();
    // Here should only be left the half edges (ie borders), direct oriented
    var side_res = 9;
    var keys = Object.keys(edges);
    for(var i=0; i<keys.length; ++i){
        // increase data in edges set
        edges[keys[i]] = {e:edges[keys[i]],curve:null};
    }

    podo3d.buildInsoleRoundEdges(insole, pattern, edges, side_res, recess_hole);

    keys = Object.keys(edges);
    // Patch contains the square that we have to fill.
    var patch = [0,0,0,0];
    for(var i=0; i<keys.length; ++i){
        var s = keys[i];
        if(edges[s].curve === null){
            patch[0] = edges[s].e[0];
            patch[1] = patch[0]+v_offset;
            patch[3] = edges[s].e[1];
            patch[2] = patch[3]+v_offset;

            // easy patching (no rounding)
            insole.addFace(patch[0],patch[1],patch[2]);
            insole.addFace(patch[2],patch[3],patch[0]);
        }
    }

    return insole;
};

/**
 *  Round the edges of the insole.
 *  Note that this functin extends the insole BufferTriGeometry.
 *  Normals are not set because this is for 3D print, computing vertices normals
 *  on the resulting mesh with standards methods will give a more accurate result.
 */
podo3d.buildInsoleRoundEdges = function(insole, pattern, edges, res, recess_hole){

    // tmp var
    var p0 = new XTHREE.Vector3();
    var p1 = new XTHREE.Vector3();
    var p2 = new XTHREE.Vector3();
    var p0p = new XTHREE.Vector3();
    var p1p = new XTHREE.Vector3();
    var p2p = new XTHREE.Vector3();
    var np1p = new XTHREE.Vector3();
    var vec = new XTHREE.Vector3();
    var vec0 = new XTHREE.Vector3();
    var vec1 = new XTHREE.Vector3();
    var n1 = new XTHREE.Vector3();
    var n2 = new XTHREE.Vector3();
    var na = new XTHREE.Vector3();
    var normal = new XTHREE.Vector3();

    // tmp var for addVertex
    var attr = {
        position : vec,
        normal : normal
    };

    // offset in insole of the seond layer (ie pattern duplicated and displaced)
    var v_offset = pattern.vertexCount();

    var subdiv = res-1;
    // We subdivide in subdiv pieces of a circle, that will be scaled down
    var disp_x = new Array(subdiv+1);
    var displace = new Array(subdiv+1);
    for(var i=0; i<displace.length;++i){ // basically just a circle equation
        disp_x[i] = -1+2*i/subdiv;
        displace[i] = Math.sqrt(1-disp_x[i]*disp_x[i]);
    }

    // We will find 1 points on the contour and iterate through the edges.
    // We use the facts that :
    // - The sole is closed when projected in Z=0, with no intersecting triangles
    //   So taking the extreme point on x direction should do the trick.
    //
    // For the recess hole, we use the first index of hole vertices and iterate in the same way

    var pattern_p = pattern.getAttribute('position');

    var vstart = 0;
    var vx_start = pattern_p.getX(0);
    for(var i=0; i<pattern.vertexCount(); ++i){
        if(vx_start>pattern_p.getX(i)){
            vstart = i;
            vx_start = pattern_p.getX(i);
        }
    }

    var insole_p = insole.getAttribute('position');
    var insole_n = insole.getAttribute('normal');

    var safety = 0;
    var border_finished = false;
    var recess_finished = false;
    var border_length = 1.0;
    var recess_length = 0.5;
    var round_length = border_length;
    var curr_v = vstart;
    while(!border_finished || !recess_finished && safety<pattern.vertexCount()){
        var e0 = edges[curr_v].e;
        var e1 = edges[e0[1]].e;
        var curve0 = edges[curr_v].curve;
        var curve1 = edges[e0[1]].curve;
        if(curve1 === null){
            curve1 = new Array(subdiv+1);
            edges[e0[1]].curve = curve1;
            p0.set(
                insole_p.getX(e0[0]),
                insole_p.getY(e0[0]),
                insole_p.getZ(e0[0])
            );
            p0p.set(
                insole_p.getX(e0[0]+v_offset),
                insole_p.getY(e0[0]+v_offset),
                insole_p.getZ(e0[0]+v_offset)
            );
            p1.set(
                insole_p.getX(e1[0]),
                insole_p.getY(e1[0]),
                insole_p.getZ(e1[0])
            );
            p1p.set(
                insole_p.getX(e1[0]+v_offset),
                insole_p.getY(e1[0]+v_offset),
                insole_p.getZ(e1[0]+v_offset)
            );
            p2.set(
                insole_p.getX(e1[1]),
                insole_p.getY(e1[1]),
                insole_p.getZ(e1[1])
            );
            p2p.set(
                insole_p.getX(e1[1]+v_offset),
                insole_p.getY(e1[1]+v_offset),
                insole_p.getZ(e1[1]+v_offset)
            );
            np1p.set(
                insole_n.getX(e1[0]+v_offset),
                insole_n.getY(e1[0]+v_offset),
                insole_n.getZ(e1[0]+v_offset)
            );

            // Get normal to the 2 patches
            vec0.subVectors(p0p,p0);
            vec1.subVectors(p1,p0);
            n1.crossVectors(vec0,vec1).normalize();
            vec0.subVectors(p1p,p1);
            vec1.subVectors(p2,p1);
            n2.crossVectors(vec0,vec1).normalize();
            // get the normal in the angle
            na.addVectors(n1,n2).normalize();

            // Build the points of the local angle curve
            curve1[0] = e1[0];
            for(var i=1; i<displace.length-1; ++i){
                var t = i/(displace.length-1);
                vec.set(
                    (1.0-t)*p1.x + t*p1p.x,
                    (1.0-t)*p1.y + t*p1p.y,
                    (1.0-t)*p1.z + t*p1p.z
                );
                vec.set(
                    vec.x+round_length*displace[i]*na.x,
                    vec.y+round_length*displace[i]*na.y,
                    vec.z+round_length*displace[i]*na.z
                );
                normal.set(
                    na.x*round_length*displace[i]+np1p.x*disp_x[i],
                    na.y*round_length*displace[i]+np1p.y*disp_x[i],
                    na.z*round_length*displace[i]+np1p.z*disp_x[i]
                );
                normal.normalize();
                // WARNING TODO : bad normals
                insole.addVertex(attr);
                curve1[i] = insole.vertexCount()-1;
            }
            curve1[displace.length-1] = e1[0]+v_offset;

            curr_v = e1[0];
        }else{
            if(!border_finished){
                border_finished = true;
                if(recess_hole && recess_hole.length){
                    curr_v = recess_hole[0];
                    round_length = recess_length;
                }else{
                    recess_finished = true;
                }
            }else{
                recess_finished = true;
            }
        }
        // Now we can build the patch p0,p0p,p1p,p1, except in the start case
        // where the p0,p0p curve has not been built
        if(curve0 !== null){
            for(var i=0; i<curve0.length-1;++i){
                insole.addFace(curve0[i],curve0[i+1],curve1[i+1]);
                insole.addFace(curve1[i+1],curve1[i],curve0[i]);
            }
        }
    }

    return insole;

};

podo3d.applyARC_BRC = function(insole_mesh, arc)
{

    var position = insole_mesh.getAttribute('position');
    var normal = insole_mesh.getAttribute('normal');

    var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
    var arc_mesh_arr = [new XTHREE.Mesh(arc,mat)];

    var vec = new XTHREE.Vector3();
    var n = new XTHREE.Vector3();
    // tmp var for setVertex
    var attr = {
        position:vec,
        normal:n
    };

    var fn = new XTHREE.Vector3();
    var vecZ = new XTHREE.Vector3(0,0,1);
    var origin = new XTHREE.Vector3();
    var dirZ = new XTHREE.Vector3(0,0,1);
    var raycaster = new XTHREE.Raycaster();
    for(var i=0; i<insole_mesh.vertexCount(); ++i){
        vec.set(position.getX(i),position.getY(i),position.getZ(i));

        origin.set(vec.x,vec.y,0);
        raycaster.set(origin, dirZ);
        var intersects = raycaster.intersectObjects(arc_mesh_arr);
        if(intersects.length !== 0){
            vec.z = vec.z + intersects[0].distance;

            // Compute the final normal from the normals of the arc and the insole.
            // Warning : kind of tricky, even though this is only maths :)
            n.set(normal.getX(i),normal.getY(i),normal.getZ(i));
            fn.copy(intersects[0].face.normal);
            if(vecZ.dot(n) < 0){
                fn.multiplyScalar(-1);
            }
            n.multiplyScalar(1/Math.abs(n.z));
            fn.multiplyScalar(1/Math.abs(fn.z));
            n.add(fn);
            n.z = n.z/Math.abs(n.z);
            n.normalize();

            insole_mesh.setVertex(i,attr);
        }
    }
}

podo3d.convertBufferTriGeometryToSkimArrayBufferMesh = function(geometry){
    var res = new skim.utils.ArrayBufferMesh(10);
    res.set(
        geometry.getAttribute('position').array.slice(0,geometry.vertexCount()*3),
        geometry.getAttribute('normal').array.slice(0,geometry.vertexCount()*3),
        geometry.getIndex().array.slice(0,geometry.faceCount()*3),
        null,null,null,
        geometry.vertexCount(),
        geometry.faceCount()
    );
    return res;
};

podo3d.getSoleIDText = function(date, cover_type, cover_size, width, stick, user_prod_id, sole_number){
    var id = user_prod_id.toString(36).toUpperCase();
    if(id.length>3){
        console.warn("WARNING : user productionId should not be more than 3 char in base 36");
    }
    while(id.length<3){ id = "0"+id; }

    var month = (date.getMonth()+1).toString();
    if(month.length === 1){ month = "0"+month; }

    var day = (date.getDate()).toString();
    if(day.length === 1){ day = "0"+day; }

    var year = (date.getFullYear()).toString();
    year = year.substring(2,4);

    var ns = sole_number.toString();
    if(ns.length == 1){ ns="00"+ns; }
    if(ns.length == 2){ ns="0"+ns; }

    return day+month+year+"-"+cover_type+cover_size+width+(stick?1:0)+"-"+id+sole_number;
};



podo3d.buildTextImageData = function(text, bold){
    // Project onto the height map
    // Extrude in 3D
    // Remove UV for backface
    // Apply displacement
    // Create the displacement
    // Here is a fidlle to check sizes : http://jsfiddle.net/g541688a/
    var canvas = new Canvas(
        (bold ? 25 : 24)*text.length,
        33
    );
    var ctx = canvas.getContext('2d');
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#808080";
    ctx.fill();
    ctx.fillStyle = "white";
    ctx.font = (bold ? "bold " : "") + "40px 'Lucida Console', Monaco, monospace";
    ctx.textBaseline = 'alphabetic';
    ctx.scale(1,1);
    ctx.fillText(text, 0, 29);

    return ctx.getImageData(0,0,canvas.width ,canvas.height);
};

// Get the best possible approximation of the text zone center
// with respect to the sole direction
podo3d.getTextZoneCenterInSoleDir = function(txt_zone, sole_dir){
    var min = Number.MAX_VALUE;
    var max = -Number.MAX_VALUE;
    var p = txt_zone.getAttribute("position");
    var tmp = new XTHREE.Vector3();
    for(var i=0; i<txt_zone.vertexCount(); ++i){
        tmp.set(p.getX(i), p.getY(i), p.getZ(i));
        var d = tmp.dot(sole_dir);
        min = Math.min(d,min);
        max = Math.max(d,max);
    }

    var c = txt_zone.boundingBox.getCenter(new XTHREE.Vector3());
    var c_dot_dir = c.dot(sole_dir);
    var ortho = c.clone().sub(tmp.copy(sole_dir).multiplyScalar(c_dot_dir));

    var avg_minmax = (max+min)*0.5;
    var res = sole_dir.clone().multiplyScalar(avg_minmax);

    res.add(ortho.multiplyScalar(c_dot_dir/avg_minmax));

    return res;
};

/**
 *  @param {string} text The text to engrave
 *  @param {ImageData} text_img_data The image of the text as an ImageData. This is built externally so that this function can be used in a worker.
 *  @param {XTHREE.BufferTriGeometry} txt_zone The zone on which the text should be built.
 *  @param {XTHREE.Vector3} soledir the sole direction, if not normalized, WILL BE NORMALIZED.
 */
podo3d.buildSoleIDPatch = function(pattern, zone_meshes, soledir, hmap, footside, txt_zone, text, text_img_data, sole_thickness, letter_params, border_offset){

    letter_params = letter_params || {
        w:3.3,  // width
        h:4.17,  // height
        d:0.8 // depth
    };

    border_offset = border_offset === undefined ? 1 : border_offset;

    soledir.normalize();

    // tmp vars
    var vec0 = new XTHREE.Vector3();
    var vec1 = new XTHREE.Vector3();

    var p_width = letter_params.w*text.length;
    // var p_height = 6;
    var p_depth = letter_params.d;
    var step = letter_params.h/31;

    // TODO : assert : check normals orientation of pattern : should be +z

    var borderHelper = new podo3d.PatternEdgesHelper(pattern,zone_meshes);
    txt_zone.computeBoundingBox();
    var closest_p = txt_zone.boundingBox.getCenter(new XTHREE.Vector3()).clone();
    //var closest_p = podo3d.getTextZoneCenterInSoleDir(txt_zone, soledir);
    var vstart = borderHelper.getClosestBorderVertex(
        closest_p.applyMatrix4(zone_meshes["By"].matrixWorld)
    );

    var edges = borderHelper.singularEdges;

    var rev_edges = pattern.getSingularEdgesAsObject(true);

    var pattern_p = pattern.getAttribute('position');

    // we will go back in half length direction to center the patch
    // That mean if we consider vstart to be the starting point, we move vstart.
    var revShift = function(){
        var rev_length = 0;
        while(rev_length < 0.5*p_width){
            var v1 = rev_edges[vstart][1];
            var vec = new XTHREE.Vector3(
                pattern_p.getX(v1)-pattern_p.getX(vstart),
                pattern_p.getY(v1)-pattern_p.getY(vstart),
                pattern_p.getZ(v1)-pattern_p.getZ(vstart)
            );
            vstart = v1;
            rev_length += vec.length();
        }
    }
    revShift();
    // Move along the sole edge to get 1 long enough line
    // Since the pattern face the foot, the edges we want are direct oriented
    var i0 = vstart;
    var i1 = edges[vstart][1];
    var edge_path = [{
        i0:i0,
        i1:i1,
        v0:new XTHREE.Vector3(pattern_p.getX(i0),pattern_p.getY(i0),pattern_p.getZ(i0)),
        v1:new XTHREE.Vector3(pattern_p.getX(i1),pattern_p.getY(i1),pattern_p.getZ(i1)),
        dir:new XTHREE.Vector3(
                    pattern_p.getX(i1)-pattern_p.getX(i0),
                    pattern_p.getY(i1)-pattern_p.getY(i0),
                    pattern_p.getZ(i1)-pattern_p.getZ(i0)
            )
    }];
    edge_path[0].n = Math.max(1,Math.round(edge_path[0].dir.length()/step));
    var path_length = edge_path[0].dir.length();
    var n_v = 1+edge_path[0].n;
    // ext_dir is the average normal direction used for extrusion later.
    var ext_dir = new XTHREE.Vector3(
                        -edge_path[0].dir.y/path_length,
                        edge_path[0].dir.y/path_length,
                        0
    );
    while(path_length<p_width){
        i0 = edge_path[edge_path.length-1].i1;
        i1 = edges[i0][1];
        edge_path.push({
            i0 : i0,
            i1 : i1,
            v0 : new XTHREE.Vector3(pattern_p.getX(i0),pattern_p.getY(i0),pattern_p.getZ(i0)),
            v1 : new XTHREE.Vector3(pattern_p.getX(i1),pattern_p.getY(i1),pattern_p.getZ(i1)),
            dir :new XTHREE.Vector3()
        });
        var e = edge_path[edge_path.length-1];
        e.dir.subVectors(e.v1,e.v0);
        var l = e.dir.length();
        e.n = Math.max(1,Math.round(l/step));
        path_length += l;
        n_v += e.n;
        ext_dir.x += -e.dir.y/l; // add normal to average the direction
        ext_dir.y +=  e.dir.x/l;
    }
    ext_dir.divideScalar(edge_path.length);
    ext_dir.normalize();

    var geometry = new XTHREE.BufferTriGeometry();
    // Extrude the line into a 2D surface, in the average 2D normal direction
    var attr = {
        position:new XTHREE.Vector3(edge_path[0].v0.x, edge_path[0].v0.y,edge_path[0].v0.z)
    };
    geometry.addVertex(attr);
    for(var i=0; i<edge_path.length; ++i){
        var e = edge_path[i];
        for(var k=0; k<e.n; ++k){
            attr.position.set(
                e.v0.x + e.dir.x*(k+1)/e.n,
                e.v0.y + e.dir.y*(k+1)/e.n,
                e.v0.z + e.dir.z*(k+1)/e.n
            );
            geometry.addVertex(attr);
        }
    }
    var ort_soledir = (new XTHREE.Vector3()).crossVectors(new XTHREE.Vector3(0,0,1), soledir);
    if(footside === "right"){
        ort_soledir.multiplyScalar(-1);
    }
    geometry.translate(
        border_offset*ort_soledir.x,
        border_offset*ort_soledir.y,
        border_offset*ort_soledir.z
    );
    // following is a trick to place new vertices where we want.
    geometry.extrude(step,ext_dir); // p_height = step
    geometry.extrude(2*step,ext_dir); // p_height = 3*step
    geometry.extrude(4*step,ext_dir); // p_height = 7step
    geometry.extrude(8*step,ext_dir); // p_height = 15step
    geometry.extrude(16*step,ext_dir); // p_height = 31step
    var position = geometry.getAttribute('position');
    // Tile this 2D surface
    for(var j=0; j<32-1; ++j){
        for(i=0; i<n_v-1; ++i){
            geometry.addFace( j*n_v+i+1, j*n_v+i, (j+1)*n_v+i+1 );
            geometry.addFace( j*n_v+i, (j+1)*n_v+i, (j+1)*n_v+i+1);
        }
    }
    geometry.computeVertexNormals();
    // Build with uv coordinates
    var uv = new XTHREE.BufferAttribute( new Float32Array(2*position.count), 2 );
    var i_uv = 0;
    for(var j=0; j<32; ++j){
        var v = 1.0-j/31;
        for(i=0; i<n_v; ++i){
            var u = i/(n_v-1);
            uv.setXY(i_uv, u, v);
            i_uv++;
        }
    }
    geometry.addAttribute('uv',uv);

    geometry.translate(0,0,hmap.getMinHeight()-10); // apply an epsilon just in case.
    geometry.project([hmap], 60, new XTHREE.Vector3(0,0,1));

    // Here we have a model fitting the foot with u/v coordinates setup for engraving.
    // The engraving can be done now, or later (as far as we keep the uvs).
    // Therefore, it may be faster to load a 3D pattern with uvs, and only project it
    // That may save computing time.

    // Extrude to have a 3D patch.
    var n_disp = new XTHREE.DisplacementMap(1,1);
    n_disp.setDisp(0,0,sole_thickness);

    geometry.applyDisplacement(n_disp);
    var prev_nv = geometry.getAttribute('position').count;
    geometry.extrude(-1, null, {patch:true, round:false} );
    var uv = geometry.getAttribute('uv');
    for(var i=prev_nv; i<uv.count; ++i){
        uv.setXY(i,0,0);
    }

    var grav_disp = new XTHREE.DisplacementMap(text_img_data.width ,text_img_data.height);
    grav_disp.setFromImageData(text_img_data, p_depth);

    geometry.applyDisplacement(grav_disp);

    return geometry;
};
/**
 *  @param {string} text The text to engrave
 *  @param {ImageData} text_img_data The image of the text as an ImageData. This is built externally so that this function can be used in a worker.
 *  @param {XTHREE.Vector3} soledir the sole direction, if not normalized, WILL BE NORMALIZED.
 */
podo3d.buildSoleInitialPatch = function(pattern, zone_meshes, soledir, hmap, txt_zone, text, text_img_data, sole_thickness, letter_params, border_offset)
{
    letter_params = letter_params || {
        w:3,  // width
        h:4.1,  // height
        d:0.8 // depth
    };
    border_offset = border_offset === undefined ? 1 : border_offset;

    var pattern_p = pattern.getAttribute('position');

    soledir.normalize();

    // tmp vars
    var vec0 = new XTHREE.Vector3();
    var vec1 = new XTHREE.Vector3();

    var p_width = letter_params.w*text.length;
    // var p_height = 6;
    var p_depth = letter_params.d;
    var step = letter_params.h/31;

    // TODO : assert : check normals orientation of pattern : should be +z

    // get the extreme point in soledir direction
    /*
    var extr_p = new XTHREE.Vector3(pattern_p.getX(0),pattern_p.getY(0),pattern_p.getZ(0));
    var vstart = 0;
    for(var i=0; i<pattern.vertexCount(); ++i){
        vec0.set(pattern_p.getX(i),pattern_p.getY(i),pattern_p.getZ(i));
        if(vec0.dot(soledir)<extr_p.dot(soledir)){
            extr_p.copy(vec0);
            vstart = i;
        }
    }
    */

    var borderHelper = new podo3d.PatternEdgesHelper(pattern,zone_meshes);
    txt_zone.computeBoundingBox();
    var closest_p = txt_zone.boundingBox.getCenter(new XTHREE.Vector3()).clone();
    var vstart = borderHelper.getClosestBorderVertex(
        closest_p.applyMatrix4(zone_meshes["By"].matrixWorld)
    );

    // Get external edges of the pattern
    var edges = pattern.getSingularEdgesAsObject();
    var rev_edges = pattern.getSingularEdgesAsObject(true);
    // we will go back in half length direction to center the patch
    var revShift = function(){
        var rev_length = 0;
        while(rev_length < 0.5*p_width){
            var v1 = rev_edges[vstart][1];
            var vec = new XTHREE.Vector3(
                pattern_p.getX(v1)-pattern_p.getX(vstart),
                pattern_p.getY(v1)-pattern_p.getY(vstart),
                pattern_p.getZ(v1)-pattern_p.getZ(vstart)
            );
            vstart = v1;
            rev_length += vec.length();
        }
    }
    revShift();
    // Move along the sole edge to get 1 long enough line
    // Since the pattern face the foot, the edges we want are direct oriented
    var i0 = vstart;
    var i1 = edges[vstart][1];
    var edge_path = [{
        i0:i0,
        i1:i1,
        v0:new XTHREE.Vector3(pattern_p.getX(i0),pattern_p.getY(i0),pattern_p.getZ(i0)),
        v1:new XTHREE.Vector3(pattern_p.getX(i1),pattern_p.getY(i1),pattern_p.getZ(i1)),
        dir:new XTHREE.Vector3(
                    pattern_p.getX(i1)-pattern_p.getX(i0),
                    pattern_p.getY(i1)-pattern_p.getY(i0),
                    pattern_p.getZ(i1)-pattern_p.getZ(i0))
    }];
    edge_path[0].n = Math.max(1,Math.round(edge_path[0].dir.length()/step));
    var path_length = edge_path[0].dir.length();
    var n_v = 1+edge_path[0].n;
    // ext_dir is the average normal direction used for extrusion later.
    var ext_dir = new XTHREE.Vector3(
                        -edge_path[0].dir.y/path_length,
                        edge_path[0].dir.y/path_length,
                        0
    );
    while(path_length<p_width){
        i0 = edge_path[edge_path.length-1].i1;
        i1 = edges[i0][1];
        edge_path.push({
            i0 : i0,
            i1 : i1,
            v0 : new XTHREE.Vector3(pattern_p.getX(i0),pattern_p.getY(i0),pattern_p.getZ(i0)),
            v1 : new XTHREE.Vector3(pattern_p.getX(i1),pattern_p.getY(i1),pattern_p.getZ(i1)),
            dir :new XTHREE.Vector3()
        });
        var e = edge_path[edge_path.length-1];
        e.dir.subVectors(e.v1,e.v0);
        var l = e.dir.length();
        e.n = Math.max(1,Math.round(l/step));
        path_length += l;
        n_v += e.n;
        ext_dir.x += -e.dir.y/l; // add normal to average the direction
        ext_dir.y +=  e.dir.x/l;
    }
    ext_dir.divideScalar(edge_path.length);
    ext_dir.normalize();
    // Extrude the line into a 2D surface, in the average 2D normal direction
    var geometry = new XTHREE.BufferTriGeometry();
    // Extrude the line into a 2D surface, in the average 2D normal direction
    var attr = {
        position:new XTHREE.Vector3(edge_path[0].v0.x, edge_path[0].v0.y,edge_path[0].v0.z)
    };
    geometry.addVertex(attr);
    for(var i=0; i<edge_path.length; ++i){
        var e = edge_path[i];
        for(var k=0; k<e.n; ++k){
            attr.position.set(
                e.v0.x + e.dir.x*(k+1)/e.n,
                e.v0.y + e.dir.y*(k+1)/e.n,
                e.v0.z + e.dir.z*(k+1)/e.n
            );
            geometry.addVertex(attr);
        }
    }
    // following is a trick to place new vertices where we want.
    geometry.translate(
        border_offset*soledir.x,
        border_offset*soledir.y,
        border_offset*soledir.z
    );
    geometry.extrude(step,ext_dir); // p_height = step
    geometry.extrude(2*step,ext_dir); // p_height = 3*step
    geometry.extrude(4*step,ext_dir); // p_height = 7step
    geometry.extrude(8*step,ext_dir); // p_height = 15step
    geometry.extrude(16*step,ext_dir); // p_height = 31step
    var position = geometry.getAttribute('position');
    // Tile this 2D surface
    for(var j=0; j<32-1; ++j){
        for(i=0; i<n_v-1; ++i){
            geometry.addFace( j*n_v+i+1, j*n_v+i, (j+1)*n_v+i+1 );
            geometry.addFace( j*n_v+i, (j+1)*n_v+i, (j+1)*n_v+i+1);
        }
    }
    geometry.computeVertexNormals();
    // Build with uv coordinates
    var uv = new XTHREE.BufferAttribute( new Float32Array(2*position.count), 2 );
    var i_uv = 0;
    for(var j=0; j<32; ++j){
        var v = 1.0-j/31;
        for(i=0; i<n_v; ++i){
            var u = i/(n_v-1);
            uv.setXY(i_uv, u, v);
            i_uv++;
        }
    }
    geometry.addAttribute('uv',uv);


    var grav_disp = new XTHREE.DisplacementMap(text_img_data.width ,text_img_data.height);
    grav_disp.setFromImageData(text_img_data, p_depth);
    var n_disp = new XTHREE.DisplacementMap(1,1);
    n_disp.setDisp(0,0,sole_thickness);

    geometry.translate(0,0,hmap.getMinHeight()-10); // apply an epsilon just in case.
    geometry.project([hmap], 60, new XTHREE.Vector3(0,0,1));

    // Trick to displace in the normal direction.
    geometry.applyDisplacement(n_disp);
    var prev_nv = geometry.getAttribute('position').count;
    geometry.extrude(-1, null, {patch:true, round:false});
    var uv = geometry.getAttribute('uv');
    for(var i=prev_nv; i<uv.count; ++i){
        uv.setXY(i,0,0);
    }
    geometry.applyDisplacement(grav_disp);

    return geometry;
};

/**
 *  Start on on point inside the insole and iterate in direction dir (x/y),
 *  test position with respect to soleMeshes.
 *  return t such that start_in+t*dir is the last point inside (modulo step).
 *  return -1 iff all point from start_in to start_in + t*limit are inside.
 */
podo3d.findInsideSoleLimit = function(start_in, dir, limit, step, soleMeshes){
    var front_objs = [
        soleMeshes.E,
        soleMeshes.Dx, soleMeshes.Dy, soleMeshes.Dz,
        soleMeshes.C,
        soleMeshes.Bx, soleMeshes.By, soleMeshes.Bz,
        soleMeshes.CenterH, soleMeshes.CenterB,
        soleMeshes.Fx, soleMeshes.Fy,
        soleMeshes.A, soleMeshes.G
    ];
    var zoffset = -500;
    var origin = new XTHREE.Vector3();
    var cast_dir = new XTHREE.Vector3(0,0,1);
    var raycaster = new XTHREE.Raycaster();

    var curr = new XTHREE.Vector3();
    curr.copy(start_in);

    var out = false;
    var t = step;
    var stop =false;
    while(!out && !stop){
        if(t>limit){
            stop = true;
        }
        origin.set(curr.x,curr.y,zoffset);
        raycaster.set(origin, cast_dir);
        intersects = raycaster.intersectObjects(front_objs);
        if(intersects.length === 0){
            out = true;
        }else{
            t+=step;
        }
        curr.copy(dir).multiplyScalar(t).add(start_in);
    }

    if(out){
        return t-step;
    }else{
        return -1;
    }
};

/**
 *  Small util to clone an array of Bezier Path
 */
podo3d.cloneBezierPathArray = function(b_arr){
    var res = [];
    for(var i=0; i<b_arr.length; ++i){
        res.push(b_arr[i].clone());
    }
    return res;
};


/**
 *  @param {Array.<Number>} positions Positions of each antero in [0,2]
 *  @param {number} border res contour resolution in mm
 *  @param {number} inside_res, mesh resolution insode the contour, in mm.
 *  @param {BezierPath} c_heads
 *  @param {Array.<BezierPath>} c_up
 *  @param {Array.<BezierPath>} c_down
 *  @param {number} sole_thick : the thickness of the insole in the front.
 *  @param {number} antero_thick : the thickness wanted of the antero.
 *
 *  @result {XTHREE.BufferTriGeometry} The flat 2D geometry of the antero parts. If antero thick !== sole_front_thick, the
 *                                       geometry will have an extrudeDist attribute which specify for each vertex how long
 *                                       must be the extrusion to have the expected thickness in all parts.
 */
podo3d.buildAnteroGeometry = function(positions, c_heads, c_up, c_down, border_res, inside_res, sole_front_thick, antero_thick){

    var b_arr = [];

    b_arr.push(c_heads);

    var updown = positions.slice(0,positions.length);

    var cp = [];
    var bbox = new XTHREE.Box3();
    for(var i=0; i<5; ++i){
        c_up[i].computeBoundingBox();
        c_down[i].computeBoundingBox();
        var bbup = c_up[i].boundingBox;
        var bbdown = c_down[i].boundingBox;

        bbox.union(bbup).union(bbdown);

        var ctr_up = bbup.getCenter(new XTHREE.Vector3());
        var ctr_down = bbdown.getCenter(new XTHREE.Vector3());
        var tr = new XTHREE.Vector3().subVectors(ctr_up,ctr_down);
        if(updown[i] < 0.5){
            tr.multiplyScalar(updown[i]);
            var clone = c_down[i].clone().translate(tr.x,tr.y,tr.z);
            b_arr.push(new XTHREE.BezierPath(cp));
            cp = [];
            b_arr.push(clone);
        }else{
            tr.multiplyScalar(updown[i]-1);
            var clone = c_up[i].clone().translate(tr.x,tr.y,tr.z);
            var st = i===0? 0 : (updown[i-1] < 0.5 ? 0 : 2);
            var end = i===4? 7 : (updown[i+1] < 0.5 ? 7 : 5);
            if(st===3 && end===4){
                st--;
                end++;
            }
            Array.prototype.push.apply(cp, clone.controlPoints.slice(st,end));
        }
    }
    b_arr.push(new XTHREE.BezierPath(cp));

    var b = XTHREE.BezierPath.merge(b_arr,true);

    // The merge function will close the path in a smart way, but we need something special at heads ends
    // to keep the tangents.
    // So we tweak the concerned control points.
    var h_c = c_heads.countControlPoints();
    b.setControlPoint(
        h_c,
        b.getControlPoint(h_c-1).clone().lerp(
            b.getControlPoint(h_c-2),
            0.3*(1-updown[0])+2*updown[0]
        )
    );
    var b_c = b.countControlPoints();
    b.setControlPoint(
        b_c-2,
        b.getControlPoint(0).clone().lerp(
            b.getControlPoint(1),
            0.3*(1-updown[4])+2*updown[4]
        )
    );

    var pts = b.getSpacedPoints(Math.max(Math.round(b.getLength()/border_res),50));
    var polygonizer = new XTHREE.PolylinePolygonizer(pts, [], inside_res);
    var geometry = polygonizer.triangulate();

    if(sole_front_thick  && antero_thick && antero_thick !== sole_front_thick){

        var flat = 5+inside_res + 0.1;
        var progress = flat+7;

        var border_progress = 1.5;

        var c_front = XTHREE.BezierPath.merge(b_arr.slice(1,b_arr.length),false);
        var front_poly = c_front.getSpacedPoints(Math.round(c_front.getLength()/border_res));

        var h_poly = c_heads.getSpacedPoints(Math.round(c_heads.getLength()/border_res));
        // Antero curves may be given with some offset in z.
        // however, the PolyLinePolygonizer only returns a 2D geometry in X,Y.
        // So in order to compute the distance to the heads curve, we need to
        // ensure this curve is considered at z = 0
        for(var i=0; i<h_poly.length; ++i){
            h_poly[i].z = 0;
        }
        for(var i=0; i<front_poly.length; ++i){
            front_poly[i].z = 0;
        }
        for(var i=0; i<pts.length; ++i){
            pts[i].z = 0;
        }


        geometry.addVertexAttribute('extrudeDist', Float32Array, 1);
        var extrudeDist = geometry.getAttribute('extrudeDist');
        var p = geometry.getAttribute('position');
        var vec = new XTHREE.Vector3();
        for(var i=0; i<geometry.vertexCount(); ++i){
            vec.set(p.getX(i), p.getY(i), p.getZ(i));
            var dist = XTHREE.PolylineUtils.distanceToPoint(h_poly, vec);
            var dist_border = XTHREE.PolylineUtils.distanceToPoint(pts, vec);

            var h_thick = sole_front_thick; // thickness expected from the distance to the heads
            if(dist > progress){
                h_thick = antero_thick;

            }else if(dist>flat){
                var t = (dist-flat)/(progress-flat);
                h_thick = t*antero_thick + (1-t)*sole_front_thick;
            }

            var border_thick = antero_thick;
            if(dist_border<border_progress){
                var t = dist_border/border_progress;
                border_thick = t*antero_thick+(1-t)*sole_front_thick;
            }
            extrudeDist.setX(i,Math.min(border_thick,h_thick));
        }
    }

    /*
    var pts = b.getSpacedPoints(Math.max(Math.round(b.getLength()/res),50));
    var indices = XTHREE.ShapeUtils.triangulateShape(pts,[]);

    var geometry = new XTHREE.BufferTriGeometry();
    var attr = {
        position:new XTHREE.Vector3(),
        normal:new XTHREE.Vector3(0,0,1)
    };
    for(var i=0; i<pts.length; ++i){
        attr.position.copy(pts[i]);
        geometry.addVertex(attr);
    }
    for(var i=0; i<indices.length; i++){
        geometry.addFace(indices[i][0],indices[i][1],indices[i][2]);
    }
    */


    geometry.minimizeBuffers();

    geometry.computeVertexNormals();

    return geometry;
};

podo3d.getAnteroStartEndCursors = function(c_heads, c_up, c_down){
    var res = [];
    for(var i=0; i<5; ++i){
        c_up[i].computeBoundingBox();
        c_down[i].computeBoundingBox();
        var bbup = c_up[i].boundingBox;
        var bbdown = c_down[i].boundingBox;

        res.push({
            start: bbdown.getCenter(new XTHREE.Vector3()),
            end: bbup.getCenter(new XTHREE.Vector3())
        });
    }
    return res;
};

/**
 *  Modify the given c_heads, c_down, c_up to apply the adjustment transformation
 */
podo3d.adjustAnteroCurves = function(c_heads, c_up, c_down, sole_refpts, foot_side, foot_width, foot_size, adjusted_pts){ //var data = podiatrySMFunc.podiatry.antero.data;


    var side_scale = foot_side === "right" ? -1 :1;

    var mat_ad = podo3d.computeSoleAdjustMatrix(adjusted_pts);
    var mat_o = podo3d.computeSoleOrientationMatrix(sole_refpts, foot_side);
    var ad_heel = adjusted_pts.heel.clone();
    ad_heel.z = 0; // no z translation, whatever the offset for visualization
    mat_ad.setPosition(ad_heel);

    var scale = podo3d.getGabScale(foot_width, foot_size, 40);

    c_heads.scale(1,side_scale,1).scale(
        scale.x, scale.y, scale.z
    ).translate(
        sole_refpts.heel.x,
        sole_refpts.heel.y,
        sole_refpts.heel.z
    ).applyMatrix4(mat_o).applyMatrix4(mat_ad);
    for(var i=0; i<5; i++){
        c_down[i].scale(1,side_scale,1).scale(
        scale.x, scale.y, scale.z
        ).translate(
            sole_refpts.heel.x,
            sole_refpts.heel.y,
            sole_refpts.heel.z
        ).applyMatrix4(mat_o).applyMatrix4(mat_ad);
        c_up[i].scale(1,side_scale,1).scale(
        scale.x, scale.y, scale.z
        ).translate(
            sole_refpts.heel.x,
            sole_refpts.heel.y,
            sole_refpts.heel.z
        ).applyMatrix4(mat_o).applyMatrix4(mat_ad);
    }

};

podo3d.buildFinalAntero = function(
    hmap,
    geometry2d,
    sole_thickness,
    thickness // the antero patch thickness, only used if geometry2d has no attribute extrudeDist
){
    var geometry = geometry2d;

    geometry.translate(0,0,hmap.getMinHeight()-10); // apply an epsilon just in case.
    geometry.project([hmap], 60, new XTHREE.Vector3(0,0,1));

    // Hack : since bezier polygonization is not really nice,
    //        some normals may be badly computed.
    //        This creates artefacts so until we have a better meshing algorithm,
    //        we just set normals to 0,0,1.
    var normals = new Float32Array(geometry.vertexCount()*3);
    normals.fill(0);
    for(var i=2; i<normals.length; i+=3){
        normals[i] = 1;
    }
    var normals2 = normals.slice(0,normals.length);
    geometry.setVertexAttribute('normal',normals);
    ////////////////////

    var n_disp = new XTHREE.DisplacementMap(1,1);
    n_disp.setDisp(0,0,-sole_thickness);
    var nv = geometry.getAttribute('position').count;
    var uv = new XTHREE.BufferAttribute(new Float32Array(nv*2), 2);
    geometry.addAttribute('uv', uv);
    geometry.applyDisplacement(n_disp);

    geometry.setVertexAttribute('normal',normals2);

    var extrudeDist = geometry.getAttribute('extrudeDist');
    geometry.extrude(extrudeDist ? null : thickness, null, {patch:true, round:true, scale:1.0, resolution:9});

    geometry.computeVertexNormals();

    return geometry;
};

podo3d.buildStabilityElement = function(stability_geom, adjust_mat, angle, foot_mesh, foot_size, foot_width, sole_thickness){

    // Data to be sent via email if something weird is detected.
    var debugData = {};

    var result = (new XTHREE.BufferTriGeometry()).copy(stability_geom);
    if(result.getAttribute("normal") === undefined){
        result.computeVertexNormals();
    }

    var scale = podo3d.getGabScale(foot_width, foot_size, 40);

    result.scale(scale.x,scale.y,1);
    var matrix = new XTHREE.Matrix4();
    matrix.makeRotationX(angle);
    result.applyMatrix(matrix);
    result.applyMatrix(adjust_mat);

    var proj_dir = new XTHREE.Vector3(0,0,1);
    proj_dir.applyMatrix4(matrix);

    debugData.proj_dir = proj_dir.clone();

    foot_mesh.geometry.computeBoundingBox();
    var aabb_foot = foot_mesh.geometry.boundingBox;
    var foot_sizes = aabb_foot.getSize(new XTHREE.Vector3());

    debugData.foot_mesh_aabb = aabb_foot.clone();
    debugData.foot_mesh_sizes = foot_sizes.clone();

    result.computeBoundingBox();
    var aabb_stabel = result.boundingBox;
    var stabel_sizes = aabb_stabel.getSize(new XTHREE.Vector3());

    debugData.foot_mesh_aabb = aabb_stabel.clone();
    debugData.foot_mesh_sizes = stabel_sizes.clone();

    // apply offset for raycasting to ensure the foot is in front
    var offset = 2*(Math.max(foot_sizes.x, Math.max(foot_sizes.y, foot_sizes.z))
                 + Math.max(stabel_sizes.x, Math.max(stabel_sizes.y, stabel_sizes.z)));

    debugData.offset = offset;

    var position = result.getAttribute("position");
    var normal = result.getAttribute("normal");
    var raycaster = new XTHREE.Raycaster();
    var origin = new XTHREE.Vector3();
    var min_dist = Number.MAX_VALUE;
    for(var i=0; i<result.vertexCount(); ++i){
        origin.set(
            position.getX(i)-proj_dir.x*offset,
            position.getY(i)-proj_dir.y*offset,
            position.getZ(i)-proj_dir.z*offset
        );
        raycaster.set(origin,proj_dir);
        var intersects = raycaster.intersectObject(foot_mesh);
        if(intersects.length !== 0){
            min_dist = Math.min(intersects[0].distance, min_dist);
        }
    }

    debugData.min_dist = min_dist;

    if(min_dist!==Number.MAX_VALUE){
        var tr = proj_dir.clone().multiplyScalar(min_dist-offset-sole_thickness);
        result.translate(tr.x,tr.y,tr.z);
        debugData.translated = true;
    }else{
        debugData.translated = false;
    }

    result.extrude(sole_thickness, null, {patch:true, round:true, scale:1.0, resolution:9});

    result.computeBoundingBox();
    debugData.extruded_bbox = result.boundingBox.clone();

    return {
        mesh:result,
        debugData:debugData
    };
};


/**
 *  Compute only orientation based on the 3 adjust points.
 *  Position can be set outside this function, depending on what is needed.
 *  @param {{meta1;XTHREE.Vector3, meta5:XTHREE.Vector3, heel:XTHREE.Vector3}} adjusted_pts
 */
podo3d.computeSoleAdjustMatrix = function(adjusted_pts){
    var newX = new XTHREE.Vector3();
    var newY = new XTHREE.Vector3();
    var newZ = new XTHREE.Vector3(0,0,1);

    var mat = new XTHREE.Matrix4();
    mat.identity();

    // Z does not change, X will be a new vector, and Y computed from
    // Z and X. Position will be the adjusted heel
    newX.addVectors(
        adjusted_pts.meta1,
        adjusted_pts.meta5
    );
    newX.multiplyScalar(0.5);
    newX.sub(adjusted_pts.heel);
    newX.normalize();

    newY.crossVectors(newZ, newX);

    mat.makeBasis(newX,newY,newZ);

    return mat;
};

/**
 *  This will compute the orientation matrix used to reposition the sole from the database
 *  @param {{meta1;XTHREE.Vector3, meta5:XTHREE.Vector3, heel:XTHREE.Vector3}} sole_refpts Reference points for the sole in database
 *  @param {string} foot_side Eithere "left" or "right"
 */
podo3d.computeSoleOrientationMatrix = function(sole_refpts, foot_side){
    // Build the orthonormal basis in which we want the scan to be
    var O = new XTHREE.Vector3();
    var newX = new XTHREE.Vector3();
    var newY = new XTHREE.Vector3();
    var newZ = new XTHREE.Vector3();

    var vec1 = new XTHREE.Vector3();
    var vec2 = new XTHREE.Vector3();

    O.copy(sole_refpts.heel);

    vec1.addVectors(sole_refpts.meta5, sole_refpts.meta1);
    vec1.multiplyScalar(0.5);
    newX.subVectors(vec1,sole_refpts.heel);
    newX.normalize();

    vec1.subVectors(sole_refpts.meta5, sole_refpts.heel);
    vec2.subVectors(sole_refpts.meta1, sole_refpts.heel);
    newZ.crossVectors(vec1,vec2);
    newZ.normalize();

    if(foot_side === "left"){
        newZ.multiplyScalar(-1);
    }
    newY.crossVectors(newZ,newX);
    newY.normalize();

    var mat4 = new XTHREE.Matrix4();
    mat4.set(   newX.x, newY.x, newZ.x, O.x,
                newX.y, newY.y, newZ.y, O.y,
                newX.z, newY.z, newZ.z, O.z,
                0,0,0,1);
    mat4.getInverse(mat4.clone());

    return mat4;
};

// @param {Object.<string,XTHREE.Mesh>} meshes Set of meshes
// @param {XTHREE.Matrix4} mat Matrix to decompose for setting meshes scale, position and rotation
// @return the decomposition of mat that has been applied.
podo3d.setMatrixOnMeshes = function(meshes,mat){
    var dec = {
        translation : new XTHREE.Vector3(),
        quaternion : new XTHREE.Quaternion(),
        scale : new XTHREE.Vector3()
    };
    mat.decompose(dec.translation, dec.quaternion, dec.scale);
    dec.quaternion.normalize();

    var keys = Object.keys(meshes);
    for(var i=0; i<keys.length; ++i){
        // Set according to build matrix
        meshes[keys[i]].position.copy(dec.translation);
        meshes[keys[i]].rotation.setFromQuaternion(dec.quaternion);
        meshes[keys[i]].scale.copy(dec.scale);
        // Three js will not update matrices before the next render,
        // so we do it here to ensure any following computation
        // (like ray tracing) will take the transformation into account
        meshes[keys[i]].updateMatrix();
        meshes[keys[i]].updateMatrixWorld();
    }

    return dec;
};

// @param {{meta1;XTHREE.Vector3, meta5:XTHREE.Vector3, heel:XTHREE.Vector3}} sole_refpts Reference points for the sole in database
// @param {Object.<string,DualBox.BufferTriGeometry>} pattern_zones Zones as loaded from sole pattern DB
podo3d.buildSoleProjectionMeshes = function(pattern_zones, foot_side){

    var zone_meshes = {};

    // build a mesh per zone
    var keys = Object.keys(pattern_zones);
    var zg_mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
    for(var i=0; i<keys.length; ++i){
        var mesh = pattern_zones[keys[i]].clone();
        var w_mesh = new XTHREE.Mesh(
            mesh,
            zg_mat
        );
        w_mesh.name = keys[i];
        zone_meshes[keys[i]] = w_mesh;
    }

    return zone_meshes;
};

podo3d.displaceContourFromHMap = function(contour, hmap, dist){
    // TODO : Should be replaced wth displace function call when dualbox will have one.
    var vec = new XTHREE.Vector3();
    var n = new XTHREE.Vector3();
    var attr = {
        position:new XTHREE.Vector3()
    };
    var positions = contour.getAttribute('position');
    for(var i =0; i<contour.vertexCount(); ++i){
        vec.set(positions.getX(i),positions.getY(i),positions.getZ(i));
        hmap.getNormal(vec.x,vec.y,n);
        attr.position.set(
            vec.x-dist*n.x,
            vec.y-dist*n.y,
            vec.z-dist*n.z
        );
        contour.setVertex(i, attr);
    }
    return contour;
};

// mesh : mesh on which the fitting ratio will be applied.
// ratio_mesh : the mesh defining the ratio in z (all points of this mesh must be in 0<z<1)
podo3d.applyFittingRatio = function(mesh, ratio_mesh){
    var mat = new XTHREE.MeshBasicMaterial({side:XTHREE.DoubleSide});
    var mesh_arr = [new XTHREE.Mesh(ratio_mesh,mat)];

    var position = mesh.getAttribute('position');
    var normal = mesh.getAttribute('position');

    var vec = new XTHREE.Vector3();
    var n = new XTHREE.Vector3();
    // tmp var for setVertex
    var attr = {
        position:vec,
        normal:n
    };

    var origin = new XTHREE.Vector3(0,0,ratio_mesh.boundingBox.min.z);
    var dirZ = new XTHREE.Vector3(0,0,1);
    var raycaster = new XTHREE.Raycaster();
    for(var i=0; i<mesh.vertexCount(); ++i){
        vec.set(position.getX(i),position.getY(i),position.getZ(i));

        origin.set(vec.x,vec.y,ratio_mesh.boundingBox.min.z);
        raycaster.set(origin, dirZ);
        var intersects = raycaster.intersectObjects(mesh_arr);
        if(intersects.length !== 0){
            vec.z = vec.z*intersects[0].distance; // apply a fitting ratio

            n.set(normal.getX(i),normal.getY(i),normal.getZ(i));
            if(n.dot(intersects[0].face.normal) > 0){
                n.add(intersects[0].face.normal);
            }else{
                n.sub(intersects[0].face.normal);
            }
            n.normalize();

            mesh.setVertex(i,attr);
        }
    }
};


/**
 *  @param {string} base_url : url to the folder of the patterns (like Meteor.absoluteUrl("img/cover_patterns") in scientifeet)
 *  @param {Number} footsize
 *  @param {string} footside
 *  @param {string} solewidth
 *
 *  @return : {{uvplane:XTHREE.Mesh, texData:ImageData}} a 3D plane (rectangle) with uv coordinates and an imageData object.
 *            The 3D plane has real world size according to the pattern image and
 *            the origin of the rectangle is the reference point.
 *
 *  Limitation : only works client side since it uses canvas to get Image Data.
 */
podo3d.loadCoverPattern = function(pngDataURL, footside, callback){

    var pixel_mm_ratio = 0.254;

    var processImage = function(img){

        var canvas = new Canvas(img.width,img.height);
        var context = canvas.getContext('2d');

        var scaleH = 1;
        var posX = 0;
        if(footside === "right"){
            scaleH = -1;
            posX = img.width * -1; // Set x position to -100% if flip horizontal
        }

        context.save(); // Save the current state
        context.scale(scaleH, 1); // Set scale to flip the image
        context.drawImage(img, posX, 0, img.width, img.height); // draw the image
        context.restore(); // Restore the last saved state
        var cvs_data = context.getImageData(0, 0, img.width, img.height);

        var red = [];
        // Note : we revert the height since canvas do not use the image orientation we want to use.
        for(var i=0; i<cvs_data.width; ++i){
            for(var j=0; j<cvs_data.height;++j){
                var idx = 4*(j*cvs_data.width+i);
                var value = cvs_data.data[idx]
                if(cvs_data.data[idx] > 200 && cvs_data.data[idx+1] < 70 && cvs_data.data[idx+1] < 70){
                    red.push({x:(cvs_data.height-j-0.5)*pixel_mm_ratio,y:(-0.5-i)*pixel_mm_ratio});
                }
            }
        }

        var red_dot = new XTHREE.Vector3();
        if(red.length !== 0){
            for(var i=0; i<red.length;++i){
                red_dot.x += red[i].x;
                red_dot.y += red[i].y;
            }
            red_dot.multiplyScalar(1/red.length);
        }else{
            throw "Error : cannot find red dot on the cover pattern image.";
        }

        var attr = {
            position:new XTHREE.Vector3,
            uv:new XTHREE.Vector2()
        };
        var geometry = new XTHREE.BufferTriGeometry();
        geometry.addVertexAttribute("uv", Float32Array, 2);
        attr.position.set(0,0,0);
        attr.uv.set(0,0);
        geometry.addVertex(attr);
        attr.position.set(0,-pixel_mm_ratio*img.width,0);
        attr.uv.set(1,0);
        geometry.addVertex(attr);
        attr.position.set(pixel_mm_ratio*img.height,-pixel_mm_ratio*img.width,0);
        attr.uv.set(1,1);
        geometry.addVertex(attr);
        attr.position.set(pixel_mm_ratio*img.height,0,0);
        attr.uv.set(0,1);
        geometry.addVertex(attr);
        geometry.addFace(0,1,2);
        geometry.addFace(2,3,0);

        geometry.translate(-red_dot.x, -red_dot.y, -red_dot.z);

        callback({
            uvplane:geometry.toJSON(),
            texData:(new ImageData(cvs_data.width, cvs_data.height, cvs_data.data)).toJSON(),
            texDataURL:canvas.toDataURL()
        });

    };

    if(inWorker()){
        throw "Error : Image load cannot work in worker. To workerize this, more work is needed to change the way the app is getting the image.";
    }else {

        var img = null;
        if(Canvas.Image){
            img = new Canvas.Image();
        }else{
            img = new Image();
        }
        img.onerror = function (err) {
          throw err;
        };
        // IMPORTANT NOTE :
        // For node-canvas, the src must be defined AFTER the onload.
        // I suspect this is because the call to onload is synchronous,
        // which is not the case for the browser Image object...
        img.onload = function(){
            processImage(img);
        };
        img.src = pngDataURL;
    }
}

/**
 *  Build some little segments to help the 3D printing company set the cover on the insole.
 *  @param {DualBox.BufferTriGeometry} pattern_resized The pattern, with holes resized and positionned as for the final morphing.
 *  @param {XTHREE.Vector3}
 *
 *  @return {Array<XTHREE.BufferTriGeometry>} The 5 segments to setup the frame, the order is [heel bottom, heel left and right, front left and right]
 */
podo3d.buildCoverFrameLines = function(pattern_resized, adjusted_pts, heel_pos, contour_start, contour_end, cover_tex, sole_thick){

    // Offset between the cover border and the sole border
    var heel_offset = 3 + sole_thick/2;

    var uvplane_mesh = new XTHREE.Mesh(
        cover_tex.uvplane,
        new XTHREE.MeshBasicMaterial({
            // map:XTHREE.ImageUtils.loadTexture(cover_tex.texDataURL), // removed since that does not work in a worker.
            side:XTHREE.DoubleSide}
        )
    );

    var walkTexture = function(start, dir, step, maxstep){
        var raycaster = new XTHREE.Raycaster();
        var origin = new XTHREE.Vector3();
        var direction = new XTHREE.Vector3(0,0,1);

        var objs = [uvplane_mesh];

        var stop = false;
        var i = 0;
        while(i<maxstep && !stop){
            origin.copy(dir).multiplyScalar(step*i).add(start);
            origin.z = -10; // offset to ensure intersection with the z = 0 plane.
            raycaster.set(origin, direction);
            var intersects = raycaster.intersectObjects(objs);
            if(intersects.length !== 0){
                var uv = intersects[0].uv;
                var tx = Math.min( Math.max(0, Math.min(uv.x, 1))* cover_tex.texData.width  | 0, cover_tex.texData.width - 1);
                var ty = Math.min( Math.max(0, Math.min((1 - uv.y), 1)) * cover_tex.texData.height | 0, cover_tex.texData.height - 1);
                var offset = (ty * cover_tex.texData.width + tx) * 4;
                var r = cover_tex.texData.data[offset + 0];
                var g = cover_tex.texData.data[offset + 1];
                var b = cover_tex.texData.data[offset + 2];
                if(g > 100 || b > 100){ // white or at least grey enough
                    stop = true;
                }
            }
            ++i;
        }

        return origin;
    };

    var pattern_p = pattern_resized.getAttribute('position');

    // Accuracy note :
    //  Instead of getting the closest border vertex, it would have been better to look for the intersection with the border (analytical)
    //  This is faster to implement and should be enough considering the needs and the mesh level of detail.
    var sole_dir = (new XTHREE.Vector3()).copy(adjusted_pts.meta1).add(adjusted_pts.meta5).multiplyScalar(0.5).sub(adjusted_pts.heel).normalize();
    var ort_sole_dir = (new XTHREE.Vector3()).crossVectors(new XTHREE.Vector3(0,0,1), sole_dir);
    // TODO : use DualBox Advanced Buffer Tri Geometry to limit the number of aabb computation.
    pattern_resized.computeBoundingBox();
    var aabb = pattern_resized.boundingBox;
    var borderHelper = new podo3d.PatternEdgesHelper(pattern_resized);
    var i_bot = borderHelper.getClosestBorderVertex(
        sole_dir.clone().multiplyScalar(-aabb.getSize(new XTHREE.Vector3()).y/2).add(heel_pos)
    );
    var bot = new XTHREE.Vector3(pattern_p.getX(i_bot),pattern_p.getY(i_bot),pattern_p.getZ(i_bot));
    var i_bot_1 = borderHelper.getClosestBorderVertex(
        ort_sole_dir.clone().multiplyScalar(-aabb.getSize(new XTHREE.Vector3()).y/2).add(heel_pos)
    );
    var bot_1 = new XTHREE.Vector3(pattern_p.getX(i_bot_1),pattern_p.getY(i_bot_1),pattern_p.getZ(i_bot_1));
    var i_bot_2 = borderHelper.getClosestBorderVertex(
        ort_sole_dir.clone().multiplyScalar(aabb.getSize(new XTHREE.Vector3()).y/2).add(heel_pos)
    );
    var bot_2 = new XTHREE.Vector3(pattern_p.getX(i_bot_2),pattern_p.getY(i_bot_2),pattern_p.getZ(i_bot_2));
    var i_up_1 = borderHelper.getClosestBorderVertex(
        contour_start
    );
    var up_1 = new XTHREE.Vector3(pattern_p.getX(i_up_1),pattern_p.getY(i_up_1),pattern_p.getZ(i_up_1));
    var i_up_2 = borderHelper.getClosestBorderVertex(
        contour_end
    );
    var up_2 = new XTHREE.Vector3(pattern_p.getX(i_up_2),pattern_p.getY(i_up_2),pattern_p.getZ(i_up_2));

    var vec = new XTHREE.Vector3();

    // Translate the uvplane geometry to position the heel reference point where needed.
    var x_off = vec.subVectors(heel_pos,bot).length();
    vec.copy(sole_dir).multiplyScalar(-x_off-heel_offset);
    uvplane_mesh.geometry.translate(vec.x,vec.y,vec.z);

    var gs = {};
    // For now create a 1cm pick
    var keys = ['bot','bot_1','bot_2','up_1','up_2'];
    for(var k=0; k<keys.length; ++k){
        gs[keys[k]] = new XTHREE.BufferLineGeometry();
    }
    gs.bot.addVertex({position:bot});
    vec.copy(walkTexture(bot, vec.copy(sole_dir).multiplyScalar(-1), 0.5, 40));
    vec.z = bot.z;
    gs.bot.addVertex({position:vec});

    gs.bot_1.addVertex({position:bot_1});
    vec.copy(walkTexture(bot_1, vec.copy(ort_sole_dir).multiplyScalar(-1), 0.5, 40));
    vec.z = bot_1.z;
    gs.bot_1.addVertex({position:vec});

    gs.bot_2.addVertex({position:bot_2});
    vec.copy(walkTexture(bot_2, vec.copy(ort_sole_dir), 0.5, 40));
    vec.z = bot_2.z;
    gs.bot_2.addVertex({position:vec});

    var orient_up = vec.subVectors(up_1,contour_start).normalize().dot(ort_sole_dir) > 0;
    var orient = orient_up ? 1 : -1;

    gs.up_1.addVertex({position:up_1});
    vec.copy(walkTexture(up_1, vec.copy(ort_sole_dir).multiplyScalar(orient), 0.5, 40));
    vec.z = up_1.z;
    gs.up_1.addVertex({position:vec});

    gs.up_2.addVertex({position:up_2});
    vec.copy(walkTexture(up_2, vec.copy(ort_sole_dir).multiplyScalar(-orient), 0.5, 40));
    vec.z = up_2.z;
    gs.up_2.addVertex({position:vec});

    // reset the cover uvplane translation
    // Should not be important, but just in case...
    // vec.copy(sole_dir).multiplyScalar(x_off+heel_offset);
    // uvplane_mesh.geometry.translate(vec.x,vec.y,vec.z);

    return [gs.bot,gs.bot_1,gs.bot_2,gs.up_1,gs.up_2];
};

// @param {XTHREE.BufferTriGeometry} Actually podo3d.buildCoverFrameLines[0] after projection on height map
// Note also that g_bot will be extended to hold the notch
podo3d.buildCoverFrameHeelNotch = function(g_bot, frame_radius){
    var p = g_bot.getAttribute("position");
    var dir = new XTHREE.Vector3(
        p.getX(1)-p.getX(0),
        p.getY(1)-p.getY(0),
        p.getZ(1)-p.getZ(0)
    );
    var l = dir.length();
    dir.normalize();

    var depth = 3+frame_radius;
    var width = 3;
    var height = 1.8;

    g_bot.setVertex(
        1,
        {
            position:new XTHREE.Vector3(p.getX(0),p.getY(0),p.getZ(0)).add(dir.clone().multiplyScalar(l+width))
        }
    );

    var box = (new XTHREE.BufferTriGeometry()).copy(
        new XTHREE.BoxBufferGeometry(
            width,
            height,
            depth
        )
    );
    box.removeAttribute("normal");
    box.removeAttribute("uv");
    // Optimization : since XTHREE (ie THREE js) creates an open mesh by default,
    //                this is the easiest and more general way to close it.
    box.mergeCloseVertices(box.computeEdgeLengthData().average/1000);

    var minusX = new XTHREE.Vector3(-1,0,0);
    var cross = (new XTHREE.Vector3()).crossVectors(minusX,dir);
    var sign = cross.dot(new XTHREE.Vector3(0,0,1)) >= 0 ? 1 :-1;
    var theta = sign*Math.asin(cross.length());
    theta += dir.dot(minusX) >= 0 ? 0 : Math.PI/2;

    var m = new XTHREE.Matrix4();
    m.makeRotationZ(theta);
    box.translate(width/2,0,depth/2);
    box.applyMatrix(m);
    box.translate(p.getX(1),p.getY(1),p.getZ(1));

    return box;
};

podo3d.computeHeightFromBorderLine = function(border, zones_geoms, zones){

    var l = border.clone();

    var crop_b = new XTHREE.Box3();
    for(var i=0; i<zones.length; ++i){
        crop_b.union(zones_geoms[zones[i]].geometry.boundingBox);
    }

    crop_b.min.z = -1000;
    crop_b.max.z = 1000;

    l.cropVertices(crop_b);

    l.computeBoundingBox();

    return l.boundingBox.max.z;
};

/**
 *
 *  @param {podo3d.RigiditiesManager} rigidities
 *  @param {DualBox.BufferTriGeometry} pattern The sole 2D pattern.
 *  @param {Object.<string,XTHREE.Mesh>} pattern_zones ==> podiatrySMFunc.podiatry.sole.meshes
 *  @param {XTHREE.BufferTriGeometry} pattern_contour The contour line as an array of vertices position, taken from db.contour.polyline.
 *  @param {Object.<string,{p:{x:number,y:number,z:number},vertices:Array.<number>}>} holes
 *  @param {{meta1;XTHREE.Vector3, meta5:XTHREE.Vector3, heel:XTHREE.Vector3}} sole_refpts Reference points for the sole in database
 *  @param {{meta1;XTHREE.Vector3, meta5:XTHREE.Vector3, heel:XTHREE.Vector3}} adjusted_pts
 *  @param {XTHREE.Geometry} foot_geometry The foot geometry, placed such that it is directed in y, heel reference at 0,0,0.
 *  @param {number} foot_size The foot size ==> podiatrySMFunc.podiatry.footsize
 *  @param {string} foot_side The foot side, as "left" or "right"
 *  @param {
        {
            productionId:{
                text:string,
                img_data:Object
            },
            thickness:number,
            patientInit:{
                text:string,
                img_data:Object,
            }
        }
    } sole_infos
 *  @param {{active:boolean,adjustData:Object}} antero
 */
podo3d.buildCompleteInsole = function(
                                        pattern_resized, // the pattern with holes resized according to rigidities.
                                        pattern_zones,
                                        recess_hole,
                                        pattern_contour,
                                        pattern_contour_cover,
                                        sole_refpts,
                                        adjusted_pts,
                                        foot_scan,
                                        foot_size,
                                        foot_width,
                                        foot_side,
                                        foot_positions,
                                        sole_infos,
                                        antero,
                                        arc_brc_elt,
                                        flat_heel,
                                        cover_frame,
                                        mat_ad)
{

    console.time("native buildCompleteInsole");
    //var foot_geometry = foot_scan.clone();
    //podo3d.setScanHeightAboveZero(foot_geometry, foot_positions);

    var foot_geometry = foot_scan;
    var pattern_resized = pattern_resized.clone();

    // assert
    if(pattern_resized.getAttribute('normal') === undefined){
        throw "Error : pattern normals should be defined";
    }

    // var holes_sizes = rigidities.getHolesSizes();
    // var pattern_resized = pattern.clone();
    // podo3d.resizeHoles(
        // pattern_resized,
        // holes,
        // holes_sizes
    // );

    pattern_resized.applyMatrix(mat_ad);

    var ad_sole_pos = {};
    var aspkeys = Object.keys(sole_refpts);
    for(var i=0; i<aspkeys.length; ++i){
        var k = aspkeys[i];
        ad_sole_pos[k] = sole_refpts[k].clone();
        ad_sole_pos[k].applyMatrix4(mat_ad);
    }

    // Note : do not use sole.meshes, they are not transformed !
    var zones_geoms = podo3d.buildSoleProjectionMeshes(
        pattern_zones,
        foot_side
    );
    var keys = Object.keys(zones_geoms);
    for(var i=0; i<keys.length; ++i){
        zones_geoms[keys[i]].geometry.applyMatrix(mat_ad);
        // next step should be useless, zones should be positioned at 0 in z....?
        zones_geoms[keys[i]].geometry.translate(0,0,-zones_geoms[keys[i]].position.z);
        zones_geoms[keys[i]].geometry.computeBoundingBox();
    }

    var flatheel_mesh = flat_heel;
    if(flat_heel){
        // build flat_heel geometry and transform it
        flatheel_mesh = flat_heel.clone();
        flatheel_mesh.applyMatrix(mat_ad);
        flatheel_mesh.computeBoundingBox();
    }

    var soleHMap = podo3d.buildSoleHeightMap(
        zones_geoms,
        foot_geometry,
        pattern_resized,
        podo3d.out_max_map,
        podo3d.in_max_map,
        foot_size,
        foot_side,
        flatheel_mesh
    );

    var soledir = (new XTHREE.Vector3()).subVectors(
        (new XTHREE.Vector3()).addVectors(
            ad_sole_pos.meta5,
            ad_sole_pos.meta1
        ).multiplyScalar(0.5),
        ad_sole_pos.heel
    ).normalize();

    var id_patch_mesh = null;
    var pdI = sole_infos.productionId;
    if(pdI && pdI.text.length !== 0 && pdI.text !== " "){
        var zone = sole_infos.productionId.zone.clone();
        zone.applyMatrix(mat_ad);
        var id_patch_mesh = podo3d.buildSoleIDPatch(
            pattern_resized,
            zones_geoms,
            soledir,
            soleHMap,
            foot_side,
            zone,
            sole_infos.productionId.text,
            sole_infos.productionId.img_data,
            sole_infos.thickness,
            sole_infos.productionId.letter_params,
            sole_infos.productionId.border_offset
        );
    }
    var init_patch_mesh = null;
    var ptI = sole_infos.patientInit;
    if(ptI !== undefined && ptI.text.length !== 0 && ptI.text !== " "){
        var zone = sole_infos.patientInit.zone.clone();
        zone.applyMatrix(mat_ad);
        init_patch_mesh = podo3d.buildSoleInitialPatch(
            pattern_resized,
            zones_geoms,
            soledir,
            soleHMap,
            zone,
            sole_infos.patientInit.text,
            sole_infos.patientInit.img_data,
            sole_infos.thickness,
            sole_infos.patientInit.letter_params,
            sole_infos.patientInit.border_offset
        );
    }

    // Build insole
    var insole_mesh = podo3d.buildInsole(
        soleHMap,
        pattern_resized,
        zones_geoms,
        sole_infos.thickness,
        sole_infos.frontThickness,
        recess_hole,
        sole_infos.recessThickness
    );
    // Save the aabb of the insole for smart screenshot
    insole_mesh.computeBoundingBox();
    var insole_aabb = insole_mesh.boundingBox;

    var final_meshes = [insole_mesh]; // having insole_mesh first here is important.
    if(id_patch_mesh !== null){ final_meshes.push(id_patch_mesh); }
    if(init_patch_mesh !== null){ final_meshes.push(init_patch_mesh); }

    ///////////////////////////////////////////////////////////////////////////
    // Build contour
    var contour = pattern_contour;
    contour.applyMatrix(mat_ad);
    var contour_start = new XTHREE.Vector3(
        contour.getAttribute('position').getX(0),
        contour.getAttribute('position').getY(0),
        contour.getAttribute('position').getZ(0)
    );
    var contour_end = new XTHREE.Vector3(
        contour.getAttribute('position').getX(contour.vertexCount()-1),
        contour.getAttribute('position').getY(contour.vertexCount()-1),
        contour.getAttribute('position').getZ(contour.vertexCount()-1)
    );
    contour.translate(0,0,soleHMap.getMinHeight()-5);

    contour.project([soleHMap], 60, new XTHREE.Vector3(0,0,1));
    podo3d.displaceContourFromHMap(contour, soleHMap, sole_infos.thickness);

    var g_contour = contour.makeTube({
        radialSegments:16,
        radius : 0.3
    });
    g_contour.computeVertexNormals();

    final_meshes.push(g_contour);
    // END Build contour //////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    // Build cover frame (5 little segments to know how to position the insole
    // cove once 3D printed). Same steps as for contour
    if(cover_frame !== null){
        var trans_uvplane = XTHREE.BufferTriGeometry.fromJSON(cover_frame.uvplane);
        trans_uvplane.applyMatrix(mat_ad);
        var frame_lines = podo3d.buildCoverFrameLines(
            pattern_resized,
            adjusted_pts,
            ad_sole_pos.heel,
            contour_start,
            contour_end,
            {
                uvplane:trans_uvplane,
                texData: ImageData.fromJSON(cover_frame.texData),
                texDataURL:cover_frame.texDataURL
            },
            sole_infos.thickness
        );
        for(var i=0; i<frame_lines.length; ++i){
            frame_lines[i].translate(0,0,soleHMap.getMinHeight()-0.0001);
            frame_lines[i].project([soleHMap], 60, new XTHREE.Vector3(0,0,1));
            frame_lines[i].getAttribute('position').setZ(1, frame_lines[i].getAttribute('position').getZ(0));
            podo3d.displaceContourFromHMap(frame_lines[i], soleHMap, sole_infos.thickness/2);
            var frame_radius = 1;
            if(i===0){ // build the corrsponding notch
                var notch = podo3d.buildCoverFrameHeelNotch(frame_lines[i], frame_radius);
                notch.computeVertexNormals();
                final_meshes.push(notch);
            }
            frame_lines[i] = frame_lines[i].makeTube({
                radialSegments:8,
                radius : frame_radius
            });
            frame_lines[i].computeVertexNormals();
            final_meshes.push(frame_lines[i]);
        }
    }
    ///////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    // Build contour cover
    var contour_cover = pattern_contour_cover.clone();
    contour_cover.applyMatrix(mat_ad);

    contour_cover.translate(0,0,soleHMap.getMinHeight()-10); // apply an epsilon just in case.
    contour_cover.project([soleHMap], 60, new XTHREE.Vector3(0,0,1));
    contour_cover.computeVertexNormals();

    // Extrude to have a 3D patch.
    contour_cover.displaceAlongNormals(-sole_infos.thickness);
    contour_cover.extrude(1, null, {patch:true, round:false} );
    final_meshes.push(contour_cover);
    // END Build contour cover ////////////////////////////////////////////////

    if(antero !== null){
        // build antero
        antero.applyMatrix(mat_ad);
        var antero_mesh = podo3d.buildFinalAntero(
            soleHMap,
            antero,
            sole_infos.thickness,
            sole_infos.frontThickness // front
        );
        final_meshes.push(antero_mesh);
    }

    // Apply BRC on the result, if active
    if(arc_brc_elt !== null){
        arc_brc_elt.applyMatrix(mat_ad);
        arc_brc_elt.computeBoundingBox();

        podo3d.applyARC_BRC(insole_mesh, arc_brc_elt);
        podo3d.applyARC_BRC(contour_cover, arc_brc_elt);
        podo3d.applyARC_BRC(g_contour, arc_brc_elt);
    }

    // Merge the insole with all other elements.
    insole_mesh = XTHREE.BufferTriGeometry.merge(final_meshes);

    // Important note : this call will get border indices of the original pattern
    // and rely on the fact that those indices do not change in any of the previous
    // calls. Not when extruding, not when merging.
    // If extruding, merging, or any other mesh transform do not conserve indices,
    // this will be broken.
    var border_tube = new XTHREE.BufferLineGeometry();
    var border = podo3d.getPatternBorderVertices(pattern_resized);
    var attr = {
        position: new XTHREE.Vector3()
    };
    var insole_p = insole_mesh.getAttribute('position');
    for(var i=0; i<border.length; i+=4){
        var idx = border[i];
        attr.position.set(
            insole_p.getX(idx),
            insole_p.getY(idx),
            insole_p.getZ(idx)
        );
        border_tube.addVertex(attr);
    }
    var tube_g = border_tube.makeTube({radialSegments:8, radius:sole_infos.thickness/4, caps:"flat"});
    tube_g.translate(0,0,-sole_infos.thickness/2);

    var heel_height = podo3d.computeHeightFromBorderLine(border_tube, zones_geoms, ["CenterB","A","G"]);
    var arch_ext_height = podo3d.computeHeightFromBorderLine(border_tube, zones_geoms, ["Fx","Fy"]);

    console.timeEnd("native buildCompleteInsole");

    return {
        result : insole_mesh,
        border : tube_g,
        heelHeight : heel_height,
        archextHeight : arch_ext_height,
        hmap: soleHMap
    };

};

// In the pattern lib, the contour polyline is stored
// as a quad mesh with useless vertices at z>0
podo3d.buildContourPolylineFromPatternMesh = function(mesh){

    var faces = mesh.getIndex().array;
    var position = mesh.getAttribute('position');

    var quad = [0,0,0,0];
    var edge = [0,0];
    var edges = {};
    if(2*Math.floor(mesh.faceCount()/2) !== mesh.faceCount()){
        throw "Error : Contour faces should be built from quad faces, number of faces must be even.";
    }
    for(var i=0; i<mesh.faceCount(); i+=2){

        var vi = {};
        for(var k=0; k<6; ++k){
            vi[faces[3*i+k]] = faces[3*i+k];
        }
        var keys = Object.keys(vi);
        if(keys.length !== 4){
            throw "Error : 2 consecutive triangles should be 4 vertices";
        }
        quad[0] = vi[keys[0]];
        quad[1] = vi[keys[1]];
        quad[2] = vi[keys[2]];
        quad[3] = vi[keys[3]];
        var e = 0;
        for(var k=0; k<4; ++k){
            if(position.getZ(quad[k]) === 0){
                if(e>1){
                    throw "Error : contour line is expected to have only 2 vertices at z = 0 in each quad face";
                }
                edge[e] = quad[k];
                e++;
            }
        }
        //console.log("final e : "+ e);
        if(e !== 2){
            throw "Error : should be at least one contour edge per quad face." + "Concerned face : " + i;
        }
        if(edges[edge[0]] === undefined){
            edges[edge[0]] = [];
        }
        if(edges[edge[1]] === undefined){
            edges[edge[1]] = [];
        }
        edges[edge[0]].push(edge[1]);
        edges[edge[1]].push(edge[0]);
    }
    // find a starting point on the contour.
    // If the contour is not closed, we take a point connected to only one edge,
    // else we take any point
    var curr = 0;
    var keys = Object.keys(edges);
    for(var i=0; i<keys.length; ++i){
        if(edges[keys[i]].length === 1){
            curr = keys[i];
            next = edges[keys[i]][0];
            break;
        }
    }

    var contour = [
        position.getX(curr),
        position.getY(curr),
        position.getZ(curr)
    ];

    while(next !== -1){
        contour.push(
            position.getX(next),
            position.getY(next),
            position.getZ(next)
        );
        var e = edges[next];
        var swap = next;
        var next = e.length === 1 ? -1 :
                    (e[0] !== curr ? e[0] : e[1]);
        curr = swap;
    }

    return contour;
};

/**
 *  This function parses an OBJ containing the insoles zones and reference points.
 *  Then return a JSON object to be saved in DB.
 *
 *  @param {string} obj_s The OBJ file as a string. Each zone mesh is separated
 *                        by a "g XXX" line where XXX is PD_Zones_Centrale_H,
 *                        PD_Zones_Centrale_B, PD_Zones_A, PD_Zones_B,
 *                        PD_Zones_C, PD_Zones_D, PD_Zones_E, PD_Zones_F,
 *                        PD_Zones_G, PD_3PTs_ref, PG_3PTs_ref
 *  @param {warn} boolean Activate WARN logs
 *  @return {Object} Object containing each mesh as raw arrays.
 */
 podo3d.InsolePatternImporter = function(obj_s, warn){
    // Build a key map to be a little compliant with the entry
    var keys_map = {
        "zones_centrale_h"      : "CenterH",
        "zones_centrale_b"      : "CenterB",
        "zones_a"               : "A",
        "zones_b"               : "B",
        "zones_bx"              : "Bx",
        "zones_by"              : "By",
        "zones_bz"              : "Bz",
        "zones_c"               : "C",
        "zones_d"               : "D",
        "zones_dx"              : "Dx",
        "zones_dy"              : "Dy",
        "zones_dz"              : "Dz",
        "zones_e"               : "E",
        "zones_f"               : "F",
        "zones_fx"              : "Fx",
        "zones_fy"              : "Fy",
        "zones_fz"              : "Fz",
        "zones_g"               : "G",
        "3pts_ref"              : "refpts",
        "pts_ref"               : "refpts",
        "perforation"           : "pattern",
        "perforations"          : "pattern",
        // Trous
        "centres_des_trous_zone_centrale_h":"center_holes_CenterH",
        "centres_des_trous_zone_centrale_b":"center_holes_CenterB",
        "centres_des_trous_zone_cb" :   "center_holes_CenterB",
        "centres_des_trous_zone_ch" :   "center_holes_CenterH",
        "centres_des_trous_zone_g"  :   "center_holes_G",
        "centres_des_trous_zone_f"  :   "center_holes_F",
        "centres_des_trous_zone_fx" :   "center_holes_Fx",
        "centres_des_trous_zone_fy" :   "center_holes_Fy",
        "centres_des_trous_zone_fz" :   "center_holes_Fz",
        "centres_des_trous_zone_e"  :   "center_holes_E",
        "centres_des_trous_zone_d"  :   "center_holes_D",
        "centres_des_trous_zone_dx" :   "center_holes_Dx",
        "centres_des_trous_zone_dy" :   "center_holes_Dy",
        "centres_des_trous_zone_dz" :   "center_holes_Dz",
        "centres_des_trous_zone_c"  :   "center_holes_C",
        "centres_des_trous_zone_b"  :   "center_holes_B",
        "centres_des_trous_zone_bx" :   "center_holes_Bx",
        "centres_des_trous_zone_by" :   "center_holes_By",
        "centres_des_trous_zone_bz" :   "center_holes_Bz",
        "centres_des_trous_zone_a"  :   "center_holes_A",
        // Elements de construction
        "tangences_avant_pied":         "antero",
        "contour_mesh": "contour",
        "initiales": "txt_initiales",
        "identifiant": "txt_production_id",
        "recouvrement_mesh": "cover_contour"
    };

    var parsedSole = podo3d.InsoleZonesOBJParser(obj_s);

    var res = {
        zones : {},
        pattern : null,
        refpts : {},
        holes : {},
        recess:{
            hole:null
        },
        contour:{
            polyline:null,
            cover:null
        },
        txtzones : {

        }
    };

    // keep the pattern geometry as a BufferTriGeometry for later use.
    var pattern_geom = null;

    // used later for centers, should contain the pattern halfedges
    var hedges = null;
    var vstart = 0; //

    var keys = Object.keys(parsedSole);
    for(var i=0; i<keys.length; ++i){
        var k = keys[i].toLowerCase();
        if(k.substring(0,3) === "pg_"){
            k = k.substring(3,k.length);
        }
        k = keys_map[k];
        if(k !== undefined){
            var mesh = new XTHREE.BufferTriGeometry();
            mesh.setVerticesNumber(parsedSole[keys[i]].vertices.length/3);
            mesh.setFacesNumber(parsedSole[keys[i]].faces.length/3);
            mesh.setVertexAttribute('position', parsedSole[keys[i]].vertices);
            mesh.setFaces(parsedSole[keys[i]].faces);

            // Sometimes exports are close to 0 but not 0,
            // this ensure we are at 0 and help improve the storage cost.
            podo3d.setZVerticesCoordTo0(mesh, 0.0001);

            var position = mesh.getAttribute('position');

            if(k === "refpts"){
                var p = [null,null,null];
                p[0] = new XTHREE.Vector3(position.getX(0),position.getY(0), position.getZ(0));
                p[1] = new XTHREE.Vector3(position.getX(1),position.getY(1), position.getZ(1));
                p[2] = new XTHREE.Vector3(position.getX(2),position.getY(2), position.getZ(2));
                res.refpts = podo3d.detectReferencePoints(p[0], p[1], p[2], "left", new XTHREE.Vector3(0,0,1));
                Object.keys(res.refpts).forEach(function(key,i){
                    res.refpts[key] = res.refpts[key].toJSON();
                });
            }else if(k==="pattern"){
                hedges = mesh.getSingularEdgesAsObject();
                vstart = 0;
                var vx_start = position.getX(0);
                for(var vi=0; vi<mesh.vertexCount(); ++vi){
                    if(vx_start>position.getX(vi)){
                        vstart = vi;
                        vx_start = position.getX(vi);
                    }
                }
                podo3d.roundVerticesCoordinates(mesh,3);
                mesh.removeAttribute('normal');
                res.pattern = mesh.toJSON();
                pattern_geom = mesh;
            }else if(k.indexOf("center_holes") !== -1){
                var centers = [];
                for(var ih=0; ih<mesh.vertexCount(); ++ih){
                    centers.push({
                        p:{x:position.getX(ih), y:position.getY(ih),z:position.getZ(ih)},
                        vertices:{}
                    });
                }
                res.holes[k.substring(13,k.length)] = centers;
            }else if(k==="antero"){
                res.antero = {
                    // interior tangent
                    intan: [
                        new XTHREE.Vector3(position.getX(1), position.getY(1), position.getZ(1)).toJSON(),
                        new XTHREE.Vector3(position.getX(0), position.getY(0), position.getZ(0)).toJSON()
                    ],
                    // exterior tangent
                    extan: [
                        new XTHREE.Vector3(position.getX(2), position.getY(2), position.getZ(2)).toJSON(),
                        new XTHREE.Vector3(position.getX(3), position.getY(3), position.getZ(3)).toJSON()
                    ]
                };
            }else if(k==="contour"){
                res.contour.polyline = podo3d.buildContourPolylineFromPatternMesh(mesh);
            }else if(k==="cover_contour"){
                podo3d.roundVerticesCoordinates(mesh,3);
                mesh.removeAttribute('normal');
                res.contour.cover = mesh.toJSON();
            }else if(k==="txt_initiales" || k==="txt_production_id"){
                podo3d.roundVerticesCoordinates(mesh,3);
                mesh.removeAttribute('normal');
                res.txtzones[k]= mesh.toJSON();
            }else{
                podo3d.roundVerticesCoordinates(mesh,3);
                mesh.removeAttribute('normal');
                res.zones[k] = mesh.toJSON(); // Limited acuracy to 10-3 mm
            }
        }else{
            if( warn ) {
                console.warn("Unknown key " + keys[i] + " in sole mesh.");
            }
        }
    }

    var expected_n_hz = 14;
    if(Object.keys(res.holes).length ===0){
        console.log("Warning : this file has no holes zones...");
    }else if(Object.keys(res.holes).length <expected_n_hz){
        console.log("Warning : this file has only " + Object.keys(res.holes).length + " holes zones, expected "+expected_n_hz);
    }

    // Process centers to get all the vertices corresponding to each hole
    // Assumption : each border vertex is linked to only 1 center, which is the nearest
    // First of all, clean hedges from the contour hedges
    var curr = vstart;
    while(curr !== -1){
        if(hedges[curr] === undefined){
            curr = -1;
        }else{
            var old_curr = curr;
            curr = hedges[curr][1];
            delete hedges[old_curr];
        }
    }

    // Each vertex is the start of an edge, so just process the start of all edges
    var pattern_p = pattern_geom.getAttribute('position');
    var tmp_vec = new XTHREE.Vector3();
    var d_computer = new XTHREE.Vector3();
    var keys = Object.keys(hedges);
    for(var i=0; i<keys.length; ++i){
        var vi = hedges[keys[i]][0];
        tmp_vec.set(
            pattern_p.getX(vi),
            pattern_p.getY(vi),
            pattern_p.getZ(vi)
        );
        var dist = Number.MAX_VALUE;
        var ck = Object.keys(res.holes);
        if(ck.length !== 0){
            var nearest_z = ck[0];
            var nearest_i = 0;
            for(var k=0; k<ck.length;++k){
                var zctrs = res.holes[ck[k]];
                for(var ci = 0; ci<zctrs.length;++ci){
                    d_computer.set(zctrs[ci].p.x,zctrs[ci].p.y,zctrs[ci].p.z);
                    d_computer.sub(tmp_vec);
                    if(d_computer.length() < dist){
                        nearest_z = ck[k];
                        nearest_i = ci;
                        dist = d_computer.length();
                    }
                }
            }
            res.holes[nearest_z][nearest_i].vertices[vi] = vi;
        }
    }

    // For all holes, we re-order in the edges orders.
    // This will give the possibility to iterate on the hole edges later
    // Also, at the same time we will remove edges which could come from other
    // holes (like the heel main hole)

    // We suppose the only hole which is not marked by a center in the insole is the heel hole.
    var recess_hole = {};
    var hkeys = Object.keys(res.holes);
    for(var i=0; i<hkeys.length; ++i){
        var zone = hkeys[i];
        var zone_holes = res.holes[zone];
        for(var j=0; j<zone_holes.length; ++j){
            var hole = zone_holes[j];
            // Yes, holes can be empty in some strange cases where we were given
            // a center out of the mesh.
            if(Object.keys(hole.vertices).length !== 0){
                var hv_keys = Object.keys(hole.vertices);
                var first = hole.vertices[hv_keys[0]];
                var new_vertices = [first];
                var next = hedges[first][1];
                var safe = 0;
                var safe_limit = 10*hv_keys.length;
                while(next !== first && safe<=safe_limit){
                    if(hole.vertices[next] === undefined){
                        // The current vertex does, and all its chain, do not belong
                        // to the hole for this center, remove and discard them
                        for(var vi=0; vi<new_vertices.length; ++vi){
                            var discarded = new_vertices[vi];
                            recess_hole[discarded] = discarded;
                            delete hole.vertices[new_vertices[vi]];
                        }
                        hv_keys = Object.keys(hole.vertices);
                        if(hv_keys.length !== 0){
                            first = hole.vertices[hv_keys[0]];
                            new_vertices = [first];
                            next = hedges[first][1];
                        }else{
                            next = first;
                        }
                    }else{
                        new_vertices.push(next);
                        delete hole.vertices[next]; // it's processed, remove it from the set to process.
                        next = hedges[next][1];
                    }
                    safe++;
                }
                if(safe>=safe_limit){
                    console.error("Safety break in while loop InsolePatternImporter");
                }
                delete hole.vertices[next];

                // All remaining vertices must belong to the recess hole
                Object.keys(hole.vertices).forEach(
                    function(vertex) {
                        recess_hole[vertex] = hole.vertices[vertex];
                    }
                );

                hole.vertices = new_vertices;

            }else{
                hole.vertices = [];
            }
        }
    }

    // Process heel hole to get it good
    var hkeys = Object.keys(recess_hole);
    var recess_vertices = [];
    if(hkeys.length !== 0){
        var first = recess_hole[hkeys[0]];
        recess_vertices.push(first);
        var next = hedges[first][1];
        var safe = 0;
        var safe_limit = 10*hkeys.length;
        while(next !== first && safe<=safe_limit){
            if(recess_hole[next] === undefined){
                throw "Error : something's wrong with the heel hole, some vertices belonging to it are connected to other edges vertices.";
            }else{
                recess_vertices.push(next);
                next = hedges[next][1];
            }
            safe++;
        }
        if(safe !== hkeys.length-1){
            throw "Error : something's wrong with the heel hole, it has been closed without using all vertices supposed to belong to it.";
        }
        res.recess.hole = recess_vertices;
    }

    return res;
};

/**
 *  Important note : the dbSolePattern IS NOT replicated. It is MODIFIED.
 *  @param {Object} dbSolePattern The JSON file saved in DB, basically the result from InsolePatternImporter.
 *  @return {Object} The reversed object (mean if it was a left insole, it is now a right insole, and vice versa)
 */
 podo3d.inverseFootSide = function(dbSolePattern){
    // Assumption :
    //  - Insole are in z = 0

    // Check to output warning in case something strange, like we plan to reverse less fields that dbSolePattern has
    if(dbSolePattern.zones === undefined || dbSolePattern.pattern === undefined || dbSolePattern.refpts == undefined){
        console.warn("WARNING : zones, pattern and refpts should be defined");
    }else{
        if(Object.keys(dbSolePattern).length > 4){
            console.warn("WARNING : dbSolePattern seems to contains data that this function does not reverse");
        }
    }

    // An easy way of reversing is to switch the y values to -y
    // Faces must be reversed to have there normals set to Z direction (direct oriented)

    var reverseFacesAndVertices = function(json_mesh){
        var mesh = new XTHREE.BufferTriGeometry();
        mesh.fromJSON(json_mesh);

        var indices = mesh.getIndex().array;

        var nfaces = mesh.faceCount();
        for(var i=0; i<nfaces; ++i){
            var s = indices[3*i+1];
            indices[3*i+1] = indices[3*i+2];
            indices[3*i+2] = s;
        }

        var position = mesh.getAttribute('position');

        var attr = {
            position : new XTHREE.Vector3()
        };

        var nvertices = mesh.vertexCount();
        for(var i=0; i<nvertices; ++i){
            attr.position.set(
                position.getX(i),
                -position.getY(i),
                position.getZ(i)
            );
            mesh.setVertex(i, attr);
        }

        return mesh.toJSON();
    };

    var keys = Object.keys(dbSolePattern.zones);
    for(var i=0; i<keys.length; ++i){
        dbSolePattern.zones[keys[i]] = reverseFacesAndVertices(dbSolePattern.zones[keys[i]]);
        // No use to reverse normals, they should not be there.
    }
    dbSolePattern.pattern = reverseFacesAndVertices(dbSolePattern.pattern);
    keys = Object.keys(dbSolePattern.txtzones);
    for(var i=0; i<keys.length; ++i){
        dbSolePattern.txtzones[keys[i]] = reverseFacesAndVertices(dbSolePattern.txtzones[keys[i]]);
        // No use to reverse normals, they should not be there.
    }
    var pl = dbSolePattern.contour.polyline;
    for(var i=1; i<pl.length; i+=3){
        pl[i] = -pl[i];
    }
    dbSolePattern.contour.cover = reverseFacesAndVertices(dbSolePattern.contour.cover);

    var tmp = new XTHREE.Vector3();
    Object.keys(dbSolePattern.refpts).forEach(function(key,i){
        var tmp = new XTHREE.Vector3();
        tmp.fromJSON(dbSolePattern.refpts[key]);
        tmp.y = -tmp.y;
        dbSolePattern.refpts[key] = tmp.toJSON();
    });

    for(var i=0; i<2; ++i){
        tmp.fromJSON(dbSolePattern.antero.intan[i]);
        tmp.y = -tmp.y;
        dbSolePattern.antero.intan[i] = tmp.toJSON();
        tmp.fromJSON(dbSolePattern.antero.extan[i]);
        tmp.y = -tmp.y;
        dbSolePattern.antero.extan[i] = tmp.toJSON();
    }

    // inverse holes centers
    var hkeys = Object.keys(dbSolePattern.holes);
    for(var i=0; i<hkeys.length; ++i){
        var arr = dbSolePattern.holes[hkeys[i]];
        for(var k=0; k<arr.length; ++k){
            arr[k].p.y = -arr[k].p.y;
        }
    }

    return dbSolePattern;
};

/**
 *  @param {XTHREE.BufferTriGeometry} mesh
 */
podo3d.setZVerticesCoordTo0 = function(mesh, tolerance){

    var attr = {
        position : new XTHREE.Vector3()
    };

    var p = mesh.getAttribute('position');

    for(var i=0; i<mesh.vertexCount(); ++i){
        if(Math.abs(p.getZ(i))<tolerance){
            attr.position.set(
                p.getX(i),
                p.getY(i),
                0
            );
            mesh.setVertex(i, attr);
        }
    }
    return mesh;
};

/**
 *  Limit accuracy to reduce storage size.
 */
podo3d.roundVerticesCoordinates = function(mesh, n){

    var attr = {
        position : new XTHREE.Vector3()
    };

    var mult = Math.pow(10,n);

    var p = mesh.getAttribute('position');

    for(var i=0; i<mesh.vertexCount(); ++i){
        attr.position.set(
            Math.round(p.getX(i)*mult)/mult,
            Math.round(p.getY(i)*mult)/mult,
            Math.round(p.getZ(i)*mult)/mult
        );
        mesh.setVertex(i, attr);
    }
    return mesh;
};

/**
 *  This function parses an OBJ containing the insoles zones and reference points.
 *
    @param {string} obj_s The OBJ file as a string. Each zone mesh is separated
 *                        by a "g XXX" line where XXX is PD_Zones_Centrale_H,
 *                        PD_Zones_Centrale_B, PD_Zones_A, PD_Zones_B,
 *                        PD_Zones_C, PD_Zones_D, PD_Zones_E, PD_Zones_F,
 *                        PD_Zones_G, PD_3PTs_ref, PG_3PTs_ref
 *  @return {Object} Object containing each mesh as raw arrays.
 */
podo3d.InsoleZonesOBJParser = function(obj_s){

    var v = [];
    var f = [];
    var vn = [];
    var vt = [];
    var fn = [];
    var ft = [];

    // Delimit for each "g" marker the indices of faces and vertices
    var delimiters = {};
    var curr_g = null;
    var curve = null;

    var test = 0;

    var lines = obj_s.split(/[\r\n]+/g); // tolerate both Windows and Unix linebreaks
    for(var l = 0; l < lines.length; l++) {

        var line = lines[l];

        // if line ends with a backslash, add next line too
        while( line[line.length-1] == '\\' ) {
            l++;
            line = line.slice(0, -1) + lines[l];
            line = line.replace(/\s\s+/g, ' ');
        }

        if(line.length !== 0 && line.charAt(0) !== "#") {
            var toks = line.split(" ");
            switch(toks[0]) {
                case "v":
                  if(toks.length < 3) {
                    throw new Error("parse-obj: Invalid vertex :" + line);
                  }
                  v.push(parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]));
                break;

                case "vn":
                  // vertex normals are useless for now
                  //if(toks.length < 3) {
                  //  throw new Error("parse-obj: Invalid vertex normal:"+ line);
                  //}
                  //vn.push(parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]));
                break;

                case "vt":
                  // vertex texture are useless for now
                  //if(toks.length < 2) {
                  //  throw new Error("parse-obj: Invalid vertex texture coord:" + line);
                  //}
                  //vt.push(parseFloat(toks[1]), parseFloat(toks[2]));
                break;

                case "f":
                  var position = new Array(toks.length-1);
                  // Normals and texCoord useless for now
                  //var normal = new Array(toks.length-1);
                  //var texCoord = new Array(toks.length-1);
                  for(var i=1; i<toks.length; ++i) {
                    var indices = toks[i].split("/");
                    position[i-1] = (parseInt(indices[0],10)|0)-1;
                    //texCoord[i-1] = indices[1] ? Math.floor(parseFloat(indices[1]))-1 : -1;
                    //normal[i-1] = indices[2] ? Math.floor(parseFloat(indices[2]))-1 : -1;
                  }
                  if(position.length === 3){
                    f.push(position[0],position[1],position[2]);
                    //fn.push(normal[0],normal[1],normal[2]);
                    //ft.push(texCoord[0], texCoord[2], texCoord[2] );
                  }else if(position.length === 4){
                    f.push(position[0],position[1],position[2]);
                    f.push(position[0],position[2],position[3]);
                    //fn.push(normal[0],normal[1],normal[2]);
                    //fn.push(normal[0],normal[2],normal[3]);
                    //ft.push(texCoord[0], texCoord[1], texCoord[2] );
                    //ft.push(texCoord[0], texCoord[2], texCoord[3] );
                  }else{
                    console.error("Cannot handle Faces with " + position.length + "vertices");
                  }
                break;
                case "o":
                case "g":
                    var data = {
                        v:{first:v.length/3, last:v.length/3},
                        f:{first:f.length/3, last:f.length/3}
                    };
                    if(delimiters[toks[1]] === undefined){
                        delimiters[toks[1]] = [data];
                    }else{
                        delimiters[toks[1]].push(data)
                    }
                    if(curr_g !== null){
                        var del_curr = delimiters[curr_g];
                        del_curr[del_curr.length-1].v.last = v.length/3;
                        del_curr[del_curr.length-1].f.last = f.length/3;
                        if(curve !== null){
                            del_curr[del_curr.length-1].curve = curve;
                            curve = null;
                        }
                    }
                    curr_g = toks[1];
                break;
                // Curve and surfaces parameters
                // ti be handled later
                case "trim":
                case "parm":
                case "curv":
                case "curv2":
                case "end":
                case "surf":
                case "cstype":
                case "deg":
                    // set curve so that we knew we are currently parsing curve param.
                    curve = {};
                break;
                case "vp":
                case "s":
                case "usemtl":
                case "mtllib":
                  //Ignore this crap
                break;

                default:
                    console.warn("line " + l + " not parsed correctly: $" + line + "^");
                    console.warn("Warning : parse-obj: Unrecognized directive: '" + toks[0] + "'");
                    return;
                break;
            }
        }
    }
    if(curr_g !== null){
        var currdel = delimiters[curr_g];
        currdel[currdel.length-1].v.last = v.length/3;
        currdel[currdel.length-1].f.last = f.length/3;
        if(curve !== null){
            currdel[currdel.length-1].curve = curve;
        }
    }

    var zones = {};
    var keys = Object.keys(delimiters);
    for(var i=0;i<keys.length; ++i){
        var delarr = delimiters[keys[i]];
        for(var j=0; j<delarr.length; ++j){
            zones[keys[i]] = zones[keys[i]] === undefined ? {} : zones[keys[i]];

            var zone = delarr[j];
            var vertices = [];
            var faces = [];

            var vmatch = {};
            for(var k=zone.v.first; k<zone.v.last; ++k){
                vertices.push(v[3*k]);
                vertices.push(v[3*k+1]);
                vertices.push(v[3*k+2]);
                vmatch[k] = k-zone.v.first;
            }
            for(var k=zone.f.first; k<zone.f.last; ++k){
                faces.push(vmatch[f[3*k]]);
                faces.push(vmatch[f[3*k+1]]);
                faces.push(vmatch[f[3*k+2]]);
            }
            if(zone.curve === undefined){
                if(zones[keys[i]].vertices !== undefined){
                    console.error("Error : this parser will not handle 2 meshes with the same identifier."
                    + "Same identifier are allowed only for objects represented in different forms : nurbs, mesh, etc... "
                    + "Zone concerned : " + keys[i]);
                }
                zones[keys[i]].vertices = vertices;
                zones[keys[i]].faces = faces;
            }else{
                if(zones[keys[i]].curve !== undefined){
                    console.error("Error : this parser will not handle 2 curves with the same identifier. Same identifier are allowed only for objects represented in different forms : nurbs, mesh, etc...");
                }
                // Do nothing for now, do not get curve params.
                delete zones[keys[i]];
                //zones[keys[i]].curve = zone.curve;
            }
        }
    }

    return zones;
};

/**
 *  Sort p1, p2 and p3 in {heel,meta1,meta5}.
 *  p1, p2 and p3 must be given in z fixed, positive z being the foot->knee
 *  direction, and negative z going under the foot
 *  @param {XTHREE.Vector3} p0
 *  @param {XTHREE.Vector3} p1
 *  @param {XTHREE.Vector3} p2
 *  @param {string} foot Must be "left" or "right"
 *  @param {XTHREE.Vector3} up The up dir, front the foot to the knee
 */
podo3d.detectReferencePoints = function(p0,p1,p2,foot,up){

    if(foot !== "left" && foot !== "right"){
        console.error("Unknown foot value : " + foot);
    }

    // Just safety
    up.normalize();

    var vec1 = new XTHREE.Vector3();
    var vec2 = new XTHREE.Vector3();
    var cross = new XTHREE.Vector3();

    var res = {
        heel : null,
        meta5 : null,
        meta1 : null
    };

    // Find heel : take the point that is farthest from the 2 others
    var avg_dist = [0,0,0];
    avg_dist[0] = 0.5*(vec1.subVectors(p0,p1).length() + vec2.subVectors(p0,p2).length());
    avg_dist[1] = 0.5*(vec1.subVectors(p1,p0).length() + vec2.subVectors(p1,p2).length());
    avg_dist[2] = 0.5*(vec1.subVectors(p2,p0).length() + vec2.subVectors(p2,p1).length());

    var rest = null;
    if(avg_dist[0] > avg_dist[1]){
        if(avg_dist[0] > avg_dist[2]){
            res.heel = p0;
            rest = [p1,p2];
        }else{
            res.heel = p2;
            rest = [p0,p1];
        }
    }else{
        if(avg_dist[1] > avg_dist[2]){
            res.heel = p1;
            rest = [p0,p2];
        }else{
            res.heel = p2;
            rest = [p0,p1];
        }
    }

    // Now find meta1 and meta5 depending on orientation.
    var mid = (new XTHREE.Vector3()).addVectors(rest[0], rest[1]).multiplyScalar(0.5);
    vec1.subVectors(mid, res.heel);

    // Process the left foot case
    vec2.subVectors(rest[0],res.heel);
    cross.crossVectors(vec2, vec1);
    if(cross.dot(up)>0){
        res.meta1 = rest[0];
        res.meta5 = rest[1];
    }else{
        res.meta1 = rest[1];
        res.meta5 = rest[0];
    }

    if(foot === "right"){
        var tmp = res.meta1;
        res.meta1 = res.meta5;
        res.meta5 = tmp;
    }

    return res;
};


module.exports = podo3d;




