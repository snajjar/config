class Zoomer {
    constructor(parent, container, canvas) {
        this.parent = parent;
        this.container = container;
        this.canvas = canvas;
        this.currentZoom = 1;
        this.previousZoom = this.currentZoom;

        this.canvasWidth = this.canvas.width();
        this.canvasHeight = this.canvas.height();

        this.transform = null;

        this.currentlyZooming = false;
        this.nextZoom = false;
    }

    initialize() {
        this.container.off('mousewheel');
        this.container.on('mousewheel', (e) => {
            // normalize wheel to +1 or -1
            if(e.originalEvent.wheelDelta / 120 > 0) {
                this.zoomIn(e);
            }
            else{
                this.zoomOut(e);
            }
        });
    }

    getZoom() {
        return this.currentZoom;
    }

    saveState() {
        var el = this.parent.jsPlumbInstance.getContainer();
        return {
            "currentZoom" : this.currentZoom,
            "offset"      : this.canvas.offset(),
            "transform"   : el.style["transform"],
            "transition"  : el.style["transition"],
            "transformOrigin" : el.style["transform-origin"],
        }
    }

    restoreState( savedZoom ) {
        this.currentZoom = savedZoom.currentZoom;
        var el = this.parent.jsPlumbInstance.getContainer();
        $(el).one("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd", () => {
            $(this.canvas).offset(savedZoom.offset);
            this.parent.jsPlumbInstance.setZoom(this.currentZoom);
            this.parent.jsPlumbInstance.repaintEverything();
        });
        el.style["transition"] = savedZoom.transition;
        el.style["transform"] = savedZoom.transform;
        el.style["transform-origin"] = savedZoom.transformOrigin;
    }

    // zoom in or out
    // - zoom: value between 0 and 1
    // - e: if e is defined, we make sure the mouse stays on the same point
    setZoom(zoom, e) {
        this.currentlyZooming = true;

        var el = this.parent.jsPlumbInstance.getContainer();

        // set the scale
        var s = "scale(" + zoom + ")";

        var elOffset = this.canvas.offset();

        // set the transform origin
        if( e ) {
            /*
            // NODE: this works exactly like 50% 50%
            // compute current distance from the center of the canvas
            var canvasCenterX = this.canvas.width()/ 2;
            var canvasCenterY = this.canvas.height()/ 2;
            var oString = canvasCenterX + "px " + canvasCenterY + "px";
            */

            // find our current mouse position on this canvas
            var mouseX = (e.pageX - this.canvas.offset().left) / (this.canvas.width() * this.currentZoom);
            var mouseY = (e.pageY - this.canvas.offset().top) / (this.canvas.height() * this.currentZoom);

            var oString = (mouseX*100) + "% " + (mouseY*100) + "%";
        }
        else {
            var oString = "50% 50%";
        }

        return new Promise( (resolve) => {
            if( this.currentZoom == zoom ) {
                this.currentlyZooming = false;
                resolve();
            }
            else {
                $(el).one("transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd", () => {
                    this.parent.jsPlumbInstance.setZoom(this.currentZoom, true);
                    this.currentlyZooming = false;
                    $(el).ready(resolve);
                });

                // before we apply the transformation, remove the previous transform-origin as it messes up the new transform
                el.style["transform"] = s;
                el.style["transition"] = "transform 1ms ease";
                el.style["transform-origin"] = oString;
                $(el).offset(elOffset);

                this.currentZoom = zoom;
            }
        });
    }

    zoomIn(e) {
        // On big apps, zoom can be not real-time.
        if( this.currentlyZooming ) {
            clearTimeout(this.nextZoom);
            this.nextZoom = setTimeout(() => {
                this.zoomIn(e);
            });
        }
        else {
            if( this.currentZoom + 0.1 <= 1 ) {
                var newZoom = this.currentZoom + 0.1;
                this.setZoom(newZoom, e);
            }
        }
    }

    zoomOut(e) {
        if( this.currentlyZooming ) {
            clearTimeout(this.nextZoom);
            this.nextZoom = setTimeout(() => {
                this.zoomOut(e);
            });
        }
        else {
            if( this.currentZoom - 0.1 >= 0.1 ) {
                var newZoom = this.currentZoom - 0.1;
                this.setZoom(newZoom, e);
            }
        }
    }

    sleep( count ) {
        return new Promise((resolve) => {
            setTimeout(resolve, count);
        });
    }

    /*
    // temporary remove zoom if some lib/component needs it
    deactivate() {
        if( this.getZoom() !== 1 ) {
            var el = this.view.jsPlumbInstance.getContainer();

            this.transform = el.style["transform"];
            el.style["visibility"] = "hidden"; // better than resize glitch
            el.style["transform"] = "scale(1)";

            //el.style["transition"] = "none";
            //el.style["transform-origin"] = "none";
            return new Promise((resolve) => {
                $(el).one("transitionend", resolve);
            });
        }
        else {
            this.transform = null;
            return new Promise(resolve => resolve());
        }
    }

    activate(cb) {
        if( this.transform !== null ) {
            var el = this.view.jsPlumbInstance.getContainer();
            el.style["transform"] = this.transform;
            return new Promise((resolve) => {
                $(el).one("transitionend", () => {
                    el.style["visibility"] = "visible";
                    resolve();
                });
            });
        }
        else {
            this.transform = null;
            return new Promise(resolve => resolve());
        }
    }
    */

    deactivate() {
        this.previousZoom = this.currentZoom;
        return this.setZoom(1);
    }

    activate() {
        return this.setZoom(this.previousZoom);
    }
}

export default Zoomer;
