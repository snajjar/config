"use strict";

const LoopModule = require('../LoopModule');
const errors = require('../../Errors');
const desc = require('./If.json');

/**
 *  Module If is here to choose between two options from a condition
 *  by evaluating only the path from one of them (for performances)
 */
class If extends LoopModule {
    constructor(attrs) {
        super(desc, attrs);
    }

    compute(input, response) {
        response.send({ "result" : (input.cond ? input.ifTrue : input.ifFalse) });
    }

    // We received a READ message from node after us
    // Analyze it's missing elements to determine if we should process or not
    onRead(msg) {
        this.info("[EVENT] %s (state %s) RECEIVED read", this.id, this.getStatusName(), { userOrigin: false, event: true });
        if( this.haveOutputToNode(msg.node, msg.missing) ) {
            this.fetchMissingDataAndCompute();
        }
    }

    // On this node, there is 2 steps in fetching datas
    // Step 1: fetching the condition (cond)
    // Step 2: fetching ifTrue or ifFalse according to cond
    fetchMissingDataAndCompute() {
        this.validAndCloneDefaultInputs();

        if( this.isReady() ) {
            // if node is not already evaluating, trigger the 'ready' event to start
            // the evaluating process
            if( !this.isEvaluating() ) {
                this.setStatus(If.status.AWAITING_DATA);
                this.emit('ready');
            }
        }
        else {
            if( this.hasCond() ) {
                var cond = this.inputValue['cond'];
                var condInput = cond ? 'ifTrue' : 'ifFalse';
                this.setStatus(If.status.AWAITING_DATA);
                this.emit('read', { 'node': this, 'missing' : [condInput] });
            }
            else {
                // fetch the condition
                this.setStatus(If.status.AWAITING_DATA);
                this.emit('read', { 'node': this, 'missing' : ['cond'] });
            }
        }
    }

    onData( data ) {
        if( data.node === undefined ) {
            throw new errors.RuntimeError("node " + this.id + " received data with node undefined");
        }
        if( data.output === undefined ) {
            throw new errors.RuntimeError("node " + this.id + " received data with output undefined");
        }

        // remove node listener
        this.removeListener(data.node, "data");

        // log incoming event
        this.log("[EVENT] %s (state %s) RECEIVED data from %s", this.id, this.getStatusName(), data.node.id, { userOrigin: false, event: true });

        // process data to this.inputValue and this.inputValid
        if( this.isStatus(If.status.AWAITING_DATA) ) {
            var newValidKeys = this.validateNewKeys(data);

            if(this.isReady()){
                this.emit('ready');
            }
            else {
                if( newValidKeys.indexOf('cond') !== -1 ) {
                    // we got the first step: the condition. Now get the condition input
                    this.fetchMissingDataAndCompute();
                }
                else {
                    this.debug('%s still needs (%s) to compute', this.id, JSON.stringify(this.getInvalidInputs()), { userOrigin: false });
                }
            }
        }
        else {
            // discard callback, no value needed (ie none wants this node output)
            this.info("[EVENT DISCARD] discarding data event, no one is listening to this node output", { userOrigin: false });
        }
    }


    /**
     *  The "if" node is ready only when the condition input is ready,
     *  and when the right input (according to condition) is ready
     */
    isReady() {
        return this.hasCond() && this.hasCondInput();
    }

    // true if we fetched the condition already
    hasCond() {
        return this.inputValid['cond'];
    }

    // true if we fetched the condition and the input for the condition already
    // assume we already fetched the condition input
    hasCondInput() {
        var cond = this.inputValue['cond'];
        return cond ? this.inputValid['ifTrue'] : this.inputValid['ifFalse'];
    }

    /**
     *  Check the current input state.
     */
    runtimeCheckInput( error ){
        if( !this.hasCond() ) {
            throw new errors.RuntimeError(this.id + ": If condition was not resolved");
        }
        if(this.inputValue["cond"] === undefined){
            throw new errors.RuntimeError(this.id + ": input cond is not set to any value, module cannot be resolved");
        }
        if( !this.hasCondInput() ) {
            throw new errors.RuntimeError(this.id + ": If condition was resolved to " + this.inputValue['cond'] + " but the associated input wasnt resolved");
        }
    }
}

module.exports = If
