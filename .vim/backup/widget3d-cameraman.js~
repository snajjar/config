import { $, env, Widget3D, Widget3DCamera, utils as DualBoxUtils, Type, Errors} from '@dualbox/dualbox';
import {Box2, Box3, Vector2, Vector3, Face3, WebGLRenderer, Scene, Group, Color, DirectionalLight, HemisphereLight, AmbientLight, GridHelper, Raycaster, Geometry, Mesh, MeshBasicMaterial, Object3D, CameraMan} from '@dualbox/dualbox-lib-xthree';
var pkgDesc = require('../package.json');

var DualboxTypesAll3D = require('@dualbox/dualbox-type-all3d');

// for bundle compilation
if( env.browser ) {
    require('./widget3d-cameraman.css'); // for bundle compilation
}


var specialBindings = {
    rotateCam:true,
    translateCam:true,
    pinchZoomCam:true,
    pinchZoomTranslateCam:true
};

var pAOV = Widget3D.pushArrObjVal;
var rmIAO = Widget3D.rmIdxInArrObj;

/**
 *  WIdget to manipulate a Camera in the scene.
 *
 *  API :
 *
 *  zoomCam : zoom the point of interest, which is :
 *            - Current camera target if input targetMode is "Target0" (in this case, same as zoomTargetCam)
 *            - point under mouse if input targetMode is "TargetSmart"
 *  zoomTargetCam : zoom the camera target, which is :
 *            - Current camera target if input targetMode is "Target0" (in this case, same as zoomCam)
 *            - Closest point to the point under mouse in the camera direction if input targetMode is "TargetSmart"
 *  smartZoomOriginCam
 *  smartZoomCam
 *
 *  pinchZoomCam : to be used only with touchstart2, same behavior as zoomCam but controlled by a pinch.
 *  pinchZoomTranslateCam : to be used only with touchstart2, perform a zoom in/out and a translation at the same time (quite like google map)
 *
 *  rotateCam    : if bound to mousedownX/touchstartX:whatever, will init on mousedownX/touchstartX:whatever, run on mousemove/touchmoveX, and stop on mouseupX/touchendX
 *  translateCam : if bound to mousedownX/touchstartX:whatever, will init on mousedownX/touchstartX:whatever, run on mousemove/touchmoveX, and stop on mouseupX/touchendX
 *
 */
class Widget3DCameraMan extends Widget3DCamera {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options);

        // clone appDesc to be able to redefine the special events.
        this.appDesc = JSON.parse(JSON.stringify(this.appDesc));
        var evts = this.appDesc.attr.mouse || {};
        var to_rm = {};
        var that = this;
        Object.keys(evts).forEach(function (key) {
            for(var i=0; i<evts[key].length; ++i){
                var bind = evts[key][i];
                if(specialBindings[bind]){
                    var touch = key.search("touchstart") === 0;
                    var butt = touch || key[9] === ":" || key[9] === undefined ? "" : key[9];
                    // Number of touches, if relevant
                    var nt = touch && key.length > 10 ? key[10] : "";
                    if( (key.search("mousedown") === -1 ||  (butt !== "0" && butt !== "1" && butt !=="2")) && !touch){
                        throw "Error : Widget3DCameraMan special binding '"+bind+"' has not been made to handle something else than mousedown0, mousdown1 or mousdown2, touchstart, touchstartX with X in 1 9. Please refer to documentation.";
                    }

                    var stop_evt = (touch ? "touchend" : "mouseup") + nt;
                    var mv_evt = (touch ? "touchmove" : "mousemove") + nt;

                    pAOV(to_rm,key,i);
                    switch(bind){
                        case "rotateCam":
                            {
                                pAOV(evts,key,"cameraRotateInit");
                                pAOV(evts,mv_evt,"cameraRotateRun");
                                pAOV(evts,stop_evt+butt,"cameraRotateFinalize");
                            }
                        break;
                        case "translateCam":
                            {
                                pAOV(evts,key,"cameraTranslateInit");
                                pAOV(evts,mv_evt,"cameraTranslateRun");
                                pAOV(evts,stop_evt+butt,"cameraTranslateFinalize");
                            }
                        break;
                        case "pinchZoomCam":
                            {
                                if(key.search("touchstart2") === -1){
                                    throw "Error : pinchZoomCam can only be used binded to touchstart2";
                                }else{
                                    pAOV(evts,key,"pinchZoomCamInit");
                                    pAOV(evts,mv_evt,"pinchZoomCamRun");
                                    pAOV(evts,stop_evt+butt,"pinchZoomCamFinalize");
                                }
                            }
                        break;
                        case "pinchZoomTranslateCam":
                            {
                                if(key.search("touchstart2") === -1){
                                    new Errors.RuntimeError("Error : pinchZoomTranslateCam can only be used binded to touchstart2");
                                }else{
                                    pAOV(evts,key,"pinchZoomTranslateCamInit");
                                    pAOV(evts,mv_evt,"pinchZoomTranslateCamRun");
                                    pAOV(evts,stop_evt+butt,"pinchZoomTranslateCamFinalize");
                                }
                            }
                        break;
                        default:
                            new Errors.RuntimeError("Error : bind "+bind+" is in the special binding list but is not recognized in the constructor.");
                        break;
                    }
                }
            }
        });
        // remove all the special bindings that have been found
        Object.keys(to_rm).forEach(function (key) {
            var arr = to_rm[key];
            for(var i=0; i<arr.length; ++i){
                rmIAO(evts, key, i);
            }
        });

        this.overrideInputs = ["cameraType","target","orientation","distToTarget","bottom","top","left","right","targetMode","trackballHelper","centered","centeredAABB"];
        this.initOverride();
        // Keep data about the last override.
        this.lastOverride = {};
    }

    // Exposed to Canvas3D
    init3D(){
        this.inputPersist = {
            trackballHelper :true,
            targetMode: "Target0"
        };

        this.canvas3d.cameraMan.setRotMode(this.attr.rotMode);

        this._trackballHelper = {
            dynamic:false,
            mesh:null,
            scaleNode:null
        };
        this._zoomGlobals = {
            interval:null
        };
        this._zoomTimeout = null;

        this._prevCanvasX = 0;
        this._prevCanvasY = 0;

        this._rotating = false;
        this._translating = false;
        this._zooming = false;
    }

    // This will override the current position (set by the user)
    // with the position determined from the inputs.
    // this.override contains which inputs must override the current position.
    overrideUserInputs(){

        var inVal = this.inputValue;
        var changed = this.override;

        var cm = this.canvas3d.getCameraMan();
        var pos = cm.getPosition();

        var inVal_tg = inVal.target;
        var inVal_o  = inVal.orientation;

        var dtt = changed.distToTarget? inVal.distToTarget : pos.distToTarget;
        cm.setMaxDist(this.attr.maxDistFactor*dtt);
        cm.setMinDist(this.attr.minDistFactor*dtt);

        cm.setPosition({
            rotNode:{
                px: changed.target ? inVal_tg.x : pos.rotNode.px,
                py: changed.target ? inVal_tg.y : pos.rotNode.py,
                pz: changed.target ? inVal_tg.z : pos.rotNode.pz,
                rx: changed.orientation ? inVal_o.x : pos.rotNode.rx,
                ry: changed.orientation ? inVal_o.y : pos.rotNode.ry,
                rz: changed.orientation ? inVal_o.z : pos.rotNode.rz
            },
            distToTarget: dtt,
            camType: changed.cameraType ? inVal.cameraType : pos.cameraType,
            ortho:{
                left:   changed.left    ? inVal.left : pos.ortho.left,
                right:  changed.right   ? inVal.right : pos.ortho.right,
                bottom: changed.bottom  ? inVal.bottom : pos.ortho.bottom,
                top:    changed.top     ? inVal.top : pos.ortho.top,
            }
        });

        if(changed.centered && changed.centeredAABB && inVal.centered !== null && inVal.centeredAABB !== null){
            // the max dist of the camera will be set according to the size of the object.
            cm.setMaxDist(Number.MAX_VALUE/10);
            cm.centerView(inVal.centeredAABB, inVal.centered);
            cm.setMaxDist(this.attr.maxDistFactor*cm.getDistToTarget());
        }

        this.lastOverride.position = cm.getPosition();
    }

    // DEPRECATED : was used originaly by the canvas to know the original position of the cameraman
    //              for screenshot option.
    //              The only customer to use Canvas3D screenshot should be Thea Jewelry.
    getInitialCameraPosition(){
        return this.lastOverride.position;
    }

    setPersistentInputValues(){
        var inVal = this.inputValue;

        this.inputPersist.trackballHelper = inVal.trackballHelper;
        this.inputPersist.targetMode = inVal.targetMode;
    }

    /**
     *  setup the camera target point depending on mouse and camera position.
     *  This is used in several functions init/run, so we refactored that here.
     *  If necessary the function could return information (like for instance
     *  whether or not the object is fully visible).
     *  Following properties will be returned in result
     *          - objOnCanvas             boolean true if the aabb of the object projects on canvas
     *          - objCenterPoint          Object's aabb center point
     *          - interestPoint           The point on the surface/skeleton selected to probably be the user's point
     *                                   of interest. If none, setup to interest_point.

     *  Effects :
     *      The camera target will be set to the point on the camera view direction
     *      which is the closest to interest_point.
     *
     *  @param {boolean} dbl_behaviour if dbl_behaviour and isSceneGraphOnCanvas are true,
     *                                 the camera target will be setup to the point on the camera view direction
     *                                 which is closest to obj_center_point
     *
     *
     */
    cameraSetupTargetPointUnderMouse(canvasX, canvasY, dbl_behaviour)
    {
        var caman = this.canvas3d.getCameraMan();
        var targetMode = this.inputPersist.targetMode;

        //////////////////////////////////////////////////////////////////
        // Change the target point of the camera
        // NOTE : Could be moved to another state maybe...
        var ray = caman.getRay(canvasX, canvasY);

        var res = {
            interestPoint:null,
            objOnCanvas:true,
            objCenterPoint:true
        };

        switch(targetMode)
        {
            case "Target0":
            {
                res.interestPoint = caman.getTarget().clone();
            }
            break;
            case "TargetSmart":
            {
                // TODO : projTarget should not be necessary
                var target = caman.getTarget();
                var projTarget = (new Vector3(target.x,target.y,target.z)).project(
                    caman.getCamera()
                );

                res.objOnCanvas = this.canvas3d.isSceneGraphOnCanvas();

                var raycaster = new Raycaster(ray.origin, ray.direction);

                // now compute the target point, which correspond to the 3D point under mouse selected
                // to be the user point of interest.
                // The point of interest is considered to be :
                //      - if a surface is visible, the point which is both
                //        in the camera view direction line and in the plane orthogonal
                //        to the viewplane passing by the intersection point of the ray
                //        and the surface.
                //      -else, by default, interest_point is setup to the point that is on dir
                //       and closest to the center of the visible part of the object
                //       to do so we compute the distance to all plane passing by
                //       the 8 corners of the object aabb and orthogonal to the pointing direction dir
                //       we keep the smallest and largest and use the mean to find a point of interest

                res.interestPoint = new Vector3();
                res.interestPoint.copy(target);

                var intersections = raycaster.intersectObjects( this.canvas3d.meshGroup.children, true );

                if( intersections.length !== 0)
                {
                    res.interestPoint.copy(intersections[0].point);
                }

                // behaviour_p will be set to interest_point except if dbl_behaviour is true and object is in the canvas
                // this is used for rotation to ensure the following behaviour :
                var behaviour_p = res.interestPoint;
                if(dbl_behaviour)
                {
                    // Get the object aabb center point if the object is fully visible
                    // Ideally we should rotate around the center of mass...
                    if(res.objOnCanvas ){
                        var aabb = new Box3().setFromObject(this.canvas3d.scene);
                        res.objCenterPoint = aabb.getCenter();
                        behaviour_p = res.objCenterPoint;
                    }
                }

                // now the target point of the camera will be chosen to be the point on the camera view
                // direction wich is closest to behaviour_p.
                // we reuse mouse2D vector since it's almost the same computation
                projTarget = (new Vector3(behaviour_p.x,behaviour_p.y,behaviour_p.z)).project(
                    caman.getCamera()
                );
                var mouse2D = new Vector3(0,0,projTarget.z);
                mouse2D.unproject(caman.getCamera());

                caman.setTarget(mouse2D.x, mouse2D.y, mouse2D.z);
                caman.setDistToTarget(
                    (new Vector3()).subVectors(mouse2D,caman.getCameraWorldPosition()).length()
                );
            }
            break;
            default:
                throw "Error : this._cameraTargetMode is set to an unknown value";
        }
        return res;
    }

  /**
     *  Helper function for main rotation function.
     *  @return {boolean} true if the mouse is in the trackball
     */
    cameraRotateInTrackball(canvasX,canvasY) {
        // compute distance to center of trackball and check with radius size
        var dX = canvasX - $(this.canvas3d.getCanvas()).width()/2;
        var dY = canvasY - $(this.canvas3d.getCanvas()).height()/2;
        var d = Math.sqrt(dX * dX + dY * dY);
        var diameter = Math.min($(this.canvas3d.getCanvas()).height(),$(this.canvas3d.getCanvas()).width());
        return d<diameter/2;
    }

    /**
     * Initialize the Rotation from current position of mouse on canvas.
     */
    cameraRotateInit(event) {

        if(!this.rotating && !this._translating && !this._zooming){

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);
            this._rotating = true;

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.cameraMan;

            $('body').addClass('dualbox-w3d-cameraman-noselect'); // make everything unselectable
            var target_data = this.cameraSetupTargetPointUnderMouse(canvasX, canvasY, true);
            caman.prepareRotation(canvasX,canvasY);

            this.action = "rotate";

            var width = $(this.canvas3d.getCanvas()).width();
            var height = $(this.canvas3d.getCanvas()).height();

            ////////////////////////////////////////////////////////////////
            // Build the overlay geometry
            // Visual feedback for trackball
            if(this.inputPersist.trackballHelper){
                if(caman.getRotMode() == "trackball"){

                    var visu_geometry = new Geometry();
                    visu_geometry.vertices.length = 0;
                    visu_geometry.faces.length = 0;

                    var resolution = 20;
                    visu_geometry.vertices.push(new Vector3(0.995,0,0));
                    visu_geometry.vertices.push(new Vector3(0.9955,0,0));
                    for(var i=1; i<resolution-1; ++i){
                        var angle = (i/resolution)*Math.PI/2;
                        visu_geometry.vertices.push(new Vector3(0.995*Math.cos(angle),0.995*Math.sin(angle),0));
                        visu_geometry.vertices.push(new Vector3(Math.cos(angle),Math.sin(angle),0));
                    }
                    visu_geometry.vertices.push(new Vector3(0,0.995,0));
                    visu_geometry.vertices.push(new Vector3(0,0.9955,0));

                    // opposite half circle
                    var vl = visu_geometry.vertices.length;
                    for(var i=0; i<vl; ++i){
                        var v = visu_geometry.vertices[i];
                        visu_geometry.vertices.push(new Vector3(-v.x,-v.y,0));
                    }

                    for(var i=0; i<2*resolution-2; i+=2){
                    visu_geometry.faces.push(new Face3(i, i+1, i+3));
                    visu_geometry.faces.push(new Face3(i, i+3, i+2));
                    }
                    for(var i=0; i<2*resolution-2; i+=2){
                    visu_geometry.faces.push(new Face3(vl+i, vl+i+1, vl+i+3));
                    visu_geometry.faces.push(new Face3(vl+i, vl+i+3, vl+i+2));
                    }

                    var mat_mec = new MeshBasicMaterial({color:0x999999});

                    if(this._trackballHelper.scaleNode !== null){
                        this.canvas3d.getOverlays().removeElement(this._trackballHelper.scaleNode);
                        this._trackballHelper.mesh.geometry.dispose();
                        this._trackballHelper.mesh = null;
                        this._trackballHelper.scaleNode = null;
                    }
                    this._trackballHelper.mesh = new Mesh(visu_geometry, mat_mec);

                    // build a node for scaling
                    this._trackballHelper.scaleNode = new Object3D();
                    this._trackballHelper.scaleNode.add(this._trackballHelper.mesh);
                    this.canvas3d.getOverlays().addElement(this._trackballHelper.scaleNode);

                    var diameter = Math.min(height,width);
                    this._trackballHelper.scaleNode.scale.x = diameter/width;
                    this._trackballHelper.scaleNode.scale.y = diameter/height;

                    this._trackballHelper.mesh.rotation.z = -Math.PI/4;

                    // check if we are in the trackball, and apply a cursor style or not
                    if( this.cameraRotateInTrackball(canvasX,canvasY) ) {
                        $(this.canvas3d.getRenderer().domElement).css('cursor', 'move');
                    }
                    else {
                        $(this.canvas3d.getRenderer().domElement).css('cursor', 'NS-resize');
                    }
                } // end visual feedback init for trackball
            }
        }
    }

    /**
     * Actually rotate the camera, according to mouse position change.
     */
    cameraRotateRun(event)
    {
        if(this._rotating){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;
            var caman = this.canvas3d.cameraMan;

            caman.rotateFromMouse(canvasX, canvasY);
            if(caman.getRotMode() == "trackball"){
                // check if we are in the trackball, and apply a cursor style or not
                if( this.cameraRotateInTrackball(canvasX,canvasY) ) {
                    $(this.canvas3d.getRenderer().domElement).css('cursor', 'move');
                }
                else {
                    $(this.canvas3d.getRenderer().domElement).css('cursor', 'NS-resize');
                }
            }
        }
    }

    /**
     *  End the rotation action
     */
    cameraRotateFinalize(event) {
        if(this._rotating){

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;
            var caman = this.canvas3d.cameraMan;
            if(caman.getRotMode() == "trackball" && this.inputPersist.trackballHelper){
                this.canvas3d.getOverlays().removeElement(this._trackballHelper.scaleNode);
                if( this._trackballHelper.scaleNode && this._trackballHelper.mesh ) {
                    this._trackballHelper.scaleNode.remove(this._trackballHelper.mesh);
                    this._trackballHelper.scaleNode = null;
                    this._trackballHelper.mesh.geometry.dispose();
                    this._trackballHelper.mesh = null;
                }
            }

            $('body').removeClass('dualbox-w3d-cameraman-noselect'); // make everything selectable
            $(this.canvas3d.getRenderer().domElement).css('cursor', 'default');

            this._rotating = false;
            this.canvas3d.freeWidget3D(this);
        }
    }

    /**
     * Initialize the translation from current position of mouse on canvas.
     */
    cameraTranslateInit(event) {

        if(!this._rotating && !this._translating && !this._zooming){

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);

            this._translating = true;

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;
            var caman = this.canvas3d.cameraMan;

            var target_data = this.cameraSetupTargetPointUnderMouse(canvasX, canvasY);

            this.action = "translate";

            // Init must be called on the canvas
            // So canvasX/Y are well defined
            this._prevCanvasX = canvasX;
            this._prevCanvasY = canvasY;
            $('body').addClass('dualbox-w3d-cameraman-noselect'); // make everything unselectable
        }
    }

    /**
     * Actually translate the camera, according to mouse position change.
     */
    cameraTranslateRun(event)
    {
        if(this._translating){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;
            var caman = this.canvas3d.cameraMan;

            var width = $(this.canvas3d.getCanvas()).width();
            var height = $(this.canvas3d.getCanvas()).height();

            if(this.action === "translate"){
                var target = caman.getTarget();
                var projTarget = (new Vector3(target.x,target.y,target.z)).project(
                    caman.getCamera()
                );

                var mouse2D = new Vector3(0.0,0.0,projTarget.z);
                mouse2D.x = ( canvasX / width ) * 2 - 1;
                mouse2D.y = -( canvasY / height ) * 2 + 1;

                mouse2D.unproject(caman.getCamera());

                var curr_p = mouse2D.clone();

                mouse2D.x = ( this._prevCanvasX / width ) * 2 - 1;
                mouse2D.y = -( this._prevCanvasY / height ) * 2 + 1;
                mouse2D.z = projTarget.z;

                var prev_p = mouse2D.unproject(caman.getCamera());

                // Since we want to get the impression that the object is following the mouse,
                // we move the target to the opposite direction.
                caman.setTarget(target.x-curr_p.x+prev_p.x,
                                               target.y-curr_p.y+prev_p.y,
                                               target.z-curr_p.z+prev_p.z);

                this._prevCanvasX = canvasX;
                this._prevCanvasY = canvasY;
            }
        }
    }

    /**
     *  End the translation action
     */
    cameraTranslateFinalize(event) {
        if(this._translating){
            $('body').removeClass('dualbox-w3d-cameraman-noselect'); // make everything unselectable
            this._translating = false;
            this.canvas3d.freeWidget3D(this);
        }
    }


    /**
     *  This is used to zoom on cursor whatever may be the cameraTarget setting
     *  Sequence of camera position is memorized so that we can come back.
     *  @namespace
     */

    /**
     *  Perform a classic zoomin on cursor.
     */
    smartZoomIncrease(canvasX, canvasY){

        this.override = null;

        var caman = this.canvas3d.getCameraMan();

        var cam_set = this.inputPersist.targetMode;
        this.inputPersist.targetMode = "TargetSmart";
        this.zoomIncdec(canvasX, canvasY, 0.15);
        this.inputPersist.targetMode = cam_set;
    }
    /**
     *  Choose betwee origin centered zoomout or classic zoomCursor
     *  zoomout dependeing on the position of the modeled object on the canvas.
     */
    smartZoomDecrease(canvasX, canvasY){

        this.override = null;

        var caman = this.canvas3d.getCameraMan();

        if(this.canvas3d.isSceneGraphOnCanvas())
        {
            this.smartZoomOriginDecrease(canvasX, canvasY);
        }else{
            var cam_set = this.inputPersist.targetMode;
            this.inputPersist.targetMode = "TargetSmart";
            this.zoomIncdec(canvasX, canvasY,-0.15);
            this.inputPersist.targetMode = cam_set;
        }
    }
    /**
     *  Smoothly animate camera move to zoom on a point.
     *  Current target is replaced by cursor hit point if any, and
     *  distance to target is decreased at each step.
     *
     *  Note : this function is especially made for interfaces such as "double click"
     *         as on google map.
     */
    smartZoomOriginIncrease(canvasX, canvasY)
    {
        this.override = null;

        var caman = this.canvas3d.getCameraMan();

        if(this._zoomGlobals.interval !== null){
            clearInterval(this._zoomGlobals.interval);
            this._zoomGlobals.interval = null;
        }

        var target_data = this.cameraSetupTargetPointUnderMouse(canvasX, canvasY, false);

        var old_target = caman.getTarget().clone();
        var old_d = caman.getDistToTarget();
        var new_target = target_data.interestPoint;
        var new_d = 0.6*old_d;
        var c = 0;
        var that = this;
        this._zoomGlobals.interval = setInterval(
            function () {
                if(c<=60){
                    var t = c/60;
                    c+=2;
                    that.cameraMan.setDistToTarget(
                        t*new_d + (1-t)*old_d
                    );
                    that.cameraMan.setTarget(
                        t*new_target.x + (1-t)*old_target.x,
                        t*new_target.y + (1-t)*old_target.y,
                        t*new_target.z + (1-t)*old_target.z
                    );
                }else{
                    clearInterval(that._zoomGlobals.interval);
                    that._zoomGlobals.interval = null;
                }
            },
            1/60
        );
    }
    /**
     *  Smoothly animate the camera position to move backward and change
     *  target at the same time.
     *  If the object is completely on screen, the view will recenter
     *  at the original camera target point position (setup in this.attr.camPos, or 0,0,0 if none)
     */
    smartZoomOriginDecrease(canvasX, canvasY)
    {
        this.override = null;

        var caman = this.canvas3d.getCameraMan();
        var target_data = this.cameraSetupTargetPointUnderMouse(canvasX, canvasY, false);

        if(this._zoomGlobals.interval !== null){
            clearInterval(this._zoomGlobals.interval);
            this._zoomGlobals.interval  = null;
        }

        var old_target = caman.getTarget().clone();
        var old_d = caman.getDistToTarget();
        var old_ortho = caman.getPosition().ortho;
        var new_target = target_data.interestPoint;
        var new_d = old_d/0.6;
        var new_ortho = null; // TODO : some dezooming will be uncomplete in case of an ortho camera, should be corrected.
        if(this.canvas3d.isSceneGraphOnCanvas())
        {
            new_d = this.lastOverride.position.distToTarget;
            new_target = new Vector3(this.lastOverride.position.rotNode.px, this.lastOverride.position.rotNode.py, this.lastOverride.position.rotNode.pz);
            new_ortho = JSON.parse(JSON.stringify(this.lastOverride.position.ortho));
            // check that the aspect has not changed (can be important if a canvas resize occured)
            var aspect = (new_ortho.right-new_ortho.left)/(new_ortho.top-new_ortho.bottom);
            var cvs_s = this.canvas3d.renderer.getSize();
            if(aspect !== cvs_s.width/cvs_s.height){
                aspect = cvs_s.width/cvs_s.height;
                var cw = new_ortho.right-new_ortho.left;
                var ch = new_ortho.top-new_ortho.bottom;
                var ch2 = ch/2;
                var mid = (new_ortho.right+new_ortho.left)/2;
                new_ortho.left = mid - ch2*aspect;
                new_ortho.right = mid + ch2*aspect;
            }
        }
        var c = 0;
        var that = this;
        this._zoomGlobals.interval = setInterval(
            function () {
                if(c<=60){
                    var t = c/60;
                    c+=2;
                    caman.setDistToTarget(
                        t*new_d + (1-t)*old_d
                    );
                    caman.setTarget(
                        t*new_target.x + (1-t)*old_target.x,
                        t*new_target.y + (1-t)*old_target.y,
                        t*new_target.z + (1-t)*old_target.z
                    );
                    if(new_ortho){
                        caman.setOrthographicCameraAllParameters(
                            t*new_ortho.left + (1-t)*old_ortho.left,
                            t*new_ortho.right + (1-t)*old_ortho.right,
                            t*new_ortho.top + (1-t)*old_ortho.top,
                            t*new_ortho.bottom + (1-t)*old_ortho.bottom
                        );
                    }
                }else{
                    clearInterval(that._zoomGlobals.interval);
                    that._zoomGlobals.interval = null;
                }
            },
            1/60
        );
    }

    /**
     *
     */
    zoomCursorAnim() {
        this.override = null;

        var caman = this.canvas3d.getCameraMan();
        $(this.canvas3d.getRenderer().domElement).css('cursor', 'crosshair');
        clearTimeout( this._zoomTimeout );
        var self = this;
        this._zoomTimeout = setTimeout(
            function() {
                $(self.canvas3d.getRenderer().domElement).css('cursor', 'default');
            }, 200
        );
    }

    /**
     *  General function used in increase and decrease.
     *  @param {number} coeff The coefficient of zoom, in percentage of the distance to the target, negative to zoom out.
     */
    zoomIncdec(canvasX, canvasY, coeff)
    {
        this.override = null;

        // before processing, setup camera min dist to be X times the object
        // X chosen with a rule of thumb
        var caman = this.canvas3d.getCameraMan();

        // Use scene aabb
        var aabb_dims = this.canvas3d.getSceneAABB();
        if(aabb_dims.x < 0 || aabb_dims.y < 0 || aabb_dims.z < 0){
            aabb_dims = (new Box3()).setFromObject(this.widgetGroup).getSize();
            if(aabb_dims.x < 0 || aabb_dims.y < 0 || aabb_dims.z < 0){
                console.warn("WARNING : nothing to zoom on");
                aabb_dims = null;
            }
        }
        var target_data = this.cameraSetupTargetPointUnderMouse(canvasX, canvasY, false);
        if(aabb_dims !== null){
            // caman.setMaxDist(10*Math.max(Math.max(aabb_dims.x, aabb_dims.y),aabb_dims.z));
            caman.zoomPoint(coeff, target_data.interestPoint);
            this.zoomCursorAnim();
        }else{
            caman.zoomTarget(coeff);
        }
    }

    /**
     *  Get closer to the target point.
     */
    zoomIncrease(canvasX, canvasY) {
        this.zoomIncdec(canvasX, canvasY, 0.2);
    }

    /**
     *  Get away from the target point.
     */
    zoomDecrease(canvasX, canvasY) {
        this.zoomIncdec(canvasX, canvasY, -0.25);
    }

    /**
     *  Get closer to the target point.
     */
    zoomTargetIncrease(event) {

        this.override = null;

        var canvasX = event.cvs3dEvent.mouseData.canvasX;
        var canvasY = event.cvs3dEvent.mouseData.canvasY;
        this.cameraSetupTargetPointUnderMouse(canvasX, canvasY, false);
        var caman = this.canvas3d.getCameraMan();
        caman.zoomTarget(0.2);
    }

    /**
     *  Get away from the target point.
     */
    zoomTargetDecrease(event) {

        this.override = null;

        var canvasX = event.cvs3dEvent.mouseData.canvasX;
        var canvasY = event.cvs3dEvent.mouseData.canvasY;
        this.cameraSetupTargetPointUnderMouse(canvasX, canvasY, false);
        var caman = this.canvas3d.getCameraMan();
        caman.zoomTarget(-0.2);
    }

    pinchZoomCamInit(event){
        var canvasX = event.cvs3dEvent.mouseData.touchesX;
        var canvasY = event.cvs3dEvent.mouseData.touchesY;
        if(!this._rotating && !this._translating && !this._zooming){

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);

            this._zooming = true;

            this.action = "zoom";

            // Init must be called on the canvas
            // So canvasX/Y are well defined
            this._prevCanvasX = canvasX;
            this._prevCanvasY = canvasY;
            $('body').addClass('dualbox-w3d-cameraman-noselect'); // make everything unselectable
        }
    }
    pinchZoomCamRun(event){
        var canvasX = event.cvs3dEvent.mouseData.touchesX;
        var canvasY = event.cvs3dEvent.mouseData.touchesY;
        if(this._zooming){
            var x = this._prevCanvasX[0]-this._prevCanvasX[1];
            var y = this._prevCanvasY[0]-this._prevCanvasY[1];

            var d1 = Math.sqrt(x*x+y*y);

            x = canvasX[0]-canvasX[1];
            y = canvasY[0]-canvasY[1];

            var d2 = Math.sqrt(x*x+y*y);

            var ratio = 1 - d1/d2;

            this.zoomIncdec(canvasX, canvasY, ratio);

            this._prevCanvasX = canvasX;
            this._prevCanvasY = canvasY;
        }
    }
    pinchZoomCamFinalize(event){
        if(this._zooming){
            $('body').removeClass('dualbox-w3d-cameraman-noselect');
            this._zooming = false;
            this.canvas3d.freeWidget3D(this);
        }
    }

    pinchZoomTranslateCamInit(event){
        var canvasX = event.cvs3dEvent.mouseData.touchesX;
        var canvasY = event.cvs3dEvent.mouseData.touchesY;
        if(!this._rotating && !this._translating && !this._zooming){

            console.log("INI pinchZoomTrans");

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);

            this._zooming = true;

            this.action = "zoom";

            // Init must be called on the canvas
            // So canvasX/Y are well defined
            this._prevCanvasX = canvasX;
            this._prevCanvasY = canvasY;
            $('body').addClass('dualbox-w3d-cameraman-noselect'); // make everything unselectable
        }
    }
    pinchZoomTranslateCamRun(event){
        var canvasX = event.cvs3dEvent.mouseData.touchesX;
        var canvasY = event.cvs3dEvent.mouseData.touchesY;
        var caman = this.canvas3d.getCameraMan();

        var width = $(this.canvas3d.getCanvas()).width();
        var height = $(this.canvas3d.getCanvas()).height();
        if(this._zooming){

            var x = this._prevCanvasX[0]-this._prevCanvasX[1];
            var y = this._prevCanvasY[0]-this._prevCanvasY[1];
            var d1 = Math.sqrt(x*x+y*y);

            x = canvasX[0]-canvasX[1];
            y = canvasY[0]-canvasY[1];

            var d2 = Math.sqrt(x*x+y*y);

            var ratio = 1 - d1/d2;

            var midX = (canvasX[0]+canvasX[1])*0.5;
            var midY = (canvasY[0]+canvasY[1])*0.5;
            var prev_midX = (this._prevCanvasX[0]+this._prevCanvasX[1])*0.5;
            var prev_midY = (this._prevCanvasY[0]+this._prevCanvasY[1])*0.5;

            var target_data = this.cameraSetupTargetPointUnderMouse(midX, midY, false);
            caman.zoomPoint(ratio, target_data.interestPoint);

            var target = caman.getTarget();
            var projTarget = (new Vector3(target.x,target.y,target.z)).project(
                caman.getCamera()
            );

            var mouse2D = new Vector3(0.0,0.0,projTarget.z);
            mouse2D.x = ( midX / width ) * 2 - 1;
            mouse2D.y = -( midY / height ) * 2 + 1;

            mouse2D.unproject(caman.getCamera());

            var curr_p = mouse2D.clone();

            mouse2D.x = ( prev_midX / width ) * 2 - 1;
            mouse2D.y = -( prev_midY / height ) * 2 + 1;
            mouse2D.z = projTarget.z;

            var prev_p = mouse2D.unproject(caman.getCamera());

            // Since we want to get the impression that the object is following the mouse,
            // we move the target to the opposite direction.
            caman.setTarget(target.x-curr_p.x+prev_p.x,
                                           target.y-curr_p.y+prev_p.y,
                                           target.z-curr_p.z+prev_p.z);

            this._prevCanvasX = canvasX;
            this._prevCanvasY = canvasY;
        }
    }
    pinchZoomTranslateCamFinalize(event){
        if(this._zooming){
            $('body').removeClass('dualbox-w3d-cameraman-noselect');
            this._zooming = false;
            this.canvas3d.freeWidget3D(this);
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Following functions are API function for the widget                   //
    //
    //  zoomCam
    //  zoomTargetCam
    //  smartZoomOriginCam
    //  smartZoomCam
    //
    ///////////////////////////////////////////////////////////////////////////

    // API Function
    zoomCam(event){
        var canvasX = event.cvs3dEvent.mouseData.canvasX;
        var canvasY = event.cvs3dEvent.mouseData.canvasY;
        if(event.cvs3dEvent.name.search("mousewheel") === -1 || event.htmlEvent.deltaY < 0){
            this.zoomIncrease(this._canvasX,this._canvasY);
        }else{
            this.zoomDecrease(this._canvasX,this._canvasY);
        }
    }

    // API Function
    zoomTargetCam(event){
        if(event.htmlEvent.deltaY < 0){
            this.zoomTargetIncrease();
        }else{
            this.zoomTargetDecrease();
        }
    }

    // API Function
    smartZoomOriginCam(event){
        if(event.htmlEvent.deltaY < 0){
            this.smartZoomOriginIncrease(event.cvs3dEvent.mouseData.canvasX,event.cvs3dEvent.mouseData.canvasY);
        }else{
            this.smartZoomOriginDecrease(event.cvs3dEvent.mouseData.canvasX,event.cvs3dEvent.mouseData.canvasY);
        }
    }

    // API Function
    // When zooming out a lot, this will reposition the object at the original distance and with the original target point.
    // Original distance and target are defined by CameraMan inputs.
    smartZoomCam(event){
        if(event.htmlEvent.deltaY < 0){
            this.smartZoomIncrease(event.cvs3dEvent.mouseData.canvasX,event.cvs3dEvent.mouseData.canvasY);
        }else{
            this.smartZoomDecrease(event.cvs3dEvent.mouseData.canvasX,event.cvs3dEvent.mouseData.canvasY);
        }
    }

    onReady() {

        if(this.override){
            this.overrideUserInputs();
        }
        this.setPersistentInputValues();

        this.emit('data', {});
    }

    static attachTo(appDesc, attrs, div) {
        var dt = new Widget3DCameraMan(pkgDesc, appDesc, attrs);
        return dt;
    }
}

module.exports = Widget3DCameraMan;
