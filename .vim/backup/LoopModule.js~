"use strict";

const _ = require('lodash');
const SimpleModule = require('./SimpleModule');
const Type = require('../Type');
const misc = require('../utils/misc');
const env = require('../Env.js');
const errors = require('../Errors');

/**
 *  Adding loop capabilities to Modules.
 */
class LoopModule extends SimpleModule {
    constructor(desc, attrs, arg3) {
        super(desc, attrs);

        // Clone of this node created when a loop is expected from this node.
        this.loop = null;

        // References are kept for interruption purpose
        this.looperNode = null;
        this.looperNodeListenerUUID = null;
        this.looperNodeListener = null;

        this.initialAttributes = attrs;
    }

    reduce( f ) {
        super.reduce(f);
        if( this.looperNode ) {
            this.looperNode.reduce(f);
        }
    }

    reduceApps( f ) {
        super.reduceApps(f);
        if( this.looperNode ) {
            this.looperNode.reduceApps(f);
        }
    }

    // when setLogLevel is called, set in also on the looper node
    setLogLevel( logLevel ) {
        super.setLogLevel(logLevel);
        if( this.looperNode ) this.looperNode.setLogLevel( logLevel );
    }

    getExtendedInputTypes( key ){
        var res = super.getExtendedInputTypes(key);
        if(this.loop !== null && this.loop.backfeed[key] === undefined){
            Array.prototype.push.apply(res, this.looperNode.getExtendedInputTypes( key ));
            return res;
        }else{
            return res;
        }
    }

    clone(clonedAttrs){
        var node = new this.constructor(clonedAttrs);
        return node;
    }

    // looperNode is not authorized to restart, so this module must
    canRestart() {
        return this.looperNode ? true : super.canRestart();
    }

    initLooperNode(){
        var attributes = Object.assign({}, this.initialAttributes);
        attributes.id = this.id+'>loop_'+this.loop.type;
        this.looperNode = this.clone(attributes); // Only attrs required in dualbox_modules
        this.looperNode.initialize();
        this.looperNode.connect({},[]);
        this.looperNode.setMaxListeners(2); // it's own listener + the one from the main node
        this.looperNode.allowRestart(false);  // not authorized to restart itself on interruption
    }

    /**
     *  Add a loop to this node.
     *  Internally, loops are managed by lonely nodes instanciated to repeat a given computation.
     *  Note : to be called before init and link (connect).
     *  @param {Object} loopdef Js object describing the loop
     */
    addLoop(loopdef){
        if( this.loop === null ) {
            // no loop defined on this node, init a looperNode
            this.loop = JSON.parse(JSON.stringify(loopdef));

            if(this.loop.iterators === undefined || Object.keys(this.loop.iterators).length === 0){
                throw new errors.CompileError("At least one iterator must be defined on a loop.");
            }

            this.loop.type = "for";

            // if a loop defines feedback (i.e: results to be reinjected on the next iteration),
            // It's a "combine" loop. Otherwise, it's a "match" loop.
            if(this.loop.feedback !== undefined && Object.keys(loopdef.feedback).length !== 0){
                this.loop.refs = "combine";
                this.loop.backfeed = misc.swap(this.loop.feedback); // reverse key, value
            }else{
                this.loop.refs = "match";
                this.loop.feedback = {};
                this.loop.backfeed = {};
            }

            this.initLooperNode();
        }
        else {
            // we already have a loop defined on this node, add the loop to our loopernode
            this.looperNode.addLoop(loopdef);
        }

        // "arrayize" input types if they are not retroactive (ie feedback from output)
        // Now explicit iterators are necessary so loop will only consider iterating
        var keys = Object.keys(this.inputType);
        for(var i=0; i<keys.length; ++i){
            if(this.loop.iterators[keys[i]] !== undefined){
                this.inputType[keys[i]] = "array<"+this.inputType[keys[i]]+">";
            }
        }

        // if not combine type, also "arrayize" output types
        if(this.loop.refs !== "combine"){
            keys = Object.keys(this.outputType);
            for(var i=0; i<keys.length; ++i){
                this.outputType[keys[i]] = "array<"+this.outputType[keys[i]]+">";
            }
        }
    }

    /**
     *  Check that this node is electable for "combine" looping.
     *  Combine looping will perform a while loop on elements, combining them according to what the node does.
     *  The node must be a combine node.
     *  A combine node is a node such that :
     *      - Inputs can be regrouped as 2 sets with the same types.
     *        Ex : {i1:number, s1:String, i2:number, s2:string} --> {i1,s1}  {i2,s2}
     *      - Output types must be the same as one set of input, like {s:string, i:number} in the example above.
     *  Note : for now we enforce naming convention : the input set must have the same name followed by 1 and 2.
     */
    checkCombineLoopThrow(){
        var outkeys = Object.keys(this.desc.dualbox.output);
        var inkeys = Object.keys(this.desc.dualbox.input);
        for(var i=0; i<outkeys.length; ++i){
            for(var j=1; j<3; ++j){
                var outkey = outkeys[i];
                if( this.desc.dualbox.input[outkey+j.toString()] === undefined ||
                    this.desc.dualbox.input[outkey+j.toString()].type.toLowerCase() !== this.desc.dualbox.output[outkey].type.toLowerCase())
                {
                    throw new errors.TypeError(
                        "Module " + this.desc.name + " is not electable for combine loops." +
                        " Reason : " + (this.desc.dualbox.input[outkey+j.toString()] === undefined ?
                            "Input " + outkey+j.toString() + " is not defined. " :
                            "Type mismatch between output " + outkey + " and input " + outkey+j.toString()));
                }
            }
        }
    }

    /**
     *  Return the number of loops set on this node.
     */
    countLoops(){
        return this.loop ? this.looperNode.countLoops() + 1 : 0;
    }

    /**
     *   When a loop is running, we may not want to clone depending on some node state.
     */
    shouldCloneOnLoop(inkey){
        return !this.isConst(inkey);
    }

    /**
     *   Correctly interrupts the looper node
     */
    interrupt(invalidKeys) {
        super.interrupt(invalidKeys);

        // In case this node is computing and looping, stop listening to
        // the looper nodes data event.
        if(this.looperNode !== null){
            /*
            // clean data listener and reset the default one
            this.looperNode.removeAllListeners('data');
            this.looperNode.setAfterDataListener();
            */

            if( this.looperNodeListenerUUID ) {
                this.looperNode.removeListenerById('data', this.looperNodeListenerUUID);
            }

            // interrupt but don't trigger computation again, will be node by this node
            var newInvalidKeys = _.filter(invalidKeys, (k) => { return this.inputValid[k] });
            this.looperNode.interrupt(newInvalidKeys);
            this.retrigger();

            //this.initLooperNode();
        }
    }


    /**
     *  This function is called to manage loops.
     *
     *  we suppose that expected types are in this.inputTypes.
     *  They are already adapted to the repeat order
     *  ie : for each loop there is an "array<..>"
     *
     *  @private
     */
    computeLoop(){
        var desc = this.desc;
        var outkeys = Object.keys(desc.dualbox.output);
        var inkeys = Object.keys(desc.dualbox.input);

        // Extract the size of the loop (number of iterations).
        // Check that the input have the right type (type check) and the right size (loopSize) for the loop
        // Update : we do not enforce iterator keys to have the same number of elements.
        //          The loop size will be the lower size of all iterators.
        //          This is for convenience.
        var typeMatch = {};
        var loopSize = -1;
        for(var i=0; i<inkeys.length; ++i){
            var inkey = inkeys[i];
            typeMatch[inkey] = Type.check(this.getInputType(inkey), this.inputValue[inkey]);

            if( this.loop.iterators[inkey] !== undefined ){
                if( typeMatch[inkey] ){
                    if(loopSize === -1){
                        loopSize = this.inputValue[inkey].length;
                    }else{
                        loopSize = Math.min(this.inputValue[inkey].length, loopSize);
                    }
                }
            }
        }
        if(loopSize === -1){
            throw new errors.RuntimeError("Error while computing loop in " + this.id + ".\n" +
                "Loop inputs type does not match the expected loop type.");
        }

        // init output with initial values :
        //   - for feedback values, it is initialized with the corresponding input feed.
        //   - for all other outputs, default value must be provided (in case of no iteration)
        var outputs = {};
        for(var i=0; i<outkeys.length; ++i){
            let backkey = this.loop.feedback[outkeys[i]];
            if( backkey !== undefined ){
                outputs[outkeys[i]] = !this.isConst(inkey) ?
                    Type.clone(this.inputValue[backkey]) :
                    this.inputValue[backkey];
            }
            else{
                outputs[outkeys[i]] = new Array(loopSize);
            }
        }

        var count = 0;
        var node = this.looperNode;

        // called on 'data' emitted by the looperNode
        this.looperNodeListener = function(data) {
            this.debug("[DATALISTENER:LOOP] %s loop data listener starting", this.id, { userOrigin: false });

            // Process and stack results of non-feedback outputs
            for(var i=0; i<outkeys.length; ++i){
                if( this.loop.feedback[outkeys[i]] === undefined ){
                    outputs[outkeys[i]][count] = data.output[outkeys[i]];
                }
            }

            // continue with the next iteration
            count++;
            if( count === loopSize ) {
                // loop is done, copy result of feedback output and emit data
                for(var i=0; i<outkeys.length; ++i){
                    if(this.loop.feedback[outkeys[i]] !== undefined){
                        outputs[outkeys[i]] = data.output[outkeys[i]];
                    }
                }

                //this.debug("[LOOP] ready to return results", { userOrigin: false });
                if( this.isReady() ) {
                    this.emit('data', outputs);
                }
                else {
                    throw new errors.RuntimeError("We were about to send data, but weren't in ready state");
                }
            }
            else{
                //this.debug("[LOOP] next iteration", { userOrigin: false });
                setInputsAndProcess(data);
            }
        };

        var self = this;
        var setInputsAndProcess = function(outputData){
            // for each input, setup data
            for (var i = 0; i < inkeys.length; ++i) {
                var inkey = inkeys[i];

                if( self.loop.backfeed[inkey] ){
                    // if it's a feedback input, re-insert data from the last output
                    node.setDefaultInput(inkey, outputData.output[self.loop.backfeed[inkey]], false);
                }
                else {
                    // inkey is either:
                    // - an iterator:
                    //   - if the type matches the type of the loop iterator: set the n'th element of the array
                    //   - otherwise: just set the input value
                    // - a neutral input: just set the input value
                    var val = self.loop.iterators[inkey] !== undefined ?
                                (typeMatch[inkey] ? self.inputValue[inkey][count] : self.inputValue[inkey])
                                : self.inputValue[inkey];

                    if( self.loop.iterators[inkey] && typeMatch[inkey] && self.inputValue[inkey].length <= count ) {
                        /*
                        self.dump();
                        self.error("count: " + count);
                        self.error("inkey: " + inkey);
                        self.error("typeMatch[" + inkey + "]: " + typeMatch[inkey]);
                        throw new errors.ImplementationError('LooperNode: we reached the end of the input array...');
                        */
                        // We shall have been interrupted, return quietly
                        return;
                    }

                    // clone the input if needed
                    if( self.shouldCloneOnLoop(inkey) ) {
                        val = Type.clone(val);
                    }

                    node.setDefaultInput(inkey, val);
                }
            }

            // setup the listener on the loopernode, and start compute
            self.looperNodeListenerUUID = node.once(self, 'data', self.looperNodeListener.bind(self));
            node.fetchMissingDataAndCompute();
        }

        // initiate the loop
        if( loopSize == 0 ) {
            if( this.isReady() ) {
                this.emit('data', outputs);
            }
            else {
                throw "Oh oh... Should be ready here :-(";
            }
        }
        else {
            setInputsAndProcess({output:outputs});
        }
    }

    /**
     *  Override SimpleModule compute to handle loops
     */
    startCompute() {
        this.log("Computing %s", this.id, { userOrigin: false });
        if( this.profiler ) {
            // start the profiler timer
            this.startProfile();
        }

        this.runtimeCheckInput();
        this.setStatus(LoopModule.status.COMPUTING);

        if(this.loop !== null){
            this.computeLoop();
        }
        else {
            if(this.parallel && env.browser){
                // ensure that we are in a browser to spawn workers
                this.computeParallel();
            }
            else {
                // if in a worker or node, compute
                this.computeSequential();
            }
        }
    }
}

module.exports = LoopModule;
