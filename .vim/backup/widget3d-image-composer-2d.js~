import { $, env, Widget3D, Type, utils } from '@dualbox/dualbox';
import { CircleBufferGeometry, PlaneBufferGeometry, BufferTriGeometry, BufferGeometry, BufferAttribute, Mesh, MeshBasicMaterial, OrthographicCamera, Object3D, Segment3, Vector3, Matrix4, Plane, Quaternion, Texture, TextureLoader, DoubleSide, FontLoader, WebGLRenderer, Color, TextGeometry, Scene} from '@dualbox/dualbox-lib-xthree';
var pkgDesc = require('../package.json');
import { _ } from '@dualbox/dualbox-lib-lodash';

const icons = require('./icons.js');

var DualBoxFile = require('@dualbox/dualbox-type-file');
var ImageData = require('@dualbox/dualbox-type-imagedata');
const JSONObject = require('@dualbox/dualbox-type-json');

var fetchFile = require('@dualbox/dualbox-lib-dualbox-fetch-file');

if( env.browser ) {
    require('@dualbox/dualbox-lib-bootstrap');  // require bootstrap to work
    require('./widget3d-image-composer-2d.css'); // for bundle compilation
    require('@dualbox/dualbox-lib-bootstrap-slider');
}

var defaultGeom = {
    shapeScale:(new BufferTriGeometry()).copy(
        new CircleBufferGeometry(4,6)
    ).scale(2.0, 2.0, 2.0),
    shapeDirScale:(new BufferTriGeometry()).copy(
        new CircleBufferGeometry(4,6)
    ).scale(2.0, 2.0, 2.0),
    shapeRot:(new BufferTriGeometry()).copy(
        new CircleBufferGeometry(4,16)
    ).scale(2.0, 2.0, 2.0),
    shapeTrans:(new BufferTriGeometry()).copy(
        new PlaneBufferGeometry(1,1,1,1)
    ).scale(2.0, 2.0, 2.0)
};

//defaultGeom.shapeScale.rotateZ(Math.PI/4);
defaultGeom.shapeScale.rotateZ(Math.PI/4);

var specialBindings = {
    rotate:     ["initRotate", "runRotate", "stopRotate"],
    scale:      ["initScale", "runScale", "stopScale"],
    scalex:      ["initScaleX", "runScaleX", "stopScale"],
    scaley:      ["initScaleY", "runScaleY", "stopScale"],
    translate:  ["initTranslate", "runTranslate", "stopTranslate"]
};

var sbMeshes = {
    translate:"transnode",
    rotate:"rotnode",
    scale:"scalenode",
    scalex:"scaleXnode",
    scaley:"scaleYnode",
};

var pAOV = Widget3D.pushArrObjVal;
var rmIAO = Widget3D.rmIdxInArrObj;

/**
 *
 */
class Widget3DImageComposer2D extends Widget3D {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options);

        // clone appDesc to be able to redefine the special events.
        this.appDesc = JSON.parse(JSON.stringify(this.appDesc));
        var evts = this.appDesc.attr.mouse || {};
        var to_rm = {};
        var that = this;
        Object.keys(evts).forEach(function (key) {
            for(var i=0; i<evts[key].length; ++i){
                var bind = evts[key][i];
                if(specialBindings[bind]){
                    switch(bind){
                        case "rotate":
                        case "scale":
                        case "scalex":
                        case "scaley":
                        case "translate":
                            {
                                var touch = key.search("touchstart") === 0;
                                var butt = touch || key[9] === ":" || key[9] === undefined ? "" : key[9];
                                // Number of touches, if relevant
                                var nt = touch && key.length > 10 ? key[10] : "";
                                if( (key.search("mousedown") !== 0 ||  (butt !== "0" && butt !== "1" && butt !=="2")) && !touch){
                                    throw "Error : Widget3DImageComposer2D special binding 'slide' has not been made to handle something else than mousedown0, mousdown1 or mousdown2 and touchstart. Please refer to documentation.";
                                }
                                var st_evt = (touch ? "touchstart" : "mousedown") + nt;
                                var stop_evt = (touch ? "touchend" : "mouseup") + nt;
                                var mv_evt = (touch ? "touchmove" : "mousemove") + nt;
                                pAOV(to_rm,key,i);
                                pAOV(evts,st_evt+butt+":widget:"+that.id+":"+sbMeshes[bind],specialBindings[bind][0]);
                                pAOV(evts,mv_evt,specialBindings[bind][1]);
                                pAOV(evts,stop_evt+butt,specialBindings[bind][2]);
                            }
                        break;
                        default:
                            throw "Error : bind "+bind+" is in the special binding list but is not recognized in the constructor.";
                        break;
                    }
                }
            }
        });
        // remove all the special bindings that have been found
        Object.keys(to_rm).forEach(function (key) {
            var arr = to_rm[key];
            for(var i=0; i<arr.length; ++i){
                rmIAO(evts, key, i);
            }
        });

        if(!evts['mousemove']){
            evts['mousemove'] = [];
        }
        evts['mousemove'].push("manageHover");

        this.fonts = {};
        this._fetchFonts();

        // Init override inputs
        this.overrideInputs = ["images"];
        this.initOverride();

        // button is instanciated by attachTo
        this.addDiv = null;
            this.buttonAddImg = null;
            this.buttonAddText = null;

        this.selectDiv = null;
            this.textDiv = null;
            this.fontDiv = null;
            this.fontSizeDiv = null;
            this.buttonFontBold = null;
            this.imgDiv = null;
            // Sliders for color balance
            this.sliderBlackDiv = null;
                this.sliderBlack = null;
            this.sliderWhiteDiv = null;
                this.sliderWhite = null;
            this.buttonDeleteEl = null;
    }

    _fontsLoaded(){
        var res = {
            loaded:0,
            total:this.attr.fontList.length,
            done:true
        };
        for(var i=0; i<this.attr.fontList.length; ++i){
            var f = this.attr.fontList[i];
            if(!this.fonts[f].regular || !this.fonts[f].bold
                || !this.fonts[f].regular.loader || !this.fonts[f].bold.loader
            ){
                res.done = false;
            }else{
                res.loaded++;
            }
        }
        return res;
    }

    _fetchFonts(){
        for(var i=0; i<this.attr.fontList.length; ++i){
            var f = this.attr.fontList[i];
            this.fonts[f] = {
                regular:{
                    request:null,
                    json:null,
                    loader:null
                },
                bold:{
                    request:null,
                    json:null,
                    loader:null
                }
            };
            var self = this;
            var enableIfLoaded = function(font){
                if(self.fonts[font].regular.loader && self.fonts[font].bold.loader){
                    $(self.fontDiv).find('option[value="' + font + '"]').prop("disabled", false);
                }
            };
            fetchFile(this, this.attr.fontPath+f+"_regular.typeface.json", this.fonts[f].regular, (function(){
                    var ff = f;
                    return function(file){
                        if(file === null){
                            // fetch failed
                            delete self.fonts[ff].regular;
                            if(self.fonts[ff].bold === undefined){
                                delete self.fonts[ff];
                            }
                        }else{
                            self.fonts[ff].regular.json = JSON.parse(file.toUTF8String());
                            self.fonts[ff].regular.loader = (new FontLoader()).parse( self.fonts[ff].regular.json );
                            enableIfLoaded(ff);
                        }
                    }
                })()
            );
            fetchFile(this, this.attr.fontPath+f+"_bold.typeface.json", this.fonts[f].bold, (function(){
                    var ff = f;
                    return function(file){
                        if(file === null){
                            // fetch failed
                            delete self.fonts[ff].bold;
                            if(self.fonts[ff].regular === undefined){
                                delete self.fonts[ff];
                            }
                        }else{
                            self.fonts[ff].bold.json = JSON.parse(file.toUTF8String());
                            self.fonts[ff].bold.loader = (new FontLoader()).parse( self.fonts[ff].bold.json );
                            enableIfLoaded(ff);
                        }
                    }
                })()
            );
        }
    }

    _styleButtonFontBold(bold){
        var btn = $(this.buttonFontBold);
        if(bold){
            btn.addClass('btn-dark');
            btn.removeClass('btn-default');
            btn.css('color', 'white');
        }else{
            btn.addClass('btn-default');
            btn.removeClass('btn-dark');
            btn.css('color','');
        }
    }

    init3D(){

        this.initialValues = {
            images:[]
        };

        this.inputPersist = {
            visible:true,
            // may be an input later so have it here
            shapeTrans : defaultGeom.shapeTrans,

            shapeRot : defaultGeom.shapeRot,
            shapeScale : defaultGeom.shapeScale,
            shapeDirScale : defaultGeom.shapeDirScale,
            zone:new BufferTriGeometry(),
            zoneMap:null,
            // plane is here since it may be an input in the future
            plane : new Plane(new Vector3(0,0,1), 0)
        };
        this.inputPersist.plane.normalize();

        // used only if translateOnElement is true
        this.transNode = new Object3D();
        for(var i=0;i<4;++i){
            var m = new Mesh(
                this.inputPersist.shapeTrans.clone(),
                new MeshBasicMaterial()
            );
            this.transNode.add(m);
            m.name = "select-borders";
        }

        this.scaleNode = new Object3D();
        this.scaleXNode = new Object3D();
        this.scaleYNode = new Object3D();
        this.rotNode = new Object3D();
        this.rotNode.add(new Mesh(
            this.inputPersist.shapeRot.clone(),
            new MeshBasicMaterial()
        ));
        for(var i=0;i<4;++i){
            this.scaleNode.add(new Mesh(
                this.inputPersist.shapeScale,
                new MeshBasicMaterial()
            ));
        }
        for(var i=0;i<2;++i){
            this.scaleXNode.add(new Mesh(
                this.inputPersist.shapeDirScale,
                new MeshBasicMaterial()
            ));
            this.scaleYNode.add(new Mesh(
                this.inputPersist.shapeDirScale,
                new MeshBasicMaterial()
            ));
        }

        this.zone = new Mesh(
            this.inputPersist.zone.clone(),
            new MeshBasicMaterial({color:this.attr.zoneColor,side:DoubleSide, transparent:true})
        );
        this.zone.geometry.computeBoundingBox();
        this.background = new Mesh(
            (new BufferTriGeometry()).copy(
                    (new PlaneBufferGeometry(100000,100000,1,1)).translate(0,0,-0.01)
            ),
            new MeshBasicMaterial({color:this.attr.backgroundColor, side:DoubleSide})
        );
        this.background.position.z = this.zone.geometry.boundingBox.min.z;


        // That is the size of the square onwhich the handlers are defined before
        // being activated on an image.
        this.handlerRefScale = 100;

        // contains the meshes, transformed and with a texture being the modified image.
        this.imageDatas = []; // Image data corresponding to meshes in images.
        this.selected = null;

        // We use an Object3D to store the current selected object transformation since
        // it has some handly transformation functions
        this.transfo = new Object3D();

        this.setSceneMeshNames();

        this.canvas3d.widgetGroup.add(this.scaleNode);
        this.canvas3d.widgetGroup.add(this.scaleXNode);
        this.canvas3d.widgetGroup.add(this.scaleYNode);
        this.canvas3d.widgetGroup.add(this.rotNode);
        this.canvas3d.widgetGroup.add(this.transNode);
        this.canvas3d.widgetGroup.add(this.zone);
        this.canvas3d.widgetGroup.add(this.background);

        this.translating = false;
        this.rotating = false;
        this.scaling = false;
        this.scalingX = false;
        this.scalingY = false;

        // the point and transformation after a click triggering an init.
        // Will be used to have a better accuracy when running the transformations.
        this.initClic = new Vector3();
        this.initTransfo = new Object3D(); // should be useless to work with matrices, using position/scale/rotation should be enough.
        this.locPlane = null;

        this.timeoutTrigger =  null;
    }

    getSelectedData(){
        var i = parseInt(this.selected.name.replace("image-",""));
        return this.imageDatas[i];
    }

    computeVisibility(){
        var v = this.visible;
        if(this.initialized){
            v = v && this.inputPersist.visible;
        }
        if(this.initialized){
            var vs = v && this.selected !== null;
            for(var i=0; i<4; ++i){
                this.scaleNode.children[i].visible = vs;
                this.transNode.children[i].visible = vs;
            }
            for(var i=0; i<2; ++i){
                this.scaleXNode.children[i].visible = vs;
                this.scaleYNode.children[i].visible = vs;
            }
            this.rotNode.children[0].visible = vs;

            for(var i=4; i<this.transNode.children.length; ++i){
                this.transNode.children[i].visible = v;
            }
            this.zone.visible = v;
            this.background.visible = v && this.attr.background;
        }

        // UI
        if(v){
            if(this.initialized && this.selected){
                this.addDiv.hide();
                this.selectDiv.show();
                var data = this.getSelectedData();
                if(data.txt){
                    this.textDiv.show();
                    this.fontSizeDiv.show();
                    this.fontDiv.show();
                    this.sliderWhiteDiv.hide();
                    this.imgDiv.hide();
                }else{
                    this.textDiv.hide();
                    this.fontSizeDiv.hide();
                    this.fontDiv.hide();
                    this.sliderWhiteDiv.show();
                    this.imgDiv.show();
                }
            }else{
                this.addDiv.show();
                this.selectDiv.hide();
            }
        }else{
            this.addDiv.hide();
            this.selectDiv.hide();
        }
    }

    triggerWithTimeout(){
        if(this.timeoutTrigger === null){
            var that = this;
            this.timeoutTrigger = setTimeout(
                function(){
                    clearTimeout(that.timeoutTrigger);
                    that.timeoutTrigger = null;
                    that.trigger({ "matrix" : this.transfo.matrix });
                },
                60
            );
        }
    }

    isTransforming(){
        return this.translating || this.rotating || this.scaling || this.scalingX || this.scalingY;
    }

    // Set scenenodes names.
    setSceneMeshNames(){
        this.scaleNode.name = this.id+"#"+"scalenode";
        this.scaleXNode.name = this.id+"#"+"scaleXnode";
        this.scaleYNode.name = this.id+"#"+"scaleYnode";
        this.rotNode.name = this.id+"#"+"rotnode";
        this.transNode.name = this.id+"#"+"transnode";
        this.zone.name = this.id+"#"+"zone";
        this.background.name = this.id+"#"+"background";
        this.computeVisibility();
    }

    // private : Move the given element in front
    // el is a mesh
    moveFront(el){
        var imgs = this.imageDatas;
        var dataEl = null;
        var zbase = this.zone.geometry.boundingBox.max.z;
        for(var i=0; i<imgs.length-1; ++i){
            var m = imgs[i].mesh;
            if(m === el){
                dataEl = imgs[i];
            }
            if(dataEl !== null){
                imgs[i] = imgs[i+1];
                imgs[i].mesh.name = "image-"+i;
            }
            m.position.z = zbase+i+1;
        }
        if(dataEl){
            imgs[imgs.length-1] = dataEl;
            dataEl.mesh.name = "image-"+(imgs.length-1);
        }
        el.position.z = zbase+imgs.length;
    }

    // if unscaled is true, the image will be added with its original size, otherwize it will be adapted to the zone size.
    addImage(imgdata, unscaled){

        if(this.attr.desaturate){
            imgdata.desaturate();
        }

        if(imgdata.width*imgdata.height > this.attr.maxImgSize){
            var s = this.attr.maxImgSize/(imgdata.width*imgdata.height);
            imgdata = imgdata.resize(Math.round(s*imgdata.width), Math.round(s*imgdata.height));
        }

        var mesh = new Mesh(
            (new BufferTriGeometry()).copy(
                new PlaneBufferGeometry( imgdata.width, imgdata.height, 1, 1 )
            ),
            new MeshBasicMaterial({
                map:new TextureLoader().load( imgdata.toDataURL("png"), function(tex){
                    // set filtering here if necessary
                }),
                transparent:true
            })
        );
        mesh.name = "image-"+this.imageDatas.length;

        mesh.geometry.computeBoundingBox();

        if(!unscaled){
            var z = this.zone;
            var z_size = z.geometry.boundingBox.getSize();

            var m_size = mesh.geometry.boundingBox.getSize();

            var s = Math.min(1, Math.min(z_size.y/m_size.y,z_size.x/m_size.x));
            mesh.scale.set(s,s,1);
        }

        this.transNode.add(mesh);
        this.imageDatas.push({
            mesh:mesh,
            origin:imgdata,
            current:imgdata.clone(),
            lvlCursor:{
                black:0,
                white:255
            },
            txt:null
        });

        this.moveFront(mesh);
    }

    buildTextImageDataURL(text,font,bold){
        var f = this.fonts[font];

        if(!f){
            this.error("The font " + font + " has not been loaded by the widget. The text cannot be added.");
        }

        if(bold && (!f.bold || !f.bold.json) || !bold && (!f.regular || !f.regular.json)){
            this.error("The font " + font + " has not been loaded in "+ (bold ? "bold" : "regular") + " variation. The text cannot be added.");
        }

        var tg = new TextGeometry( text, {
            font: (new FontLoader()).parse( this.fonts[font][bold ? "bold" : "regular"].json ),
            size: this.attr.fontSize,
            height: 0.2,
            curveSegments: 8,
            bevelEnabled: false
        });
        tg.computeBoundingBox();
        var tc = tg.boundingBox.getCenter();
        tg.translate(-tc.x, -tc.y,-tc.z);
        tg.computeBoundingBox();
        var tsize = tg.boundingBox.getSize();


        var scene = new Scene();
        scene.add(new Mesh(
            tg,
            new MeshBasicMaterial({color:0x000000})
        ));

        var camera = new OrthographicCamera(-Math.ceil(tsize.x/2), Math.ceil(tsize.x/2), Math.ceil(tsize.y/2), -Math.ceil(tsize.y/2), -500, 500 );
        // Don't know why this is necessary but it seems to be...
        camera.updateProjectionMatrix();

        var aspect = (camera.right-camera.left)/(camera.top-camera.bottom);

        var canvas = document.createElement('canvas');
        canvas.height = camera.top-camera.bottom;
        canvas.width  = camera.right-camera.left;

        if(canvas.width > 2048){
            var ratio = 2048/canvas.width;
            canvas.width = 2048;
            canvas.height = canvas.height*ratio;
        }

        var renderer = new WebGLRenderer( { antialias: true, canvas: canvas, alpha : true } );

        renderer.setClearColor( 0x000000, 0);
        renderer.setSize( canvas.width, canvas.height );
        renderer.autoClear = false;
        renderer.clear();

        scene.updateMatrix();
        scene.updateMatrixWorld();

        renderer.render( scene, camera );

        return canvas.toDataURL("image/png");
    }

    addText(text, font, bold, size){

        //this.addImage( ImageData.fromDataURL(this.buildTextImageDataURL(text, font, bold)), true);

        var f = this.fonts[font];

        if(!f){
            this.error("The font " + font + " has not been loaded by the widget. The text cannot be added.");
        }

        if(bold && (!f.bold || !f.bold.json) || !bold && (!f.regular || !f.regular.json)){
            this.error("The font " + font + " has not been loaded in "+ (bold ? "bold" : "regular") + " variation. The text cannot be added.");
        }

        var tg = (new BufferTriGeometry()).copy(
            (new BufferGeometry()).fromGeometry(
                new TextGeometry( text, {
                    font: this.fonts[font][bold ? "bold" : "regular"].loader,
                    size: size,
                    height: 0.2,
                    curveSegments: 8,
                    bevelEnabled: false
                })
            )
        );
        tg.computeBoundingBox();
        var tc = tg.boundingBox.getCenter();
        tg.translate(-tc.x, -tc.y,-tc.z);
        tg.computeBoundingBox();
        var tsize = tg.boundingBox.getSize();
        var mesh = new Mesh(
            tg,
            new MeshBasicMaterial({color:0x000000})
        );
        mesh.name = "image-"+this.imageDatas.length;

        var select_mesh = new Mesh(
            (new BufferTriGeometry()).copy(
                new PlaneBufferGeometry( tsize.x, tsize.y, 1, 1 )
            ),
            new MeshBasicMaterial({
                color:0x00ff00,
                transparent:true,
                opacity:0.0001
            })
        );
        select_mesh.name = "txt-select-mesh";
        select_mesh.geometry.computeBoundingBox();
        select_mesh.position.z = -0.1;
        mesh.add(
            select_mesh
        );

        this.transNode.add(mesh);

        this.imageDatas.push({
            mesh:mesh,
            // not an image so no origin nor current
            origin:null,
            current:null,
            lvlCursor:{
                black:0
            },
            txt: {
                value:text,
                font:font,
                bold:bold,
                size:size
            }
        });
        this.moveFront(mesh);

        // Change output of this module to output a JSON, since there is no way to have multiple outputs.
        //   JSON will contain the images and the text, font etc associated with it.

        // Add interface for text selection (multichoice of fonts, text input)
    }

    deleteSelectedElement(){
        if(this.selected !== null){
            var rm_el = this.selected;
            this.unselectAll();
            var n = parseInt(rm_el.name.split("-")[1]);
            this.transNode.remove(this.imageDatas[n].mesh);
            for(var i=n; i<this.imageDatas.length-1; ++i){
                this.imageDatas[i] = this.imageDatas[i+1];
                this.imageDatas[i].mesh.name = "image-"+i;
            }
            this.imageDatas.length = this.imageDatas.length-1;
            this.moveFront(this.imageDatas[this.imageDatas.length-1].mesh)

            this.doTrigger();
        }
    }

    duplicateSelectedElement(){
        if(this.selected !== null){
            var i = parseInt(this.selected.name.replace("image-",""));
            var idts = this.imageDatas;

            if(idts[i].txt){
                var params = idts[i].txt;
                var mesh = idts[i].mesh.clone();
                mesh.geometry = mesh.geometry.clone();
                mesh.geometry.computeBoundingBox();
                mesh.material = mesh.material.clone();
                mesh.name = "image-"+idts.length;

                var select_mesh = mesh.children[0];
                select_mesh.name = "txt-select-mesh";
                select_mesh.geometry = select_mesh.geometry.clone();
                select_mesh.geometry.computeBoundingBox();
                select_mesh.material = select_mesh.material.clone();

                this.transNode.add(mesh);

                idts.push({
                    mesh:mesh,
                    // not an image so no origin nor current
                    origin:null,
                    current:null,
                    lvlCursor:{
                        black:idts[i].lvlCursor.black
                    },
                    txt: JSON.parse(JSON.stringify(idts[i].txt))
                });

            }else{
                this.addImage(idts[i].current.clone());
                var clone_i = idts.length-1;
                var clone = idts[clone_i];
                clone.origin = idts[i].origin.clone();
                clone.lvlCursor.white = idts[i].lvlCursor.white;
                clone.lvlCursor.black = idts[i].lvlCursor.black;

                clone.mesh.position.copy(this.selected.position);
                clone.mesh.rotation.copy(this.selected.rotation);
                clone.mesh.scale.copy(this.selected.scale);
            }

            this.unselectAll();
            this.selectElement(this.imageDatas[idts.length-1].mesh);

            this.doTrigger();
        }
    }

    flipHSelectedElement(){
        if(this.selected){
            var i = parseInt(this.selected.name.replace("image-",""));
            var dt = this.imageDatas[i];
            if(dt.txt){
                dt.mesh.geometry.scale(-1,1,1);
                dt.mesh.geometry.flipSide();
            }else{
                dt.mesh.material.map = new TextureLoader().load(
                    this.imageDatas[i].current.flipHorizontal().toDataURL("png"),
                    function(tex){
                        // set filtering here if necessary
                    }
                )
                dt.origin.flipHorizontal();
            }

            this.doTrigger();
        }
    }
    flipVSelectedElement(){
        if(this.selected){
            var i = parseInt(this.selected.name.replace("image-",""));
            var dt = this.imageDatas[i];
            if(dt.txt){
                dt.mesh.geometry.scale(1,-1,1);
                dt.mesh.geometry.flipSide();
            }else{
                dt.mesh.material.map = new TextureLoader().load(
                    dt.current.flipVertical().toDataURL("png"),
                    function(tex){
                        // set filtering here if necessary
                    }
                )
                dt.origin.flipVertical();
            }

            this.doTrigger();
        }
    }

    selectElement(el){

        this.selected = el.name === "txt-select-mesh" ? el.parent : el;
        var dt = this.getSelectedData();

        this.sliderBlack.bootstrapSlider('setValue',dt.lvlCursor.black);
        if(!dt.txt){
            this.sliderWhite.bootstrapSlider('setValue',dt.lvlCursor.white);
        }

        this.moveFront(this.selected);
        this.selected.updateMatrix();

        var box = this.selected.geometry.boundingBox.clone();
        var s = box.getSize();
        s.x /= this.handlerRefScale;
        s.y /= this.handlerRefScale;
        s.z = 1;

        this.setSelectedTransformation(this.selected.matrix);

        if(dt.txt){
            $(this.textDiv).find('input').val(dt.txt.value);
            $(this.fontSizeDiv).find('input').bootstrapSlider('setValue', dt.txt.size);
            $(this.fontSizeDiv).find('.slider-val').text( dt.txt.size );
            $(this.fontDiv).find('select').val(dt.txt.font);
            this._styleButtonFontBold(dt.txt.bold);
        }

        this.computeVisibility();
    }

    unselectAll(){
        this.selected = null;
        this.computeVisibility();
    }

    // private Set the given transformation matrix on the selected element
    //         and handlers
    setSelectedTransformation(m){
        var dec = {
            translation : new Vector3(),
            quaternion : new Quaternion(),
            scale : new Vector3()
        };
        m.decompose(dec.translation, dec.quaternion, dec.scale);
        dec.quaternion.normalize();
        this.selected.position.copy(dec.translation);
        this.selected.rotation.setFromQuaternion(dec.quaternion);
        this.selected.scale.copy(dec.scale);
        this.selected.updateMatrix();

        // handler scale determined from the camera setup and canvas resolution
        var hscale = this.attr.handleScale*1.0;
        var cam = this.canvas3d.getCameraMan().getCamera();
        hscale = (cam.left - cam.right) / this.canvas3d.getSize().width;

        var sbox = this.selected.geometry.boundingBox;
        var min = sbox.min;
        var max = sbox.max;
        // Set corners
        this.scaleNode.children[0].position.set(min.x,min.y,max.z+0.1);
        this.scaleNode.children[1].position.set(max.x,min.y,max.z+0.1);
        this.scaleNode.children[2].position.set(max.x,max.y,max.z+0.1);
        this.scaleNode.children[3].position.set(min.x,max.y,max.z+0.1);
        for(var i=0;i<4;++i){
            this.scaleNode.children[i].scale.set(hscale,hscale,1);
        }

        // Set middle handlers
        this.scaleXNode.children[0].position.set(min.x,0.5*(min.y+max.y),max.z+0.05);
        this.scaleXNode.children[1].position.set(max.x,0.5*(min.y+max.y),max.z+0.05);
        this.scaleYNode.children[0].position.set(0.5*(min.x+max.x),min.y,max.z+0.05);
        this.scaleYNode.children[1].position.set(0.5*(min.x+max.x),max.y,max.z+0.05);
        for(var i=0;i<2;++i){
            this.scaleXNode.children[i].scale.set(hscale,hscale,1);
            this.scaleYNode.children[i].scale.set(hscale,hscale,1);
        }

        var sbox_size = sbox.getSize();
        var frame_width = hscale;
        this.transNode.children[0].geometry = defaultGeom.shapeTrans.clone().scale(frame_width, sbox_size.y*this.selected.scale.y,1);
        this.transNode.children[1].geometry = defaultGeom.shapeTrans.clone().scale(frame_width, sbox_size.y*this.selected.scale.y,1);
        this.transNode.children[2].geometry = defaultGeom.shapeTrans.clone().scale(sbox_size.x*this.selected.scale.x, frame_width,1);
        this.transNode.children[3].geometry = defaultGeom.shapeTrans.clone().scale(sbox_size.x*this.selected.scale.x, frame_width,1);
        this.transNode.children[0].position.set(-sbox_size.x/2,0,max.z+0.025);
        this.transNode.children[1].position.set(sbox_size.x/2,0,max.z+0.025);
        this.transNode.children[2].position.set(0,-sbox_size.y/2,max.z+0.025);
        this.transNode.children[3].position.set(0,sbox_size.y/2,max.z+0.025);

        this.rotNode.children[0].geometry = defaultGeom.shapeRot.clone().scale(hscale,hscale,1).translate(0,-hscale*16,0);
        this.rotNode.children[0].position.set(0.5*(max.x+min.x),max.y,max.z+0.05);

        var tr = this.scaleNode.children.concat(
                    this.scaleXNode.children
                 ).concat(
                    this.scaleYNode.children
                 ).concat(
                    this.rotNode.children
                 ).concat(
                    this.transNode.children.slice(0,4)
                 );

        for(var i=0; i<tr.length; ++i){
            tr[i].position.applyMatrix4(this.selected.matrix);
            tr[i].rotation.setFromQuaternion(dec.quaternion);
            // do not scale
        }
    }

    setPersistentInputValues(){
        var inVal = this.inputValue;

        this.inputPersist.visible = inVal.visible;

        var z = inVal.zone.clone();
        this.zone.geometry = z;
        z.computeBoundingBox();

        this.zone.material.map = inVal.zoneMap;
        this.zone.material.needsUpdate = true;

        this.background.position.z = this.zone.geometry.boundingBox.min.z;

        // move the front image in front,
        // actually a hack to reset all z values of the images.
        if(this.imageDatas.length !== 0){
            this.moveFront(this.imageDatas[this.imageDatas.length-1].mesh);
        }

        var shapeTags = ["shapeScale", "shapeRot", "shapeDirScale"];
        for(var i=0; i<shapeTags.length; ++i){
            if(inVal[shapeTags[i]] === null){
                this.inputPersist[shapeTags[i]] = defaultGeom[shapeTags[i]];
            }else{
                this.inputPersist[shapeTags[i]] = inVal[shapeTags[i]];
            }

        }
        for(var i=0;i<4;++i){
            this.scaleNode.children[i].geometry = this.inputPersist.shapeScale.clone().rotateZ(i*Math.PI/2);
        }
        for(var i=0;i<2;++i){
            this.scaleXNode.children[i].geometry = this.inputPersist.shapeDirScale.clone().rotateZ(i*Math.PI);
            this.scaleYNode.children[i].geometry = this.inputPersist.shapeDirScale.clone().rotateZ(i*Math.PI+Math.PI/2);
        }
        this.rotNode.children[0].geometry = this.inputPersist.shapeRot;

        for(var i=0;i<4;++i){
            this.scaleNode.children[i].material = inVal.matScale;
            this.transNode.children[i].material = inVal.matBorder;
        }
        for(var i=0;i<2;++i){
            this.scaleXNode.children[i].material = inVal.matScale;
            this.scaleYNode.children[i].material = inVal.matScale;
        }
        this.rotNode.children[0].material = inVal.matRot;

        // ensure the plane is normalized
        this.inputPersist.plane.normalize();

        this.unselectAll();

        this.computeVisibility();
    }

    // This will override the current position (set by the user)
    // with the position determined from the inputs.
    // this.override contains which inputs must override the current position.
    overrideUserInputs(){
        var inVal = this.inputValue;
        var changed = this.override;

        if(changed.images){
            this.initialValues.images = inVal.images;
        }
    }

    hide(){
        super.hide();
        this.computeVisibility();
    }
    show(){
        super.show();
        this.computeVisibility();
    }

    import(val) {
        var json = val instanceof JSONObject ? val.get() : val;
        for(var i=0; i<json.meshes.length; ++i){
            var dt = json.data[i];
            switch(dt.type){
                case "image":
                    this.imageDatas.push({
                        mesh:Mesh.fromJSON(json.meshes[i]),
                        origin:ImageData.fromDataURL(dt.origin),
                        current:null,
                        lvlCursor:{
                            black:dt.levels.black,
                            white:dt.levels.white
                        },
                        txt:null
                    });
                break;
                case "text":
                    this.imageDatas.push({
                        mesh:Mesh.fromJSON(json.meshes[i]),
                        // not an image so no origin nor current
                        origin:null,
                        current:null,
                        lvlCursor:{
                            black:dt.levels.black
                        },
                        txt: {
                            value:dt.value,
                            font:dt.font,
                            bold:dt.bold,
                            size:dt.size
                        }
                    });
                break;
                default:
                    throw "Error when importing in Widget3DImageComposer2D : element type is unknown";
                break;
            }
        }
        // TODO : apply black and white slider balance to all elements.
        doTrigger();
    }

    manageHover(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){
            if(under.on[0] === "widget" && under.on[1] === this.id){

            }else{

            }
        }
        event.cvs3dEvent.doPropagate();
    }

    _computeOutput(){
        var meshes = new Array(this.imageDatas.length);
        var data = new Array(this.imageDatas.length);
        this.imageDatas.forEach(function(v,i){
            var vty = v.mesh.visible;
            v.mesh.visible = true;
            var m = v.mesh.clone();
            v.mesh.visible = vty;
            if(v.txt){
                m.remove(m.children[0]);
                data[i] = {
                    type:"text",
                    value:v.txt.value,
                    font:v.txt.font,
                    bold:v.txt.bold,
                    size:v.txt.size,
                    levels:{
                        black:v.lvlCursor.black
                    }
                };
            }else{
                data[i] = {
                    type:"image",
                    origin:v.origin.toDataURL("png"),
                    levels:{
                        black:0,
                        white:255
                    }
                };
            }
            meshes[i] = m.toJSON();
        });
        return new JSONObject({
            meshes:meshes,
            data:data
        });
    }
    doTrigger(){
        this.trigger({ "elements" : this._computeOutput() });
    }

    // private
    deselectSelectedElement(){
        this.selected = null;
        this.computeVisibility();
    }
    // API Function
    deselectElement(event){
        if(!this.isTransforming()){
            deselectSelectedElement();
        }
    }

    initTranslate(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);
            this.translating = true;

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            // if the click occured on selection borders then no need to select anything.
            if(under.widgets[0].object.name !== "select-borders"){
                this.selectElement(under.widgets[0].object);
            }

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            this.locPlane = this.inputPersist.plane.clone();
            this.locPlane.constant = this.selected.position.z;
            ray.intersectPlane(this.locPlane, this.initClic);

            this.initTransfo.position.copy(this.selected.position);
            this.initTransfo.rotation.copy(this.selected.rotation);
            this.initTransfo.scale.copy(this.selected.scale);

            this.doTrigger();
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runTranslate(event){
        if(this.translating){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            var trans = ray.intersectPlane(this.locPlane, new Vector3());
            if(trans !== null){
                trans.sub(this.initClic);

                this.transfo.copy(this.initTransfo);
                this.transfo.position.add(trans);
                this.transfo.updateMatrix();

                this.setSelectedTransformation(this.transfo.matrix);

                if(this.attr.triggerOnMove){
                    this.doTrigger();
                }
            }
        }
    }

    // API Function
    stopTranslate(event){
        if(this.translating){
            this.canvas3d.freeWidget3D(this);
            this.translating = false;
            if(!this.attr.triggerOnMove){
                this.doTrigger();
            }
        }
    }

    // API Function
    initRotate(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);
            this.rotating = true;

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            this.locPlane = this.inputPersist.plane.clone();
            this.locPlane.constant = this.selected.position.z;
            ray.intersectPlane(this.locPlane, this.initClic);

            this.initTransfo.position.copy(this.selected.position);
            this.initTransfo.rotation.copy(this.selected.rotation);
            this.initTransfo.scale.copy(this.selected.scale);
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runRotate(event){
        if(this.rotating){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            var curr = ray.intersectPlane(this.locPlane, new Vector3());
            if(curr !== null){

                var vec1 = this.initClic.clone().sub(this.initTransfo.position);
                var vec2 = curr.clone().sub(this.initTransfo.position);

                var cross = (new Vector3()).crossVectors(vec1, vec2);
                var dot = vec1.dot(vec2);
                if(cross.length()> 0.0001){ // do not rotate if approximation can fuck everything
                    var angle = Math.sign(cross.z)*Math.acos(dot/(vec1.length()*vec2.length()));

                    this.transfo.copy(this.initTransfo);
                    this.transfo.rotateOnAxis(this.locPlane.normal, angle);
                    this.transfo.updateMatrix();

                    this.setSelectedTransformation(this.transfo.matrix);

                    if(this.attr.triggerOnMove){
                        this.doTrigger();
                    }
                }
            }
        }
    }

    // API Function
    stopRotate(event){
        if(this.rotating){
            this.canvas3d.freeWidget3D(this);
            this.rotating = false;
            if(!this.attr.triggerOnMove){
                this.doTrigger();
            }
        }
    }

    _initScale(event, xs, ys){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){

            this.override = null;

            this.canvas3d.enslaveWidget3D(this);
            this.scaling = xs && ys;
            this.scalingX = xs && !ys;
            this.scalingY = !xs && ys;

            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            this.locPlane = this.inputPersist.plane.clone();
            this.locPlane.constant = this.selected.position.z;
            ray.intersectPlane(this.locPlane, this.initClic);

            this.initTransfo.position.copy(this.selected.position);
            this.initTransfo.rotation.copy(this.selected.rotation);
            this.initTransfo.scale.copy(this.selected.scale);
        }
    }

    // API Function
    initScale(event){
        this._initScale(event, true, true);
    }
    initScaleX(event){
        this._initScale(event, true, false);
    }
    initScaleY(event){
        this._initScale(event, false, true);
    }

    // private
    _runScale(event, xs, ys){
        var canvasX = event.cvs3dEvent.mouseData.canvasX;
        var canvasY = event.cvs3dEvent.mouseData.canvasY;

        var caman = this.canvas3d.getCameraMan();

        var ray = caman.getRay(canvasX, canvasY);

        var curr = ray.intersectPlane(this.locPlane, new Vector3());
        if(curr !== null){

            var vec1 = this.initClic.clone().sub(this.initTransfo.position);
            var vec2 = curr.clone().sub(this.initTransfo.position);
            var vec2 = curr.clone().sub(this.initTransfo.position);

            var dot = vec1.dot(vec2);

            var scale = Math.sign(dot)*vec2.length()/vec1.length();

            this.transfo.copy(this.initTransfo);
            if(xs){
                this.transfo.scale.x *= scale;
                this.transfo.scale.x = Math.max(2/this.selected.geometry.boundingBox.getSize().x,this.transfo.scale.x);
            }
            if(ys){
                this.transfo.scale.y *= scale;
                this.transfo.scale.y = Math.max(2/this.selected.geometry.boundingBox.getSize().y,this.transfo.scale.y);
            }
            this.transfo.updateMatrix();

            this.setSelectedTransformation(this.transfo.matrix);

            if(this.attr.triggerOnMove){
                this.doTrigger();
            }
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runScale(event){
        if(this.scaling){
            this._runScale(event, true, true);
        }
    }
    runScaleX(event){
        if(this.scalingX){
            this._runScale(event, true, false);
        }
    }
    runScaleY(event){
        if(this.scalingY){
            this._runScale(event, false, true);
        }
    }

    // API Function
    stopScale(event){
        if(this.scaling || this.scalingX || this.scalingY){
            this.canvas3d.freeWidget3D(this);
            this.scaling = false;
            this.scalingX = false;
            this.scalingY = false;
            if(!this.attr.triggerOnMove){
                this.doTrigger();
            }
        }
    }

    onReady() {
        if(this.override){
            this.overrideUserInputs();
        }
        this.setPersistentInputValues();

        this.emit('data', { "elements" : this._computeOutput() });
    }

    onChange(evt) {
        var that = this;

        var files = evt.target.files; // FileList object

        // display the selected file name to our div
        $(this.div).find('.filename-display').text( files[0].name );

        // split extension and filename
        var tags = files[0].name.split('.');
        var name = "";
        for(var i=0; i<tags.length-1; ++i){
            name = name + tags[i];
        }

        var ext = "";
        if(tags.length > 1){
            ext = tags[tags.length-1];
        }

        // extract json content
        var self = this;
        DualBoxFile.asyncBuildFromBlob(files[0],ext,name,function(file){
            var imgdata = new ImageData();
            switch (file.getExtension()) {
                case 'jpg':
                case 'jpeg':
                    imgdata = imgdata.fromJPEG(file.toArrayBuffer());
                break;
                case 'png':
                    imgdata = imgdata.fromPNG(file.toArrayBuffer());
                break;
                default:
                    throw ("Widget3DImageComposer2D : Extension not recognize : " + file.getExtension() ) ;
                break;
            }
            self.addImage(imgdata);

            self.doTrigger();
        });
    }

    // color is "black" or "white".
    // It decides whether black or white pixels will be made transparent
    alphaSelectedElement(color){
        var getAlpha = function(l,a){
            // keep current alpha if it exist.
            if(a!== 255){
                return a;
            }
            return Math.round(255*(color === "black" ? l : 1-l));
        };
        var i = parseInt(this.selected.name.replace("image-",""));
        var dt = this.imageDatas[i];

        var walpha = (function() {
            var hsl = {h:0,s:0,l:0};
            return function(r,g,b,a){
                var c = new Color(r/255, g/255, b/255);
                c.getHSL(hsl);

                return [r,g,b, getAlpha(hsl.l, a)];
            }
        })();

        dt.origin = dt.origin.clone().iterate(walpha);

        this.onChangeSliderBalance(
            this.imageDatas[i].lvlCursor.black,
            this.imageDatas[i].lvlCursor.white
        );
    }
    whiteAlphaSelectedElement(){
        this.alphaSelectedElement("white");
    }
    blackAlphaSelectedElement(){
        this.alphaSelectedElement("black");
    }

    downloadSelectedElement(){
        var i = parseInt(this.selected.name.replace("image-",""));
        var dt = this.imageDatas[i];
        new DualBoxFile(dt.origin.toPNG(), "png", "image").download();
    }

    onChangeSelectedText(e, ui){
        if(this.selected){
            var i = parseInt(this.selected.name.replace("image-",""));
            var dt = this.imageDatas[i];
            if(dt.txt){
                var new_text = $(this.textDiv).find('input').val();
                new_text = (new_text !== "" ? new_text : "<>");

                var new_size = parseFloat($(this.fontSizeDiv).find('input').bootstrapSlider('getValue'));
                $(this.fontSizeDiv).find('.slider-val').text( new_size );

                var new_font = $(this.fontDiv).find('select').val();

                var new_bold = $(this.buttonFontBold).hasClass('btn-dark');

                var tg = (new BufferTriGeometry()).copy(
                    (new BufferGeometry()).fromGeometry(
                        new TextGeometry(
                            new_text,
                            {
                                font: this.fonts[new_font][new_bold ? "bold" : "regular"].loader,
                                size: new_size,
                                height: 0.2,
                                curveSegments: 8,
                                bevelEnabled: false
                            }
                        )
                    )
                );
                tg.computeBoundingBox();
                var tc = tg.boundingBox.getCenter();
                tg.translate(-tc.x, -tc.y,-tc.z);
                tg.computeBoundingBox();
                var tsize = tg.boundingBox.getSize();

                dt.mesh.geometry = tg;
                dt.mesh.children[0].geometry = (new BufferTriGeometry()).copy(
                    new PlaneBufferGeometry( tsize.x, tsize.y, 1, 1 )
                );
                dt.txt.value = new_text;
                dt.txt.size = new_size;
                dt.txt.font = new_font;
                dt.txt.bold = new_bold;

                if(dt.lvlCursor.black !== 0){
                    this.onChangeBlack();
                }

                this.setSelectedTransformation(this.selected.matrix);
            }
        }
    }

    onChangeSliderBalance(black, white){

        var i = parseInt(this.selected.name.replace("image-",""));

        var dt = this.imageDatas[i];

        if(dt.txt){
            var b = black/255;
            dt.mesh.material.color = new Color(b, b, b);
            dt.lvlCursor.black = black;
        }else{
            var iwhite = white/255;
            var iblack = black/255;

            var flum = (function() {
                var hsl = {h:0,s:0,l:0};
                return function(r,g,b,a){
                    var c = new Color(r/255, g/255, b/255);
                    c.getHSL(hsl);
                    hsl.l = iblack + hsl.l*(iwhite-iblack);
                    c.setHSL(hsl.h, hsl.s, hsl.l);

                    return [Math.round(c.r*255), Math.round(c.g*255), Math.round(c.b*255), a];
                }
            })();

            dt.current = dt.origin.clone().iterate(flum);

            dt.lvlCursor.black = black;
            dt.lvlCursor.white = white;

            var that = this;
            new TextureLoader().load( dt.current.toDataURL("png"), function(tex){
                // set filtering here if necessary
                that.selected.material.map = tex;
                that.doTrigger();
            });
        }
    }

    onChangeWhite(e, ui){
        this.onChangeSliderBalance(
            parseFloat(this.sliderBlack.bootstrapSlider('getValue')),
            ui ? parseFloat(ui.value) : parseFloat(this.sliderWhite.bootstrapSlider('getValue'))
        );
    }
    onChangeBlack(e, ui){
        this.onChangeSliderBalance(
            ui ? parseFloat(ui.value) : parseFloat(this.sliderBlack.bootstrapSlider('getValue')),
            parseFloat(this.sliderWhite.bootstrapSlider('getValue'))
        );
    }

    static attachTo(appDesc, attrs, div) {
        var component = new Widget3DImageComposer2D(pkgDesc, appDesc, attrs);

       // create the button separately and bind the click event to the component's hidden fileInput
        component.buttonAddImg = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconAddImage, alt:"AddImage" })
        ).click(function() {
            // instanciate a hidden fileInput
            var fileInput = $('<input/>', {
                id:    appDesc.attr.id,
                type:  'file',
                accept: "image/*",
            });
            fileInput.change(function(e) {
                component.onChange(e);
            });
            fileInput.click();
        });
        component.buttonAddText = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconAddText, alt:"AddText" })
        ).append(
            $('<div/>',{class:"w3d-image-composer-loader-container"}).append(
                  $('<span/>',{ text:component.attr.labelLoadingFonts.replace("_LOADED_", "0").replace("_TOTAL_", "0") })
            //    $('<div/>',{ class:"w3d-image-composer-loader"})
            )
        ).click(function() {
            if(component._fontsLoaded()){
                var fk = Object.keys(component.fonts);
                for(var fi=0; fi<fk.length; ++fi){
                    var font = component.fonts[fk[fi]];
                    if(font.regular && font.regular.loader){
                        component.addText("Dualbox", $(component.fontDiv).find('select').val(), $(component.buttonFontBold).hasClass('btn-dark'), component.attr.fontSize);
                        component.doTrigger();
                        break;
                    }
                }
            }
        });
        var stopAddTextSpinner = function(){
            component.buttonAddText.find('img').hide();
            var load_infos = component._fontsLoaded();
            if(load_infos.done){
                component.buttonAddText.find('img').show();
                component.buttonAddText.find('.w3d-image-composer-loader-container').hide();
                component.fontDiv.find('select').val( component.attr.fontList[0] );
            }else{

                component.buttonAddText.find('.w3d-image-composer-loader-container').find('span').text(
                    component.attr.labelLoadingFonts.replace("_LOADED_", load_infos.loaded).replace("_TOTAL_", load_infos.total)
                );

                setTimeout(
                    stopAddTextSpinner,
                    200
                );
            }
        };
        // stopAddTextSpinner(); // called later when fontDiv is instanciated

        component.sliderBlack = $('<input/>', { class:"w3d-image-composer-slider-black" });
        component.sliderWhite= $('<input/>',  { class:"w3d-image-composer-slider-white" });
        component.sliderBlackDiv = $('<div/>', { class:"w3d-image-composer-slider-black" }).append(
            component.sliderBlack
        );
        component.sliderWhiteDiv = $('<div/>', { class:"w3d-image-composer-slider-white" }).append(
            component.sliderWhite
        );

        component.buttonDeleteEl = $('<button/>', {
            class: "btn btn-danger"
        }).append(
            $('<img/>',{ src:icons.IconTrashBin, alt:"Delete Element" })
        ).click(component.deleteSelectedElement.bind(component));

        component.buttonDuplicateEl = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconCopy, alt:"Duplicate Element" })
        ).click(component.duplicateSelectedElement.bind(component));

        component.buttonDownloadEl = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconDownload, alt:"Download Element" })
        ).click(component.downloadSelectedElement.bind(component));

        component.buttonFlipHEl = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconFlipH, alt:"Flip Horizontal" })
        ).click(component.flipHSelectedElement.bind(component));

        component.buttonFlipVEl = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconFlipH, alt:"Flip Vertical", style:"-ms-transform: rotate(90deg); -webkit-transform: rotate(90deg); transform: rotate(90deg);" })
        ).click(component.flipVSelectedElement.bind(component));

        component.buttonBlackAlphaEl = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconClearBlack, alt:"Alpha" })
        ).click(component.blackAlphaSelectedElement.bind(component));

        component.buttonWhiteAlphaEl = $('<button/>', {
            class: "btn btn-secondary"
        }).append(
            $('<img/>',{ src:icons.IconClearWhite, alt:"Alpha" })
        ).click(component.whiteAlphaSelectedElement.bind(component));

        component.buttonBalance = $('<button/>', {
            class: "btn btn-success"
        }).append(
            $('<img/>',{ src:icons.IconBalance, alt:"Balance" })
        );

        component.buttonsGeneralDiv = $('<div/>').append(
            component.buttonDuplicateEl,
            component.buttonFlipHEl,
            component.buttonFlipVEl
        );

        component.textDiv = $('<div/>', { class : "dualbox form-group w3d-image-composer-input-text-div" }).append(
            $('<label/>', { class : "dualbox" }).append(
                $('<span/>', { class : "dualbox", text: "Text :" })
            ),
            $('<input/>', {
                type:  'text',
                class: 'dualbox form-control',
                value: "text",
                maxlength : 128
            })
            //.change(component.onChange.bind(component)) // bind onChange
            .keyup(component.onChangeSelectedText.bind(component)) // bind onKeyUp
        );

        var fontSelect = $('<select/>', {
            class: 'dualbox form-control',
        }).change(
            component.onChangeSelectedText.bind(component)
        );
        component.buttonFontBold = $('<button/>', {
            class: "dualbox form-group btn btn-default",
            style: "font-weight:bold; font-style:italic; width:100%;",
            text: "B"
        }).click(function(){
            var btn = component.buttonFontBold;
            if(btn.hasClass('btn-default')){
                component._styleButtonFontBold(true);
            }else{
                component._styleButtonFontBold(false);
            }
            component.onChangeSelectedText();
        });
        component.fontDiv = $('<div/>', { class : "dualbox form-group w3d-image-composer-font-div" }).append(
            $('<label/>', { class : "dualbox" }).append(
                $('<span/>', { class : "dualbox", text: "Font :" })
            ),
            fontSelect,
            component.buttonFontBold
        );
        _.each( component.attr.fontList, function(f) {
            fontSelect.append( $('<option/>', { class: 'dualbox', value:f }).append(f.replace(new RegExp("_","g")," ")));
        })
        stopAddTextSpinner();

        // instanciate div from app.json parameters
        var inputFontSize = $('<input/>', {});
        component.fontSizeDiv = $('<div/>', { class : "dualbox form-group w3d-image-composer-text-size-div" }).append(
            $('<label/>', { class: "dualbox", style: "width: 100%;" }).append(
                $('<span/>', { class: "dualbox", text: component.attr.labelFontSize }),
                $('<span/>', { class: 'dualbox slider-val', text: component.attr.fontSize, style: "float: right;" })
            ),
            inputFontSize
        );

        inputFontSize.bootstrapSlider({
            min:   8,
            max:   72,
            step:  1,
            formatter: function(value) {
                return value;
            }
        }).on('slide', component.onChangeSelectedText.bind(component));
        inputFontSize.on('slideStop', component.onChangeSelectedText.bind(component));

        inputFontSize.bootstrapSlider('setValue', component.attr.fontSize);

        component.imgDiv = $('<div/>').append(
            component.buttonDownloadEl,
            component.buttonWhiteAlphaEl,
            component.buttonBlackAlphaEl
        );

        component.selectDiv = $('<div/>', { class : "dualbox w3d-image-composer-select-img" }).append(
            $('<div/>', { class : "dualbox w3d-image-composer-select-img-actions" }).append(
                component.textDiv,
                component.fontDiv,
                component.fontSizeDiv,
                component.buttonsGeneralDiv,
                component.imgDiv,
                $('<div/>', { class : "dualbox w3d-image-composer-balance-div" }).append(
                    $('<label/>', { class: "dualbox" }).append(
                        $('<span/>', { class: "dualbox", text: "Black & White balance" })
                    ),
                    component.sliderBlackDiv,
                    component.sliderWhiteDiv
                ),
                component.buttonDeleteEl
            )
        );
        component.selectDiv.hide();

        component.sliderBlack.bootstrapSlider({
            min:   0,
            max:   255,
            step:  1,
            formatter: function(value) {
                return value;
            }
        }).on('slideStop', component.onChangeBlack.bind(component));
        component.sliderBlack.on('slide', component.onChangeBlack.bind(component))
        component.sliderBlack.bootstrapSlider('setValue',0);

        component.sliderWhite.bootstrapSlider({
            min:   0,
            max:   255,
            step:  1,
            formatter: function(value) {
                return value;
            }
        }).on('slideStop', component.onChangeWhite.bind(component));
        component.sliderWhite.on('slide', component.onChangeWhite.bind(component))
        component.sliderWhite.bootstrapSlider('setValue',255);

        component.addDiv = $('<div/>', { class : "dualbox w3d-image-composer-add-el" }).append(
            component.buttonAddImg,
            component.buttonAddText
        );


        // build the rest of the div (with the span that will show the file on click)
        component.div =
            $('<div/>', { class : "dualbox w3d-image-composer" }).append(
                component.addDiv,
                component.selectDiv
            );




        // measure the button width, then adjust the text div width from there
        var b = $(component.buttonAddImg).clone(false);
        b.css({ "display" : "block", "position" : "absolute", "visibility" : "hidden" });
        b.appendTo("body").ready(function() {
            var buttonWidth = b.outerWidth();
            $(component.div).find('.dualbox-file-display').css({ "width" : "calc(100% - " + buttonWidth + "px" });
            b.remove();
        });

        if(component.attr.hidden){
            component.hide();
        }

        // append to param div and return the input
        $(div).append(component.div);

        return component;
    }
}

module.exports = Widget3DImageComposer2D;
