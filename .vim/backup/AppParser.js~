"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *   File to parse an DualBox json file and extract dependencies
 */
var _ = require('@dualbox/dualbox-lib-lodash');

var htmltool = require('@dualbox/dualbox-lib-htmltool');

var AppParser =
/*#__PURE__*/
function () {
  function AppParser(json) {
    _classCallCheck(this, AppParser);

    this.json = json;
  }

  _createClass(AppParser, [{
    key: "isDualboxLibrary",
    value: function isDualboxLibrary(name) {
      return name === "@dualbox/dualbox" || name.startsWith("@dualbox/dualbox-lib");
    }
  }, {
    key: "isDualboxModule",
    value: function isDualboxModule(name) {
      return name.startsWith("@dualbox/dualbox-module");
    }
  }, {
    key: "isDualboxUI",
    value: function isDualboxUI(name) {
      return name.startsWith("@dualbox/dualbox-ui");
    }
  }, {
    key: "isDualboxCore",
    value: function isDualboxCore(name) {
      return name.startsWith("dualbox-core");
    }
  }, {
    key: "isDualboxComponent",
    value: function isDualboxComponent(name) {
      return name.startsWith("@dualbox/") || this.isDualboxCore(name);
    } // true if it's a npm dualbox package (false for dualbox-core)

  }, {
    key: "isDualboxPackage",
    value: function isDualboxPackage(name) {
      return this.isDualboxComponent(name) && !this.isDualboxCore(name);
    } // NOTE: this version works for a running App's json (since the json is modified runtime)
    // Find node through it's it. If it's a composed name (like metamodule>node-stuff),
    // dig through metamodules to find it
    // f takes a json parameter

  }, {
    key: "findNodeInRunningApp",
    value: function findNodeInRunningApp(id, f) {
      var json = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var prof = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (!json) json = this.json;
      var rjson = json.ui && json.ui[id] || json.modules && json.modules[id];

      if (rjson) {
        f(rjson);
        return;
      }

      var ids = id.split('>');
      var currentId = ids.slice(0, prof).join('>');
      var rjson = json.ui && json.ui[id] || json.modules && json.modules[currentId];

      if (rjson) {
        f(rjson);
      } else if (currentId == id) {
        throw "Couldnt find node " + id;
      } else {
        // find the current ancester node
        var ancesterId = ids.slice(0, prof + 1).join('>');
        var mjson = json.modules && json.modules[ancesterId];

        if (!mjson) {
          throw "Couldnt find ancester '" + ancesterId + "' from '" + id + "'";
        }

        if (ancesterId == id) {
          f(rjson);
          return;
        } else {
          // we need to go deeper
          var metanode = json.metanodes[mjson.module];

          if (!metanode) {
            throw "Module '" + ancesterId + "' from '" + id + "' is not a metanode. Can't dig deeper.";
          }

          this.findNode(id, f, metanode, prof + 1);
        }
      }
    } // Find node's json through an App definition. If it's a composed name (like metamodule>node-stuff),
    // dig through metamodules to find it
    // callback f takes a json parameter

  }, {
    key: "findNode",
    value: function findNode(id, f) {
      var json = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var prof = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (!json) json = this.json;
      var ids = id.split('>');
      var currentId = ids.slice(prof - 1, prof).join('>');

      if (prof == ids.length) {
        if (currentId.startsWith('input-')) {
          var rjson = json.input && json.input[currentId.replace('input-', '')];
        } else if (currentId.startsWith('output')) {
          var rjson = json.output && json.output[currentId.replace('output-', '')];
        } else {
          var rjson = json.ui && json.ui[currentId] || json.modules && json.modules[currentId];
        }

        if (rjson) {
          f(rjson);
        } else {
          throw "Couldnt find node " + id;
        }
      } else {
        // find the current ancester node
        var mjson = json.modules && json.modules[currentId];

        if (!mjson) {
          throw "Couldnt find ancester '" + currentId + "' from '" + id + "'";
        } // we need to go deeper


        var metanode = json.metanodes[mjson.module];

        if (!metanode) {
          throw "Module '" + ancesterId + "' from '" + id + "' is not a metanode. Can't dig deeper.";
        }

        this.findNode(id, f, metanode, prof + 1);
      }
    }
  }, {
    key: "eachMetanode",
    value: function eachMetanode(f) {
      var recurseMM = function recurseMM(json) {
        f(json);

        if (json.metanodes) {
          _.each(json.metanodes, function (metanode, id) {
            recurseMM(metanode);
          });
        }
      };

      recurseMM(this.json);
      return this; // for chaining
    } // f takes 2 parameters, json and id
    // each in all modules (metanodes' modules included)

  }, {
    key: "eachModule",
    value: function eachModule(f) {
      var recurseModules = function recurseModules(json) {
        if (json.modules) {
          _.each(json.modules, function (json, id) {
            f(json, id);
          });
        }

        if (json.metanodes) {
          _.each(json.metanodes, function (metanode, id) {
            recurseModules(metanode);
          });
        }
      };

      recurseModules(this.json);
      return this; // for chaining
    } // each only on top-level modules

  }, {
    key: "eachTopModule",
    value: function eachTopModule(f) {
      if (json.modules) {
        _.each(this.json.modules, function (json, id) {
          f(json, id);
        });
      }

      return this; // for chaining
    }
  }, {
    key: "eachTopMetanode",
    value: function eachTopMetanode(f) {
      _.each(json.metanodes, function (metanode, id) {
        f(metanode, id);
      });

      return this; // for chaining
    } // f takes 2 parameters, json and id

  }, {
    key: "eachUI",
    value: function eachUI(f) {
      _.each(this.json.ui, function (json, id) {
        f(json, id);
      });

      return this; // for chaining
    }
  }, {
    key: "eachInput",
    value: function eachInput(f) {
      var recurseInputs = function recurseInputs(json) {
        if (json.input) {
          _.each(json.input, function (json, id) {
            f(json, id);
          });
        }

        if (json.metanodes) {
          _.each(json.metanodes, function (metanode, id) {
            console.log('input recursing on ' + id);
            recurseInputs(metanode);
          });
        }
      };

      recurseInputs(this.json);
      return this; // for chaining
    }
  }, {
    key: "eachTopInput",
    value: function eachTopInput(f) {
      _.each(this.json.input, function (json, id) {
        f(json, id);
      });

      return this; // for chaining
    }
  }, {
    key: "eachOutput",
    value: function eachOutput(f) {
      var recurseOutputs = function recurseOutputs(json) {
        if (json.output) {
          _.each(json.output, function (json, id) {
            f(json, id);
          });
        }

        if (json.metanodes) {
          _.each(json.metanodes, function (metanode, id) {
            recurseOutputs(metanode);
          });
        }
      };

      recurseOutputs(this.json);
      return this; // for chaining
    }
  }, {
    key: "eachTopOutput",
    value: function eachTopOutput(f) {
      _.each(this.json.output, function (json, id) {
        f(json, id);
      });

      return this; // for chaining
    } // parse each input, output, ui and modules

  }, {
    key: "eachNode",
    value: function eachNode(f) {
      this.eachModule(f);
      this.eachUI(f);
      this.eachInput(f);
      this.eachOutput(f);
    } // f take name and version

  }, {
    key: "eachPackage",
    value: function eachPackage(f) {
      var deps = this.getDependencies();

      _.each(deps.libs, function (version, name) {
        f(name, version);
      });

      _.each(deps.module, function (version, name) {
        f(name, version);
      });

      _.each(deps.ui, function (version, name) {
        f(name, version);
      });

      return this; // for chaining
    } // f(panel, panelName)

  }, {
    key: "eachPanel",
    value: function eachPanel(f) {
      _.each(this.json["interface"], f);
    }
  }, {
    key: "findNodePanel",
    value: function findNodePanel(id) {
      var hasNode = function hasNode(jsonDiv, id) {
        var found = false;

        if (jsonDiv && jsonDiv.attributes && jsonDiv.attributes.dataset && jsonDiv.attributes.dataset.node) {
          return jsonDiv.attributes.dataset.node == id;
        } else {
          if (jsonDiv.children) {
            // loop through children
            _.each(jsonDiv.children, function (child) {
              if (hasNode(child, id)) {
                found = true;
                return false;
              }
            });
          }
        }

        return found;
      };

      var r = undefined;
      this.eachPanel(function (panel, panelName) {
        if (hasNode(panel, id)) {
          r = panelName;
          return false;
        }
      });
      return r;
    } // Update the whole app with a name<->version component map

  }, {
    key: "updateVersions",
    value: function updateVersions(map) {
      var _this = this;

      // update modules and UIs
      var updateJson = function updateJson(json, id) {
        var newVersion = map[json.module];

        if (newVersion && newVersion != json.version && json.version != "*") {
          console.log('[*] updating ' + json.module + ' from ' + json.version + ' to ' + newVersion);
          json.version = newVersion;
        }
      };

      this.eachModule(updateJson);
      this.eachUI(updateJson); // update libs

      _.each(this.json.libs, function (version, name) {
        var newVersion = map[name];

        if (newVersion && newVersion != _this.json.libs[name] && _this.json.version != "*") {
          console.log('[*] updating ' + name + ' from ' + version + ' to ' + newVersion);
          _this.json.libs[name] = newVersion;
        }
      });

      return this; // for chaining
    } // Update the whole app components with a name<->dependencies map

  }, {
    key: "updateComponents",
    value: function updateComponents(dmap) {
      var _this2 = this;

      if (!dmap) {
        console.error("Dependencies map is mandatory in updateComponents.");
        return;
      } // will gather all lib dependencies


      var libDeps = {}; // recursively add library dependencies

      var addLibDeps = function addLibDeps(lib) {
        _.each(dmap[lib], function (version, sublib) {
          if (libDeps[sublib] && libDeps[sublib] !== version) {
            console.error(('[*] Error while updating app libs : lib ' + lib + ' depends on lib ' + sublib + " in version " + version + " while another package uses version " + libDeps[sublib]).red);
          } else if (!libDeps[sublib] && sublib.startsWith('@dualbox/')) {
            console.log(lib + ' require ' + sublib);
            libDeps[sublib] = version;
            addLibDeps(sublib);
          }
        });
      }; // update modules and UIs


      var updateJson = function updateJson(json, id) {
        _.each(dmap[json.module], function (version, libname) {
          if (libDeps[libname] && libDeps[libname] !== version) {
            console.error(('[*] Error while updating app libs : module ' + json.module + ' depends on lib ' + libname + " in version " + version + " while another package uses version " + libDeps[libname]).red);
          } else if (!libDeps[libname] && libname.startsWith('@dualbox/')) {
            console.log(json.module + ' require ' + libname);
            libDeps[libname] = version;
            addLibDeps(libname);
          }
        });
      };

      this.eachModule(updateJson);
      this.eachUI(updateJson); // if not present, add native types

      var natives = ["@dualbox/dualbox-type-number", "@dualbox/dualbox-type-boolean", "@dualbox/dualbox-type-string", "@dualbox/dualbox-type-array", "@dualbox/dualbox-type-object", "@dualbox/dualbox-type-buffer", "@dualbox/dualbox-type-map", "@dualbox/dualbox-type-json", "@dualbox/dualbox-type-regexp", "@dualbox/dualbox-type-nativearray"]; // remove unecessary libs

      _.each(this.json.libs, function (version, name) {
        if (!libDeps[name] && natives.indexOf(name) == -1) {
          console.log('[*] removing lib ' + name);
          delete _this2.json.libs[name];
        }
      }); // add the missing one


      _.each(libDeps, function (version, name) {
        if (_this2.json.libs && !_this2.json.libs[name]) {
          console.log("[*] adding lib " + name);
          _this2.json.libs[name] = version;
        }
      });

      _.each(natives, function (n) {
        if (_this2.json.libs && !_this2.json.libs[n]) {
          _this2.json.libs[n] = "*";
        }
      });

      return this; // for chaining
    }
  }, {
    key: "getDependencies",
    value: function getDependencies() {
      var _this3 = this;

      var deps = {
        lib: {
          'babelify': "^10.0.0",
          '@babel/core': "^7.2.2",
          '@babel/preset-env': "^7.3.1",
          'browserify-css': "*",
          'rollupify': "^0.3.9"
        },
        module: {},
        ui: {}
      };
      this.eachModule(function (json, id) {
        if (deps.module[json.module] && deps.module[json.module] !== json.version) {
          console.error(('[*] Error while parsing app definition: module ' + json.module + ' exists in version ' + deps.module[json.module] + " and in version " + json.version).red);
        }

        if (_this3.isDualboxPackage(json.module)) {
          deps.module[json.module] = json.version;
        }
      });
      this.eachUI(function (json, id) {
        if (deps.ui[json.module] && deps.ui[json.module] !== json.version) {
          console.error(('[*] Error while parsing app definition: UI ' + json.module + ' exists in version ' + deps.ui[json.module] + " and in version " + json.version).red);
        }

        deps.ui[json.module] = json.version;
      }); // parse libs for dependencies

      _.each(this.json.libs, function (version, name) {
        deps.lib[name] = version;
      });

      return deps;
    }
  }, {
    key: "getDevDependencies",
    value: function getDevDependencies() {
      var deps = this.getDualboxDependencies();
      deps.lib['babelify'] = "^10.0.0";
      deps.lib['@babel/core'] = "^7.2.2";
      deps.lib['@babel/preset-env'] = "^7.3.1";
      deps.lib['browserify-css'] = "*";
      deps.lib['rollupify'] = "^0.3.9";
      return deps;
    }
  }]);

  return AppParser;
}();

module.exports = AppParser;
