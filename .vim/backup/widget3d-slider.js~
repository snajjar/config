import { $, env, Widget3D, Type } from '@dualbox/dualbox';
import { SphereBufferGeometry, BufferTriGeometry, BufferGeometry, Geometry, Mesh, MeshBasicMaterial, Object3D, Segment3, Vector3} from '@dualbox/dualbox-lib-xthree';
var pkgDesc = require('../package.json');

var DualboxTypesAll3D = require('@dualbox/dualbox-type-all3d');

var specialBindings = {
    slide:true
};

var pAOV = Widget3D.pushArrObjVal;
var rmIAO = Widget3D.rmIdxInArrObj;

/**
 *  Widget to set and move position on a scene mesh.
 *
 *  Improvement notes :
 *      - add possibility to restrict the sliding to some objects in the scene.
 *        It could be an input array of mesh names on which sliding is allowed.
 */
class Widget3DSlider extends Widget3D {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options);

         // clone appDesc to be able to redefine the special events.
        this.appDesc = JSON.parse(JSON.stringify(this.appDesc));
        var evts = this.appDesc.attr.mouse || {};
        var to_rm = {};
        var that = this;
        Object.keys(evts).forEach(function (key) {
            for(var i=0; i<evts[key].length; ++i){
                var bind = evts[key][i];
                var buffered = key.search("buffered") === 0;
                var buff_tag = "";
                if(buffered){
                    var seq = key.split("_");
                    buff_tag = seq[0]+"_";
                    key = key.replace(buff_tag,"");
                }
                if(specialBindings[bind]){
                    pAOV(to_rm,buff_tag+key,i);
                    switch(bind){
                        case "slide":
                            {
                                var touch = key.search("touchstart") !== -1;
                                var butt = touch || key[9] === ":" || key[9] === undefined ? "" : key[9];
                                // Number of touches, if relevant
                                var nt = touch && key.length > 10 ? key[10] : "";
                                if( (key.search("mousedown") === -1 ||  (butt !== "0" && butt !== "1" && butt !=="2")) && !touch){
                                    throw "Error : Widget3DSlider special binding 'slide' has not been made to handle something else than mousedown0, mousdown1 or mousdown2 and touchstart. Please refer to documentation.";
                                }
                                var st_evt = buff_tag+(touch ? "touchstart" : "mousedown") + nt;
                                var stop_evt = buff_tag+(touch ? "touchend" : "mouseup") + nt;
                                var mv_evt = buff_tag+(touch ? "touchmove" : "mousemove") + nt;

                                pAOV(evts,st_evt+butt+":widget:"+that.id,"initSlide");
                                pAOV(evts,mv_evt,"runSlide");
                                pAOV(evts,stop_evt+butt,"stopSlide");
                            }
                        break;
                        default:
                            throw "Error : bind "+bind+" is in the special binding list but is not recognized in the constructor.";
                        break;
                    }
                }
                key = buff_tag + key;
            }
        });

        // remove all the special bindings that have been found
        Object.keys(to_rm).forEach(function (key) {
            var arr = to_rm[key];
            for(var i=0; i<arr.length; ++i){
                rmIAO(evts, key, i);
            }
        });

        var tag = 'mousemove';
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageHover");

        if(this.attr.step === 0){
            this.attr.step = (this.attr.max-this.attr.min)/100;
        }

        this.val = this.attr.value;
    }

    init3D(){

        this.inputPersist = {
            visible:true
        };

        this.seg = new Segment3(new Vector3(), new Vector3());
        this.segTrans = new Segment3(new Vector3(), new Vector3());

        this.mat = new MeshBasicMaterial({color:0x000099});
        this.matHover = new MeshBasicMaterial({color:0x009900});

        // Mesh for the pointer of the slider.
        this.ptrMesh = new Mesh(
            new BufferTriGeometry(), // shape input
            this.mat
        );
        this.ptrMesh.name = this.id+"#"+"ptrmesh";
        this.ptrMesh.visible = this.visible;

        this.canvas3d.widgetGroup.add(this.ptrMesh);

        this.sliding = null;
    }

    computeVisibility(){
        this.ptrMesh.visible = this.visible && this.inputPersist.visible;
    }

    setPersistentInputValues(){
        var that = this;

        var pin = this.inputPersist;

        var persKeys = ["shape","seg","mat","matHover","matrix","visible"];
        persKeys.forEach(function (key) {
            if( that.inputValid[key] ){
                pin[key] = that.inputValue[key];
            }
        });

        this.ptrMesh.geometry.copy(pin.shape);

        this.segTrans.copy(pin.seg).applyMatrix4(pin.matrix);

        this.ptrMesh.position.lerpVectors(
            this.segTrans.start,
            this.segTrans.end,
            this.val/(this.attr.max-this.attr.min)
        );

        this.computeVisibility();
    }

    hide(){
        super.hide();
        this.computeVisibility();
    }
    show(){
        super.show();
        this.computeVisibility();
    }

    import(val) {
        this.val = Type.deserialize(val);
        this.trigger({ "x" : this.val });
        this.override = null;
    }

    manageHover(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.sliding){
            if(under.on[0] === "widget" && under.on[1] === this.id){
                this.ptrMesh.material = this.matHover;
            }else{
                this.ptrMesh.material = this.mat;
            }
        }
        event.cvs3dEvent.doPropagate();
    }

    // API Function
    initSlide(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(under.on[0] !== "widget" && under.on[1] !== this.id){
            throw "Error : cannot slide position since the clicked element is not the expected widget ("+this.id+").";
        }else{
            this.canvas3d.enslaveWidget3D(this);
            this.sliding = true;
            this.trigger({ "x" : this.val }); // useless??
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runSlide(event){
        if(this.sliding){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            var onray = new Vector3();
            var onseg = new Vector3();
            ray.distanceSqToSegment( this.segTrans.start, this.segTrans.end, onray, onseg );

            var t = (new Vector3()).subVectors(onseg, this.segTrans.start).length() / this.segTrans.length();

            this.val = t*(this.attr.max-this.attr.min);
            this.val = Math.max(
                Math.min(this.val, this.attr.max),
                Math.round( (this.val-this.attr.min) / this.attr.step ) * this.attr.step
            );

            this.ptrMesh.position.lerpVectors(
                this.segTrans.start,
                this.segTrans.end,
                this.val/(this.attr.max-this.attr.min)
            );

            if(this.attr.triggerOnSlide){
                this.trigger({ "x" : this.val });
            }
        }
    }

    // API Function
    stopSlide(event){
        if(this.sliding){
            this.canvas3d.freeWidget3D(this);
            this.sliding = false;
            if(!this.attr.triggerOnSlide){
                this.trigger({ "x" : this.val });
            }
        }
    }

    onReady() {

        this.setPersistentInputValues();

        this.emit('data', { "x" : this.val });

    }

    static attachTo(appDesc, attrs, div) {
        var dt = new Widget3DSlider(pkgDesc, appDesc, attrs);
        return dt;
    }
}

module.exports = Widget3DSlider;
