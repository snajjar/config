var fs = require('fs-extra');
var path = require('path');
var _ = require('lodash');
var colors = require('colors');

var browserify = require('browserify');
var babelify = require('babelify');
var browserifycss = require('browserify-css');
var rollupify = require('rollupify');
var uglifyify = require('uglifyify');
var uglify = require('uglify-js');

// Mecanism to add transform links to this repository when it's missing
var transforms = ["babelify", "browserify-css", "rollupify", "imgurify", "svgify", "uglifyify", "@babel/core", "@babel/preset-env", "urify", "treeify" ];
var transformLinks = [];
var ensureTransforms = function(component) {
    var pkg = require(component + '/package.json');

    _.each( transforms, (transform) => {
        var hasTransform =
            (pkg.dependencies && pkg.dependencies[transform]) ||
            (pkg.devDependencies && pkg.devDependencies[transform]);

        if( hasTransform ) {
            var componentPath = path.dirname(require.resolve(component+'/package.json'));

            // ensure node_modules exists
            fs.ensureDirSync(path.join(componentPath, "node_modules"));
            var linkPath = path.join(componentPath, "node_modules", transform);

            if( transform.indexOf('@babel/') != -1 ) {
                fs.ensureDirSync( path.join(componentPath, "node_modules", "@babel") );
            }

            var targetTransform = path.join(process.cwd(), "node_modules", transform);

            if( !fs.existsSync(linkPath) ) {
                // create a symlink to the root node_modules
                console.log(('{*] Missing dependency "' + component + '" from ' + componentPath +
                    ': creating temporary symlink to build folder').yellow);
                fs.symlinkSync(targetTransform, linkPath, 'dir');
                transformLinks.push(linkPath);
            }
        }
   });
}

var cleanTransforms = function() {
    _.each(transformLinks, (linkPath) => {
        fs.removeSync(linkPath);
    });
}

var browserifyBuild = function(args, component, version, buildDir, cwd) {
    // path for browserify to look for modules (will also look on global npm folder, as we did set NODE_PATH)
    var outputFile = path.join(cwd, args['o']);
    var sourcePaths = process.env['NODE_PATH'].split(':') || [];
    sourcePaths.push(path.join(buildDir, "node_modules"));
    var debug = args['debug'] !== undefined;
    var minify = !debug || args['minify']==true;

    // create browserify with options
    var opts = {
        'fullPaths' : !debug,
        'debug' : debug,
        'paths' : sourcePaths, // search for modules in spm cache path
        'baseDir' : buildDir,
        'browserField' : true
    }
    var b = browserify(null, opts);

    // compute externals (all dependencies that starts with @dualbox)
    var externals = [];
    var pkg = require(component + "/package.json");
    _.each( pkg.dependencies, (version, name) => {
        if( name.startsWith('@dualbox') ) {
            externals.push(name);
        }
    });
    _.each( pkg.devDependencies, (version, name) => {
        if( name.startsWith('@dualbox') ) {
            externals.push(name);
        }
    });
    _.each( pkg.optionalDependencies, (version, name) => {
        if( name.startsWith('@dualbox') ) {
            externals.push(name);
        }
    });
    b.external(externals);

    ensureTransforms(component);
    b.require(component, { paths: sourcePaths });

    b.transform(rollupify, { global: true });

    // apply babelify - UNECESSARY: should be done at build time
    b.transform(babelify, { presets: ['@babel/preset-env'], compact: false, global: true })

    // apply browserify-css transform
    b.transform(browserifycss, { autoInject: true, global: true })

    // if not built in debug mode, minify the bundle
    // apply uglifyjs transform AND apply uglify transform at the end
    if( minify ) {
        // pre-transform for compression
        b.transform('uglifyify', { global: true, sourceMap: false });
    }

    // build bundle
    return new Promise((resolve, reject) => {
        try {
            var outputStream = fs.createWriteStream(outputFile);
            var onError = function(err) {
                cleanTransforms();
                reject(err);
            };

            if( minify ) {
                b.bundle(function(err, buf) {
                    if( err ) {
                        onError(err);
                        return;
                    }

                    // minify the result
                    var minified = uglify.minify(buf.toString());
                    outputStream.write(minified.code);
                    outputStream.end();
                });
            }
            else {
                b.bundle().pipe(outputStream);
            }

            outputStream.on('finish', () => {
                cleanTransforms();
                resolve();
            });
        }
        catch(e) {
            reject(e);
        }
    });
}

process.on('message', async message => {
    try {
        var result = await browserifyBuild(message.args, message.component, message.version, message.buildDir, message.cwd );
        process.send("");
    }
    catch(e) {
        console.error(e.message.red);
        console.error(e.stack.red);
        process.exit(-1);
    }
});


