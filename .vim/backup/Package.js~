/**
 *  Class to handle DualBox packages
 */
var colors = require('colors');
var cp = require('child_process');
var path = require('path');
var _ = require('lodash');
var fs = require('fs-extra');
var crypto = require('crypto');
var semver = require('semver');

// local stuff
var dpmJson = require('@dualbox/dualbox-dpm/package.json');
var YarnClient = require('./YarnClient');
var NpmClient = require('./NpmClient');

// build stuff
var browserify = require('browserify');
var browserifycss = require('browserify-css');
var rollupify = require('rollupify');
var imgurify = require('imgurify');
var babelify = require('babelify');

// return the full path of the folder
function absolutePath(p) {
    if( path.isAbsolute(p) ) {
        return p;
    }
    return path.join(process.cwd(), p );
}

function relativePath(p) {
    if( path.isAbsolute(p) ) {
        return path.relative(process.cwd(), p);
    }
    return p;
}

function findFilesInDir(startPath, filter){
    var results = [];

    var isExcluded = function(filename) {
        var exclude = [ "node_modules", "dist", "standalone", ".orig", "package.json" ];
        var isExcluded = false;
        _.each(exclude, function(ex) {
            if( filename.indexOf(ex) !== -1 ) {
                isExcluded = true;
            }
        });
        return isExcluded;
    }

    if (!fs.existsSync(startPath)){
        console.error("path " + startPath + " doesnt exist from " + process.cwd());
        return [];
    }

    var files=fs.readdirSync(startPath);
    for(var i=0;i<files.length;i++){
        var filename=path.join(startPath,files[i]);
        var stat = fs.lstatSync(filename);
        if (stat.isDirectory()) {
            if( !isExcluded(filename) ) {
                results = results.concat(findFilesInDir(filename,filter));
            }
        }
        else if(!isExcluded(filename) && filename.indexOf(filter)>=0) {
            results.push(filename);
        }
    }
    return results;
}

// take a group of files and extract the hash
var makeFileHash = function( files ) {
    var hash = crypto.createHash("sha1");
    _.each(files, function(file, i) {
        var str = fs.readFileSync(file, "utf8");
        str = str.replace(/[\n\r]/g, ''); // avoid EOF/CLRF differences between win/unix systems while computing hashes
        hash.update( str );
    });
    return hash.digest('hex');
}

// make hash from a group of strings
var makeStringHash = function( strings ) {
    var hash = crypto.createHash("sha1");
    _.each(strings, function(string, i) {
        if( string !== undefined ) {
            hash.update( string );
        }
    });
    return hash.digest('hex');
}

// return an array of folders in directory
function getFolders(dir) {
    return fs.readdirSync(dir).filter(function(file) {
        if( file[0] != "." ) {
            try {
                var stat = fs.statSync(path.join(dir, file));
                return stat.isDirectory();
            }
            catch(e) {
                return false;
            }
        }

        return false;
    });
}

function execSync(cmd, options) {
    if( !options ) options = {};

    var output = cp.execSync(cmd, options);
    if( output ) {
        var outputStr = output.toString('utf8');
        outputStr = outputStr.substr(0, outputStr.length-1); // remove the \n
        return outputStr;
    }
    else {
        return null;
    }
}

class Package {
    constructor(p) {
        this.rootPath = absolutePath(path.join(__dirname, ".."));
        this.path     = relativePath(path.join(this.rootPath, relativePath(p)));
        this.absPath  = absolutePath(path.join(this.rootPath, this.path));

        try {
            this.pkg  = require(path.join(this.absPath, "package.json"));
        }
        catch(e) {
            console.error(("Folder " + this.absPath + " has no package.json. Do you mind fixing it?").red);
            throw e;
        }

        this.yarn = new YarnClient(this.absPath);
        this.npm  = new NpmClient(this.absPath);

        this.name = this.pkg.name;
        if( this.name.indexOf('/') !== 0 ) {
            this.subName = this.name.split('/')[1];
        }
    }

    isMain() {
        // check if this.absPath is inside this.rootPath
        // if not, it's a customer's package
        var relative = path.relative(this.rootPath, this.absPath);
        return (relative && !relative.startsWith('..') && !path.isAbsolute(relative));
    }

    script(cmd) {
        return this.yarn.run(cmd);
    }


    findFiles() {
       var files = findFilesInDir(this.absPath, ".js");
       files = files.concat( findFilesInDir(this.absPath, ".css") );
       files = files.sort(); // sort files to guarantee order
       return files;
    }

    lint() {
        if( this.pkg.scripts.lint ) {
            console.log(('[*] linting ' + this.name).green);
            var ret = this.script("lint");
            if( ret.code !== 0 ) {
                console.log(('[*] linting ' + this.name + ' failed').red);
                console.log(ret.stdout);
            }
        }
        else {
            console.log(('[*] ' + this.name + ' has no lint setup defined').yellow);
        }
    }

    execSync(cmd, options) {
        if( !options ) options = {};

        // set path for the command
        if( !options.cwd ) {
            options.cwd = this.absPath;
        }

        return execSync(cmd, options);
    }

    isRequirable() {
        try {
            require(this.name);
            return true;
        }
        catch(e) {
            return false;
        }
    }

    isGloballyInstalled() {
        var npmFolder = this.yarn.getPrefix();
        var libFolder = path.join(npmFolder, 'lib', 'node_modules');
        var dualboxFolder = path.join(libFolder, '@dualbox');

        if( !fs.existsSync(dualboxFolder) ) {
            console.log('dualbox folder not here');
            return false;
        }
        else {
            var linkPath = path.join(dualboxFolder, this.subName);
            if( !fs.existsSync(linkPath) ) {
                return false;
            }
            else {
                // we want a symlink to this package
                var stats = fs.lstatSync(linkPath);
                if( !stats.isSymbolicLink() ) {
                    return false
                }
                else {
                    var linkTarget = fs.readlinkSync(linkPath);
                    var absLinkTarget = path.join(dualboxFolder, linkTarget);
                    if( absLinkTarget != this.absPath ) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    hasDependency(name) {
        return (this.pkg.dependencies && this.pkg.dependencies[name] !== undefined);
    }

    hasDevDependency(name) {
        return (this.pkg.devDependencies && this.pkg.devDependencies[name] !== undefined);
    }

    // Add a dependency to another package
    addDependency( p ) {
        this.pkg.dependencies[ p.name ] = "^" + p.pkg.version;
        this.writePackageFile();
    }

    addExternalDependency( name, version, devDependency ) {
        var v = version == "latest" ? "^" + this.yarn.infoPkg(name).version : "version";
        console.log(this.name + ' : adding dependency to ' + name + ':' + v);

        if( devDependency ) {
            if( !this.pkg.devDependencies ) this.pkg.devDependencies = {};
            this.pkg.devDependencies[ name ] = v;
        }
        else {
            if( !this.pkg.dependencies ) this.pkg.dependencies = {};
            this.pkg.dependencies[ name ] = v;
        }
        this.writePackageFile();
    }

    removeExternalDependency( name ) {
        console.log(this.name + ' : removing dependency from ' + name);
        if( this.pkg.dependencies ) {
            delete this.pkg.dependencies[ name ];
        }
        if( this.pkg.devDependencies ) {
            delete this.pkg.devDependencies[ name ];
        }
        this.writePackageFile();
    }

    writePackageFile() {
        fs.writeFileSync( path.join(this.absPath, "package.json"), JSON.stringify(this.pkg, null, 2), 'utf-8');
    }

    getDualBoxDependencies(version = null) {
        var pkgInfo = version==null ? this.pkg : this.getPkgInfos(version);
        if( pkgInfo === null ) {
            return {};
        }

        var deps = {};
        _.each( pkgInfo.dependencies, (version, name) => {
            if( name.startsWith('@dualbox/') ) {
                if( version.startsWith('^') ) version = version.substring(1);
                deps[name] = version;
            }
        });
        return deps;
    }

    setup() {
        return this.yarn.setup();
    }

    installDeps() {
        var deps = Object.assign({}, this.pkg.dependencies, this.pkg.devDependencies);

        // link to all dualbox modules
        _.each(deps, (version, dep) => {
            if( dep.startsWith('@dualbox/') ) {
                this.yarn.link(dep);
                try {
                    require(dep);
                }
                catch(e) {
                    console.log(('    [*] could not require dependency: ' + dep + '.').red);
                }
            }
        });

        // then just run yarn
        this.yarn.installAll();
    }

    ensureNoBabel6() {
        var localNpmFolder = path.join(this.path, 'node_modules');
        fs.readdir(localNpmFolder, (err, files) => {
            if( files ) {
                files.forEach(file => {
                    if( file == "babel" || file.startsWith('babel-') ) {
                        fs.removeSync( path.join(localNpmFolder, file) );
                    }
                });
            }
        });
    }

    /*
     *  Browserify transforms should be set in the "node_modules" folder of each package.
     *  That's an ugly browserify mistake, but we have to build with it.
     *  This function ensure we have a symbolic link to the main node_module folder for each transform
     */
    ensureTransforms() {
        this.ensureNoBabel6();

        var transforms = [ "babelify", "@babel/core", "@babel/preset-env", "@babel/cli", "cssify", "browserify-css", "rollupify", "imgurify", "treeify", "urify" ];
        _.each( transforms, (transform) => {
            if( this.hasDependency(transform) || this.hasDevDependency(transform) ) {
                // ensure node_modules exists
                fs.ensureDirSync(path.join(this.path, "node_modules"));
                var linkPath = path.join(this.path, "node_modules", transform);

                if( transform.indexOf('@babel/') != -1 ) {
                    fs.ensureDirSync( path.join(this.path, "node_modules", "@babel") );
                }

                if( !fs.existsSync(linkPath) ) {

                    // create a symlink to the root node_modules
                    fs.symlinkSync(
                        path.join(this.rootPath, "node_modules", transform), // target
                        linkPath,
                        'dir'
                    );
                }
                else {

                    // we prefer a symbolic link to a direct install
                    var stats = fs.lstatSync(linkPath);
                    if( !stats.isSymbolicLink() ) {
                        fs.removeSync( linkPath  );
                        fs.symlinkSync(
                            path.join(this.rootPath, "node_modules", transform), // target
                            linkPath,
                            'dir'
                        );
                    }
                    else {
                        var linkTarget = fs.readlinkSync(linkPath);
                        if( !linkTarget || !fs.existsSync(linkTarget) ) {
                            fs.removeSync( linkPath );
                            fs.symlinkSync(
                                path.join(this.rootPath, "node_modules", transform), // target
                                linkPath,
                                'dir'
                            );
                        }
                    }
                }
            }
        });
    }

    getLinkAbsPath( linkPath ) {
        return fs.realpathSync(fs.readlinkSync(linkPath));
    }

    checkInstall() {
        return this.checkLocalInstall() && this.checkGlobalInstall();
    }

    // check if package is correctly installed (on local dualbox root)
    checkLocalInstall() {
        var localNpmPath = path.join(process.cwd(), 'node_modules', this.name);
        if( fs.existsSync(localNpmPath) ) {
            if( fs.lstatSync(localNpmPath).isSymbolicLink() ) {
                var linkTarget = fs.readlinkSync(localNpmPath);
                var absLinkTarget = path.join(path.dirname(localNpmPath), linkTarget);
                return this.absPath == absLinkTarget;
            }
        }
        return false;
    }

    // check if package is correctly installed (on npm global dir)
    checkGlobalInstall() {
        var globalNpmPath = path.join(execSync("npm root", { silent: true }).trim(), this.name);
        if( fs.existsSync(globalNpmPath) ) {
            if( fs.lstatSync(globalNpmPath).isSymbolicLink() ) {
                var linkTarget = fs.readlinkSync(globalNpmPath);
                var absLinkTarget = path.join(path.dirname(globalNpmPath), linkTarget);
                return this.absPath == absLinkTarget;
            }
        }
        return false;
    }

    removeLocalLink() {
        var localNpmPath = path.join(process.cwd(), 'node_modules', this.name);
        fs.removeSync(localNpmPath);
    }

    removeGlobalLink() {
        var globalNpmPath = path.join(execSync("npm root", { silent: true }).trim(), this.name);
        fs.removeSync(globalNpmPath);
    }

    setLocalLink() {
        var localNpmPath = path.join(process.cwd(), 'node_modules', this.name);
        fs.symlinkSync(this.absPath, localNpmPath, 'dir');
    }

    setGlobalLink() {
        var globalNpmPath = path.join(execSync("npm root", { silent: true }).trim(), this.name);
        fs.symlinkSync(this.absPath, globalNpmPath, 'dir');
    }

    removeBabel6() {
        var localNpmPath = path.join(this.path, 'node_modules', '@dualbox');
        if( fs.existsSync(localNpmPath) ) {
            getFolders(localNpmPath).map((d) => {
                var linkPath = path.join(localNpmPath, d);
                if( d.startsWith('babel-') ) {
                    fs.removeSync(linkPath);
                }
            })
        }
    }

    fixLocalDualboxDependencies() {
        /*
        var localNpmPath = path.join(this.path, 'node_modules', '@dualbox');
        if( fs.existsSync(localNpmPath) ) {
            getFolders(localNpmPath).map((d) => {
                var linkPath = path.join(localNpmPath, d);

                // we want a symlink to this package
                var stats = fs.lstatSync(linkPath);
                if( !stats.isSymbolicLink() ) {
                    fs.removeSync(linkPath);
                    fs.symlinkSync(
                        path.join(this.rootPath, "node_modules", "@dualbox", d), // target
                        linkPath,
                        'dir'
                    );
                }
            });
        }
        */

        var localNpmPath = path.join(this.path, 'node_modules', '@dualbox');
        if( fs.existsSync(localNpmPath) ) {
            fs.removeSync(localNpmPath);
        }
        fs.ensureDirSync(localNpmPath);

        // for each dependency, recreate the good link
        _.each(this.pkg.dependencies, (version, name) => {
            if( name.startsWith('@dualbox') ) {
                var p = Package.fromName(name);

                fs.symlinkSync(
                    p.absPath, // target
                    path.join(localNpmPath, name.replace('@dualbox/', '')),
                    'dir'
                );
            }
        });

        _.each(this.pkg.optionalDependencies, (version, name) => {
            if( name.startsWith('@dualbox') ) {
                var p = Package.fromName(name);

                fs.symlinkSync(
                    p.absPath, // target
                    path.join(localNpmPath, name.replace('@dualbox/', '')),
                    'dir'
                );
            }
        });
    }

    repairInstall() {
        if( !this.checkLocalInstall() ) {
            this.removeLocalLink();
            this.setLocalLink();
        }

        if( !this.checkGlobalInstall() ) {
            this.removeGlobalLink();
            this.setGlobalLink();
        }

        this.fixLocalDualboxDependencies();
        this.removeBabel6();
    }

    repair() {
        this.repairInstall();
        this.ensureTransforms();
    }

    removeNMFolder() {
        fs.removeSync( path.join(this.path, "node_modules") );
    }

    install(force = false) {
        var installHashFile = path.join(this.path, ".installhash");
        var newInstallHash = this.installHash();

        var needInstall = force || !this.isRequirable() || !this.isGloballyInstalled();
        if( needInstall ) {
            try {
                // install and link manually all dependencies
                // If it's a dualbox package, link it. Otherwise, install it
                console.log(("[*] installing " + this.pkg.name + " packages...").green);

                if( force ) {
                    this.removeNMFolder();
                }

                this.installDeps();

                // extract all install hash
                fs.writeFileSync( installHashFile, newInstallHash );
                console.log(("    [*] install hash: " + newInstallHash).green);

                // build if needed
                this.buildNode();

                // then, remove all the dualbox-related stuff in the node_modules for linking
                // cleanFolderNodeModule(folder);

                // finally, link the folder
                this.link();
            }
            catch(e) {
                console.error('Error during installation of ' + this.pkg.name);
                console.error(e);
            }
        }
        else {
            // ensure we have a direct symlink for our transforms
            console.log(("[*] no need to install " + this.pkg.name + " : already up to date").yellow);
        }

        // ensure we have a direct symlink for our transforms
        this.ensureTransforms();

        // check if install worked
        if( !this.isRequirable() ) {
            console.error(('    [*] installation of ' + this.pkg.name + ' failed: package is not requirable').red);
        }
    }

    link() {
        this.updateDeps();

        // link folder dependencies
        console.log(("[*] installing links for folder " + this.path).green);
        _.each( this.pkg.dependencies, (version, depName) => {
            if( depName.startsWith('@dualbox/') ) {
                console.log(("    [*] linking locally " + depName).grey);
                this.yarn.link(depName);
            }
        });

        // publish the folder on the local yarn filesystem
        console.log(("    [*] publishing " + this.path + " globally..").green);
        this.yarn.publishLink();

        // link to project root folder
        console.log(("    [*] linking " + this.path + " to project root...").green);
        this.yarn.publishLink(path.join(this.rootPath, "node_modules"));

        // link to yarn global path
        console.log(("    [*] linking " + this.path + " to yarn root...").green);
        this.yarn.publishLink(Repo.instance().nmPath);
    }

    upload() {
        console.log('[*] Uploading ' + this.pkg.name.green + ' version ' + this.pkg.version.green);
        this.execSync('dpm upload', { silent: true });
        this.execSync('dpm upload --debug', { silent: true });
    }

    uninstall() {
        console.log(('[*] uninstalling ' + this.path).green);
        _.each( this.pkg.dependencies, (depVersion, depName) => {
            if( depName.startsWith('@dualbox/') ) {
                try {
                    this.yarn.unlink(depName);
                }
                catch(e) {}
            }
        });
        try {
            this.yarn.unPublish();
        }
        catch(e) {}

        fs.removeSync( path.join( this.absPath, "node_modules") );
        if( fs.existsSync( path.join( this.absPath, ".installhash") ) ) {
            fs.removeSync( path.join( this.absPath, ".installhash") );
        }
        if( fs.existsSync( path.join( this.absPath, "dist", ".sourcehash") ) ) {
            fs.removeSync( path.join( this.absPath, "dist", ".sourcehash") );
        }
    }


    // version: check current version if no version provided
    isPublished(version = null) {
        version = version ? version : this.pkg.version;
        var registryPKG = this.getPkgInfos();
        if( registryPKG === null ) return false;
        return registryPKG.versions.indexOf(version) !== -1;
    }

    // get the last published version
    getCurrentVersion() {
        var registryPKG = this.getPkgInfos();
        if( registryPKG === null ) {
            return "1.0.0";
        }

        return registryPKG.version;
    }

    // get the next non-published version patch
    getNextVersion() {
        var registryPKG = this.getPkgInfos();
        if( registryPKG === null ) {
            return "1.0.0";
        }

        var version = registryPKG.version;
        while( this.isPublished(version) ) {
            version = semver.inc(version, "patch");
        }

        return version;
    }

    checkPublished() {
        if( this.isPublished() ) {
            console.log(("    [*] " + this.name + " (v: " + this.pkg.version + ") is published").green);
        }
        else {
            console.warn(("    [*] " + this.name + " (v: " + this.pkg.version + ") isn't published yet").yellow);
        }
    }

    setLastVersion() {
        var pkg = JSON.parse(JSON.stringify(this.pkg));
        if( pkg.version == "1.0.0" ) {
            return; // faster in case of previous gulp install failed
        }

        var version = this.getCurrentVersion();
        if( pkg.version !== version ) {
            console.log('    [*] ' + this.name + ': ' + pkg.version + ' --> ' + version);
            pkg.version = version
            fs.writeFileSync( path.join(this.path, "package.json"), JSON.stringify(pkg, null, 2));
        }
        else {
            console.log('    [*] ' + this.name + ': ' + version + ' (unchanged)');
        }
        this.pkg = pkg;
    }

    // update package.json version based on the source hash
    setNextVersion(force = false, version = undefined) {
        var pkgInfo = this.getPkgInfos();

        if( pkgInfo && pkgInfo.hash !== this.hash() || force ) {
            // hash changed (or force is used), set the next version
            var pkg = JSON.parse(JSON.stringify(this.pkg));
            pkg.hash = this.hash();
            pkg.version = version ? version : this.getNextVersion();
            fs.writeFileSync( path.join(this.absPath, "package.json"), JSON.stringify(pkg, null, 2), 'utf-8');

            if( this.pkg.version !== pkg.version ) {
                console.log(('    [*] incremented ' + this.pkg.name + ' version to ' + pkg.version).green);
            }
            else {
                console.log('    [*] updated hash for ' + this.pkg.name + " (version " + pkg.version + ")");
            }
            this.pkg = pkg;
        }
        else {
            // set the last published version
            if( this.pkg.version !== pkgInfo.version ) {
                var pkg = JSON.parse(JSON.stringify(this.pkg));
                pkg.version = version ? version : pkgInfo.version;
                console.log('    [*] reset ' + this.pkg.name + ' version to ' + pkg.version);
                fs.writeFileSync( path.join(this.path, "package.json"), JSON.stringify(pkg, null, 2));
                this.pkg = pkg;
            }
        }
    }

    // update all dualbox dependencies
    updateDeps(verbose = true) {
        var update = false;

        var pkg = JSON.parse(JSON.stringify(this.pkg));
        _.each(pkg.dependencies, (depVersion, depName) => {
            if( depName.startsWith('@dualbox/') ) {
                var module = Repo.instance().getPackage(depName);
                var newVersion = module.pkg.version;
                if( depVersion !== newVersion ) {
                    if(verbose) console.log(('    [*] updating dependency to ' + depName + ' from ' + depVersion + ' to ' + newVersion).green);
                    pkg.dependencies[depName] = newVersion;
                    update = true;
                }
            }
        });

        _.each(pkg.optionalDependencies, (depVersion, depName) => {
            if( depName.startsWith('@dualbox/') ) {
                var module = Repo.instance().getPackage(depName);
                var newVersion = module.pkg.version;
                if( depVersion !== newVersion ) {
                    if(verbose) console.log(('    [*] updating dependency to ' + depName + ' from ' + depVersion + ' to ' + newVersion).green);
                    pkg.optionalDependencies[depName] = newVersion;
                    update = true;
                }
            }
        });

        // package.json has changed, compute new hash
        var hash = this.hash();
        if( pkg.hash !== hash ) {
            pkg.hash = hash;
            update = true;
        }

        if( update ) {
            fs.writeFileSync( path.join(this.absPath, "package.json"), JSON.stringify(pkg, null, 2), 'utf-8');
            this.pkg = pkg; // update current package not to revert the future updates
        }
    }

    update(force = false) {
        console.log('[*] checking versions for ' + this.name);
        this.updateDeps(true); // update deps before setting next version (if deps change => version bump)
        this.setNextVersion(false);
    }

    build(force) {
        return this.buildNode(force) && this.buildBrowser(force);
    }

    buildNode(force) {
        var buildHashFile = path.join(this.path, "dist", "node", ".sourcehash");
        var build = () => {
            // repair the module first to avoid any kind of failure due to npm/yarn weird behavior
            this.repair();

            console.log(('[*] building (node): ' + this.path).green);
            try {
                var ret = this.yarn.buildNode();
                if( ret.code !== 0 ) {
                    console.log(('[*] build (node) of ' + this.path + ' failed.').red);
                    console.log(ret.stderr);
                    return false;
                }
                else {
                    fs.writeFileSync(buildHashFile, this.hash());
                }
                return true;
            }
            catch(e) {
                console.error('Error building (node) ' + this.pkg.name + ' : ' + e);
                return false;
            }
        };

        // check if the folder needs to be built ('build' script present in package.json)
        if( this.pkg && this.pkg.scripts && this.pkg.scripts["build-node"] ) {
            // check if we have already built it (and we're not in a forced command)
            if( fs.existsSync(buildHashFile) && !force ) {
                // check if the build hash is the same as the actual sources
                var oldSourceHash = fs.readFileSync(buildHashFile);
                var newSourceHash = this.hash();

                if( oldSourceHash != newSourceHash ) {
                    // we need to rebuild
                    return build();
                }
                else {
                    console.log(('[*] no need to build (node): ' + this.path).yellow);
                }
                return true;
            }
            else {
                return build();
            }
        }
        else {
            return true;
        }
    }

    buildBrowser(force) {
        var buildHashFile = path.join(this.path, "dist", "browser", ".sourcehash");
        var buildBrowser = () => {
            console.log(('[*] building (browser): ' + this.path).green);
            try {
                var ret = this.yarn.buildBrowser();
                if( ret.code !== 0 ) {
                    console.log(('[*] build (browser) of ' + this.path + ' failed.').red);
                    console.log(ret.stderr);
                    return false;
                }
                else {
                    fs.writeFileSync(buildHashFile, this.hash());
                }
                return true;
            }
            catch(e) {
                console.error('Error building (browser) ' + this.pkg.name + ' : ' + e);
                return false;
            }
        };

        // check if the folder needs to be built ('build' script present in package.json)
        if( this.pkg && this.pkg.scripts && this.pkg.scripts["build-browser"] ) {
            // check if we have already built it (and we're not in a forced command)
            if( fs.existsSync(buildHashFile) && !force ) {
                // check if the build hash is the same as the actual sources
                var oldSourceHash = fs.readFileSync(buildHashFile);
                var newSourceHash = this.hash();

                if( oldSourceHash != newSourceHash ) {
                    // we need to rebuild
                    return buildBrowser();
                }
                else {
                    console.log(('[*] no need to build (browser): ' + this.path).yellow);
                }
                return true;
            }
            else {
                return buildBrowser();
            }
        }
        else {
            return true;
        }
    }

    browserify(targetStream, done) {
        // extract all dualbox components names
        // they shall be built only 1 time
        // so we'll pass this array as externals to browserify
        var components = Object.keys(Repo.instance().getPackages());
        components = components.filter(val => val.indexOf('@dualbox/') == 0);

        // browserify our module
        var b = browserify({ debug: true, fullPaths: true})
            .external( _.without(components, this.pkg.name) )
            .require(this.pkg.name)
            .transform(rollupify)
            .on('error', function(err) {
                done(err);
            })
            .transform(babelify, { presets: ['@babel/preset-env'], compact: false })
            .on('error', function(err) {
                done(err);
            })
            .transform(browserifycss, { autoInject: true, global: true })
            .on('error', function(err) {
                done(err);
            })
            .transform("imgurify")
            .on('error', function(err) {
                done(err);
            })
            .bundle()
            .on('error', function(err) {
                done(err);
            })
            .pipe(targetStream)
            .on('error', function(err) {
                done(err);
            });
    }

    bump(force) {
        if( !Repo.instance().isLoggedInAsAdmin() ) {
            console.error('You must log in to npm registry as ADMIN USER'.red);
            throw new Error();
        }

        var registryPKG = this.getPkgInfos();
        if( !registryPKG || this.hash() !== registryPKG.hash || force ) {
            console.log(('[*] Publishing ' + this.pkg.name + " (version: " + this.pkg.version + ")").green);
            try {
                this.execSync('dpm publish', { silent: true });
            }
            catch(e) {
                var version = this.getNextVersion();
                console.log(('    [*] Publishing ' + this.pkg.name + ' failed. Updating version to "' + version + '" and retrying.').yellow);
                this.setNextVersion(true); // force update
                try {
                    this.execSync('dpm publish', { silent: true });
                    console.log(('[*] Published ' + this.pkg.name + " (version: " + this.pkg.version + ")").green);
                }
                catch(e) {
                    console.log(('[*] Publishing ' + this.pkg.name + ' failed.').red);
                }
            }
        }
        else {
            console.log(('[*] ' + this.pkg.name + " is matching the last published version (" + registryPKG.version + ")").yellow);
        }
    }

    // hash the sources
    sourceHash() {
        var files = findFilesInDir(this.absPath, ".js");
        files = files.concat( findFilesInDir(this.absPath, ".css") );
        files = files.sort(); // sort files to guarantee order
        return makeFileHash( files );
    }

    // hash the sources + package.json (without the "version" and "hash")
    hash( packageJson ) {
        var sourceHash = this.sourceHash();

        // clone the package.json but delete version and sourceHash
        var pkg = packageJson ? packageJson : JSON.parse(JSON.stringify(this.pkg));
        delete pkg.version;
        delete pkg.hash;

        return makeStringHash([sourceHash, JSON.stringify(pkg)]);
    }

    // installation hash
    installHash() {
        return makeStringHash([
            JSON.stringify(this.pkg.dependencies),
            JSON.stringify(this.pkg.devDependencies),
            JSON.stringify(this.pkg.otherDependencies)
        ]);
    }


    // infos from yarn info
    getPkgInfos(version) {
        if( !Repo.instance().isLoggedIn() ) {
            console.error('You must log in to npm registry'.red);
            throw new Error();
        }

        try {
            if( version ) {
                try {
                    var info = this.yarn.versionInfo(this.name, version);
                    return info;
                }
                catch(err) {
                    console.log("Error getting package infos of " + this.name + "@" + version + " : " + err);
                    console.log("trying with npm");
                    return this.npm.versionInfo(this.name, version);
                }
            }
            else {
                try {
                    var info = this.yarn.info();
                    return info;
                }
                catch(err) {
                    console.log("Error getting package infos of " + this.name + " : " + err);
                    console.log("trying with npm");
                    var info = this.npm.info();
                    if(!info){
                        throw "  npm got undefined info... wtf?";
                    }else{
                        return info;
                    }
                }
            }
        }
        catch(err) {
            console.log(" Failed with npm " + this.name + " : " + err);
            console.log("Retrying...");
            return this.getPkgInfos()
        }
    }

    // check if we can install the package from a path
    checkInstallable( p ) {
        fs.ensureDirSync(p);
        try {
            this.execSync('yarn add ' + this.name + ' -s --registry ' + dpmJson.registry, { cwd: p, stdio: ['pipe', 'pipe', 'ignore'] });
            console.log((this.name + ' is installable').green);
        }
        catch(e) {
            console.error((this.name + ' is not installable').red);
        }
    }

    // return a sha1 string identifying the package
    // if local is true, identify the local package. Otherwise, identify the last published version
    checksum(local = true) {
        if( local ) {
            return this.hash();
        }
    }

    static fromPath(p) {
        Package.setNodePath();

        if( fs.existsSync(path.join(p, "package.json")) ) {
            // get the absolute path
            if( !Package.instances[p] ) {
                Package.instances[p] = new Package(p);
            }
            return Package.instances[p];
        }
        else {
            console.error(('folder ' + p + ' has no package.json. Do you mind fixing it?').red);
            return null;
        }
    }

    static fromName(n) {
        Package.setNodePath();

        // find the path in the name
        try {
            var packageJsonPath = require.resolve(n + "/package.json");
            var rootPath = path.dirname( packageJsonPath );
            return Package.fromPath(rootPath);
        }
        catch(e) {
            console.error((n + " isn't an installed dualbox component").red);
            return null;
        }
    }

    // add the cache repository to the current NODE_PATH
    static setNodePath() {
        if( !Package.nodePath ) {
            var npmPath = execSync("npm get prefix", { silent: true }).trim();
            var nodePath1 = path.join(process.cwd(), 'node_modules');
            var nodePath2 = path.join(npmPath, 'lib', 'node_modules');
            var nodePath3 = path.join(npmPath, 'node_modules');

            var paths = process.env.NODE_PATH ? process.env.NODE_PATH.split(':') : [];
            if( paths.indexOf(nodePath1) === -1 ) paths.push( nodePath1 );
            if( paths.indexOf(nodePath2) === -1 ) paths.push( nodePath2 );
            if( paths.indexOf(nodePath3) === -1 ) paths.push( nodePath3 );
            var NODE_PATH = paths.join(':');

            process.env.NODE_PATH = NODE_PATH;
            Package.nodePath = NODE_PATH;

            // rerun the node initPaths function
            require("module").Module._initPaths();
        }
    }
}
Package.instances = [];
Package.nodePath = null;


/*******************************************************************************
 *  Class to get all DualBox components in a dependency-friendly order
 ******************************************************************************/
class Repo {
    constructor() {
        // build the dependency array
        this.list = [];
        this.packages = null;

        this._addNode( "@dualbox/dualbox", absolutePath("dualbox") );

        // Initialize all repos setup
        this.repos = this._readRepos();

        // add repos libraries
        _.each(this.repos, (repo) => {
            this._scanRepo("lib", repo);
        });

        // add repos types
        _.each(this.repos, (repo) => {
            this._scanRepo("types", repo);
        });

        // add repos uis
        _.each(this.repos, (repo) => {
            this._scanRepo("ui", repo);
        });

        // add repos modules
        _.each(this.repos, (repo) => {
            this._scanRepo("modules", repo);
        });

        this.yarn = new YarnClient();
        this.prefix = this.yarn.getPrefix();

        this.me = null; // useful to check npm login only once

        this.binPath = path.join(this.prefix, "bin");
        this.libPath = path.join(this.prefix, "lib");
        this.nmPath  = path.join(this.libPath, "node_modules");

        this._sort();
        this.initPackages();
    }

    execSync(cmd, options) {
        if( !options ) options = {};

        //console.log('exec: ' + cmd.yellow + ' from ' + options.cwd.yellow);
        var output = cp.execSync(cmd, options);
        if( output ) {
            var outputStr = output.toString('utf8');
            outputStr = outputStr.substr(0, outputStr.length-1); // remove the \n
            return outputStr;
        }
        else {
            return null;
        }
    }

    isLoggedIn() {
        if( this.me === null ) {
            this.me = this.yarn.whoami();
        }

        return this.me == "dualbox-guest" || this.me == "dual";
    }

    isLoggedInAsAdmin() {
        if( this.me === null ) {
            this.me = this.yarn.whoami();
        }

        return this.me == "dual";
    }

    // build every Package's node_module linking (for browserify transforms) to be able to build locally
    linkTransforms() {
        _.each(this.getPackages(), (p) => {
            p.ensureTransforms();
        });
    }

    // scan a repository for a type of component ("lib", "ui" or "modules"), add them into
    // the Repo
    _scanRepo(type, dirPath) {
        var dirName = "dualbox_" + type;
        var p = path.join(dirPath, dirName);
        var prefix_map = {
            modules:"dualbox-module-",
            types:"dualbox-type-"
        };
        var prefix = prefix_map[type] ? prefix_map[type] : "dualbox-" + type + "-";

        if( fs.existsSync(p) ) {
            getFolders(p).map((d) => {
                this._addNode("@dualbox/" + prefix + d,  absolutePath(path.join(p, d)));
            });
        }
    }

    // get the list of path from .dualboxrc
    _readRepos() {
        var repos = [ process.cwd() ];

        // if .dualboxrc, add all path in it
        if( fs.existsSync('.dualboxrc') ) {
            var txt = fs.readFileSync('.dualboxrc', 'utf8');
            var lines = txt.split('\n');
            _.each(lines, (line) => {
                line = line.trim();
                if( !line.startsWith('#') ) { // discard comment lines
                    if( line.length > 0 ) {
                        repos.push(line);
                    }
                }
            });
        }

        return repos;
    }

    getRepos() {
        return this.repos;
    }

    // add a node from it's path
    _addNode( name, path ) {
        var p = Package.fromPath(path);
        if( p ) {
            this.list.push({
                name: name,
                path: path,
                deps: p.getDualBoxDependencies()
            });
        }
    }

    // sort all components of the list in a dependency friendy way
    _sort() {
        var newList = [];

        var safety = -1;
        while( newList.length !== this.list.length ) {
            if(safety === newList.length){
                var missing_pkg = [];
                for(var i=0; i<this.list.length; ++i){
                    if(newList.indexOf(this.list[i]) === -1){
                        missing_pkg.push(this.list[i]);
                    }
                    if(this.list[i].name.search("ssao") !== -1){
                        console.log(this.list[i].deps);
                    }
                }
                console.log("Missing packages in newList : ");
                _.each(missing_pkg, (c) => {
                    _.each(c.deps, (version, dep) => {
                        var depInList = false;

                        // check if this dep is already on the newList
                        _.each( newList, (setComponent) => {
                            if( setComponent.name === dep ) {
                                depInList = true;
                            }
                        });

                        if( !depInList ) {
                            console.log( 'Package ' + c.name.yellow + ' cant be added because ' + dep.yellow + ' is not added');
                        }
                    });
                });
                //console.log(missing_pkg);
                throw "Error : _sort is stuck into an infinite loop. Something is wrong with dependencies. newList length is "+newList.length+" and list length is "+this.list.length;
            }
            safety = newList.length;

            // move out of this.list all components that already have all their dependencies in newList
            _.each(this.list, (c) => {
                var allDepsInList = true;
                //console.log('[DEBUG] name=' + c.name + ', c.deps = ' + JSON.stringify(c.deps));
                _.each( c.deps, (version, dep) => {
                    var depInList = false;

                    // check if this dep is already on the newList
                    _.each( newList, (setComponent) => {
                        if( setComponent.name === dep ) {
                            depInList = true;
                        }
                    });

                    if( !depInList ) {
                        allDepsInList = false;
                    }
                });

                if( allDepsInList ) {
                    // push in new list
                    if( newList.indexOf(c) == -1 ) {
                        newList.push(c);
                    }
                }
            });
        }

        this.list = newList;
    }

    initPackages() {
        if( !this.packages ) {
            var packages = {};
            _.each(this.list, (c) => {
                var p = Package.fromPath(c.path);
                if( p ) {
                    packages[p.name] = p;
                }
            });
            this.packages = packages;
        }
    }

    // set all packages and dependencies to the last published version
    // this is somewhat necessary now to use yarn to install
    setLastVersion() {
        console.log('[*] reverting all packages to the last published version before install'.green);
        var packages = this.getPackagesInDependencyOrder();
        _.each(packages, (pkg) => {
            pkg.tmpVersion = pkg.pkg.version;
            pkg.setLastVersion();
        });

        _.each(packages, (pkg) => {
            pkg.updateDeps(false); // non-verbose
        });
    }

    // set all packages and dependencies back to the current version
    setCurrentVersion() {
        console.log('[*] setting all changed packages to the next version'.green);
        var packages = this.getPackagesInDependencyOrder();
        _.each(packages, (pkg) => {
            pkg.setNextVersion(true, pkg.tmpVersion);
            delete pkg.tmpVersion;
        });

        _.each(packages, (pkg) => {
            pkg.updateDeps(false); // non-verbose
        });
    }

    // install all packages in Repo
    install( force = false ) {
        //this.setLastVersion();

        _.each( this.getPackagesInDependencyOrder(), (pkg) => {
            pkg.install(force);
        });

        //this.setCurrentVersion();
    }

    // return package from name
    getPackage(name) {
        this.initPackages();
        return this.packages[name];
    }

    // return object name -> Package
    getPackages() {
        this.initPackages();
        return this.packages;
    }

    // return array of path to app.jsons
    getApplications() {

        var recurs = function(appsPath, apps){
            getFolders(appsPath).map((d) => {
                var appJsonPath = path.join(appsPath, d, "app.json");
                if( fs.existsSync(appJsonPath) ) {
                    apps.push(appJsonPath);
                }else{
                    var subAppsPath = path.join(appsPath, d);
                    recurs(subAppsPath, apps);
                }
            });
        }

        var apps = [];
        _.each(this.repos, (repo) => {
            var appsPath = path.join(repo, "apps");
            if( fs.existsSync(appsPath) ) {
                recurs(appsPath, apps);
            }
        });

        return apps;
    }

    // return array of packages in a dependency friendly order
    getPackagesInDependencyOrder() {
        var packages = [];
        _.each(this.list, (c) => {
            var p = Package.fromPath(c.path);
            if( p ) {
                packages.push(p);
            }
        });
        return packages;
    }

    static instance() {
        if( Repo.__instance === null ) {
            Repo.__instance = new Repo();
        }
        return Repo.__instance;
    }
}
Repo.__instance = null;

module.exports = {
    "Package" : Package,
    "Repo"    : Repo.instance()
};
