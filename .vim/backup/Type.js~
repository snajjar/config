import { EventEmitter } from 'events';
import { Buffer } from 'buffer';
import { _ } from '@dualbox/dualbox-lib-lodash';

const LoggerObject = require('./LoggerObject');
const errors = require('./Errors');
const env = require('./Env');

/**
 *  Classe used to perform types check, load json entry to make them
 *  values for packages, etc...
 *  Definition notes :
 *      - Arrays are defined with "Array<type>"
 *      - null is accepted except when + is added at the end of the type.
 *          ex : "Geometry" vs "Geometry+"
 */
class Type extends LoggerObject {
    /**
     *  @constructor
     *  @param {Object} description The package decription of the module.
     *  @param {string} id A unique id for the module in the graph-browserify.
     */
    constructor() {
        super("Type", { userOrigin: false, logLevel: "warn" });

        this.types = {};
        this.typesKeys = [];
        // Object must stay the last type in the list because it can catch some objects like Arrays.
    }

    init() {
        // NOTES: yarn and npm do not support circular deps, even tho node.js does...
        var arr = [
            '@dualbox/dualbox-type-object',
            '@dualbox/dualbox-type-buffer',
            '@dualbox/dualbox-type-map',
            '@dualbox/dualbox-type-array',
            '@dualbox/dualbox-type-nativearray',
            '@dualbox/dualbox-type-number',
            '@dualbox/dualbox-type-boolean',
            '@dualbox/dualbox-type-string',
            '@dualbox/dualbox-type-regexp',
            '@dualbox/dualbox-type-json'
        ];

        _.each(arr, (typePackage) => {
            try {
                require(typePackage);
            }
            catch(e) {}
        });
    }

    matchJSON(json) {
        var type = this._findTypeFromJSON(json);
        // try a fast find (for perf)
        if( type && type.matchJSON(json) ) {
            return type;
        }
        else {
            // else, cycle through all types
            var t = null;
            _.each(this.types, (type) => {
                if( type.matchJSON(json) ) {
                    t = type;
                    return false;
                }
            });
            return t;
        }
    }

    // Allow for loading with a specified type
    // Basically, if the type is a simple type (not a map nor an array),
    // it can be loaded even if the JSON does not indicate the type.
    loadFromJSON(json,type_){
        if( !this.types["json"] ) {
            throw new errors.TypeError("json type must be registered, but is not");
        }

        if( json && json instanceof this.types["json"].jsClass ) {
            json = json.get();
        }

        if(type_ && type_ !== "*"){
            var type = type_.toLowerCase();
            if(type[type.length-1] === "+"){
                if(json === null){
                    throw new errors.TypeError("cannot set null default value on a non null type ("+type+")");
                    return null;
                }else{
                    return this.loadFromJSON( json, type.slice(0,type.length-1));
                }
            }else if(json === null){
                return json;
            }else if(type.slice(0,5) === "array"){
                // dealing with Arrays
                var subtype = type.slice(6,type.length-1);
                var res = [];
                if(json.constructor === Array){
                    for(var i=0; i<json.length; ++i){
                        res.push(this.loadFromJSON(json[i], subtype));
                    }
                }else{
                    throw new errors.TypeError("Expected array type " + type + " and got value : "+json);
                }
                return res;
            }else if(type.slice(0,4) === "map<"){
                // for maps, definition must be complete
                return this.types.map.fromJSON(json);
            }else{
                // dealing with all other types
                if(this.types[type] === undefined){
                    throw new errors.TypeError("Error : " + type + " is not managed by Type. Type manage the following types: " + JSON.stringify(this.typesKeys))
                }
                return this.types[type].fromJSON(json);
            }
        }else{
            var res = null;

            if( json == null ) return null;
            if( typeof json == "object" ) {
                var type = this._findTypeFromJSON(json);
                if( type ) {
                    res = type.fromJSON(json);
                }
                else {
                    var tk = this.typesKeys;
                    for(var i=0; i<tk.length; ++i){
                        var t = this.types[tk[i]];
                        if( t.matchJSON(json) ) {
                            res = t.fromJSON(json);
                            break;
                        }
                    }
                }

                if( res ){
                    return res;
                }else{
                    throw new errors.RuntimeError('Could not deserialize object ' + json + ' : unrecognized type structure');
                }
            }
            else {
                return json;
            }
        }
    }

    /**
     *  Check that val is an instance of type, type must not be *.
     *
     */
    check(type_,val){
        if(type_ === undefined || val === undefined){
            return false;
        }

        var type = type_.toLowerCase();
        if(type === "*"){
            return true;
        }else{
            var postype = type;
            if(type[type.length-1]==="+"){
                postype = type.slice(0,type.length-1);
                if(val === null){
                    return false;
                }
            }else{
                if(val === null){
                    return true;
                }
            }
            if(postype.slice(0,6) === "array<" && val.constructor === Array){
                var subtype = postype.slice(6,postype.length-1);
                if(val.length === 0){
                    return true;
                }
                return this.check(subtype, val[0])
            }else if(postype.slice(0,6) === "array<" && val.constructor !== Array){
                return false;
            }else if(postype.slice(0,4) === "map<" && val.constructor === Map){
                var key_type = postype.slice(4,10);
                var value_type = postype.slice(11,type.length-1);
                var iter = val.entries();
                if(iter.value !== undefined){
                    return this.check(key_type,iter.value[0]) && this.check(value_type,iter.value[1]);
                }else{
                    return true;
                }
            }else if(postype.slice(0,4) === "map<" && val.constructor !== Map){
                return false;
            }else if(postype === "buffer" && val.constructor.name === "Buffer"){
                return true;
            }else if(this.types[postype] !== undefined && this.types[postype].enumerate){
                return this.types[postype].enumerate[val] !== undefined || this.types[postype].toJSON(val).data;
            }else{
                if(this.types[postype] === undefined){
                    throw "Unmanaged type "+postype;
                }
                return this.types[postype].matchData(val);
            }
        }
    }

    /**
     *  Check type against val and throw a type error if any.
     *  TODO : the returned error does not perform a deep type analysis
     *         to find the actual val type, should do.
     */
    checkThrow( type, val ) {
        if( !this.check(type,val) ) {
            var actual_type = typeof val;
            if(val === undefined || val === null){
                actual_type = val;
            }else if(val.constructor === Array){
                actual_type = "Array";
            }
            throw new errors.TypeError("Expected input of type " + type + " but got '" + val + "' of type " +
            actual_type + " instead");
        }
    }

    checkArrayThrow( types, val ) {
        var ok = false;
        var actual_type = typeof val;
        var failed_types = "";
        for(var i=0; i<types.length; ++i){
            try {
                this.checkThrow(types[i], val);
                ok = true;
                break;
            }catch(e){
                failed_types += types[i]+" ; ";
            }
        }
        if(!ok){
            throw new errors.TypeError("Expected input of type " + failed_types + " but got '" + val + "' of type " +
            actual_type + " instead");
        }
    }

    typeMatch( type0_, type1_ ){
        var type0 = type0_.toLowerCase();
        var type1 = type1_.toLowerCase();
        return  type0 === "*" || type1 === "*" ||
                type0 === type1 ||
                (type0.slice(0,5) === "array" && type1.slice(0,5) === "array"
                    && this.typeMatch(type0.slice(6,type0.length-1), type1.slice(6,type1.length-1))
                ) ||
                (type0.slice(0,3) === "map" && type1.slice(0,3) === "map"
                    && this.typeMatch(type0.slice(3,10), type1.slice(3,10))
                    && this.typeMatch(type0.slice(11,type0.length-1), type1.slice(11,type1.length-1))
                );
    }

    detectType(json){
        var candidate = null;

        if( json !== null ){
            var tk = this.typesKeys;
            for(var i=0; i<tk.length; ++i){
                var type = this.types[tk[i]];
                if( type.matchJSON(json) ) {
                    candidate = tk[i];
                    break;
                }
            }
        }

        if(candidate.toLowerCase() === "array"){
            return "Array<"+this.detectType(json[0])+">";
        }else if(candidate.toLowerCase() === "map"){
            return "Map<String,"+this.detectType( json.data[Object.keys(json.data)[0]] )+">";
        }else if(candidate !== null){
            return candidate;
        }
        return null;
    }

    areValueEqual(type, v1, v2){

        var that = this;

        // Convenient functin to compare arrays, can be used in your comparison
        // setups.
        var compareArrays = function(arr1,arr2,type){
            if(arr1.length !== arr2.length){
                return false;
            }else{
                var ok = true;
                for(var i=0; i<arr1.length; ++i){
                    ok = ok && that.areValueEqual(type, arr1[i],arr2[i]);
                }
                return ok;
            }
        }

        var compareMaps = function(map1, map2, type){
            var keys = Object.keys(map1);
            for(var i=0; i<keys.length; ++i){
                if(map2[keys[i]] === undefined){
                    return false;
                }else{
                    if(!that.areValueEqual(type, map1[keys[i]],map2[keys[i]])){
                        return false;
                    }
                }
            }
            return true;
        }

        type = type.toLowerCase();

        if(v1 === null || v2 === null && v1 !== v2){
            return false;
        }else if(type.slice(0,6) === "array<"){
            return compareArrays(v1,v2,type.slice(6,type.length-1));
        }else if(type.slice(0,11) === "map<string,"){
            return compareMaps(v1,v2,type.slice(11,type.length-1));
        }else{
            switch(type){
                case "number":
                case "string":
                case "boolean":
                    return v1 === v2;
                break;
                case "file":
                    return JSON.stringify(v1.toJSON()) === JSON.stringify(v2.toJSON());
                break;
                case "json":
                    return JSON.stringify(v1) === JSON.stringify(v2);
                break;
                default:
                    if(v1.equals !== undefined){
                        return v1.equals(v2);
                    }else if(v1.toJSON !== undefined){
                        return JSON.stringify(v1.toJSON()) === JSON.stringify(v2.toJSON());
                    }else{
                        throw "Error : no implementation to compare type : " + type+". Please provide one in Type";
                    }
                break;
            }
        }
    }

    /**
     *   Return the current instance or create one if needed
     */
    static getInstance() {
        if( Type.__instance === null ) {
            Type.__instance = new Type();
        }

        return Type.__instance;
    }

    registerEnumerateType(name, map, desc){
        var reverseMap = {};
        var mapk = Object.keys(map);
        mapk.forEach(function(k, i){
            reverseMap[map[k]] = mapk[i];
        });

        this.registerType({
            enumerate:map,
            name:name,
            jsClass:null,
            desc:desc,
            fromJSON:function(json){
                var dt = json.metadata ? json.data : json;

                if(typeof dt === "string"){
                    return map[dt];
                }else if(typeof dt === "number"){
                    return dt;
                }
            },
            toJSON:function(o){
                return {
                    metadata:{
                        type:name
                    },
                    data:reverseMap[o]
                }
            }
        });
    }

    registerType(params){
        var name = params.name.toLowerCase();
        if(this.types[name]){
            // Commented throw - some types are already register before loading app in Dualbox editor
            //throw new errors.RuntimeError("Cannot register type " + params.name + " : type already registered.")
            return;
        }

        this.types[name] = {
            name:name,
            enumerate:params.enumerate ? params.enumerate : null,
            native:params.native ? params.native : false,
            jsClass:params.jsClass,
            desc:params.desc,
            clone:params.clone ? params.clone : function(o){
                return o.clone();
            },
            fromJSON:params.fromJSON ? params.fromJSON : params.jsClass.fromJSON,
            toJSON:params.toJSON ? params.toJSON : function(o){
                return o.toJSON();
            },
            fromWorkerData:
                params.fromWorkerData ?
                    params.fromWorkerData :
                    (params.jsClass && params.jsClass.fromWorkerData ?
                        params.jsClass.fromWorkerData :
                        (params.fromJSON ? params.fromJSON : params.jsClass && params.jsClass.fromJSON)
                    ),
            toWorkerData:params.toWorkerData ? params.toWorkerData : function(o){
                if(o.toWorkerData){
                    return o.toWorkerData();
                }else{
                    return this.toJSON(o);
                }
            },
            matchData:params.matchData ? params.matchData : function(o){
                if(params.enumerate &&
                    typeof o !== "object") // optimization line to avoid shit like [o] which call a toString method on the object...
                {
                    return params.enumerate[o] !== undefined;
                }else if(params.jsClass){
                    if(typeof params.jsClass === "string"){
                        return typeof o === params.jsClass;
                    }else{
                        return o instanceof params.jsClass;
                    }
                }
            },
            matchJSON:params.matchJSON ? params.matchJSON : function(json){
                return json && json.metadata && ((json.metadata.__dualbox && json.metadata.__dualbox.type === params.name) || (!json.metadata.__dualbox && json.metadata.type === params.name));
            }
        };

        // If the given object is a Javascript class, add the __dualbox__type property to its prototype for easy matching
        if(params.jsClass){
            if(params.jsClass.prototype){
                Object.defineProperty(params.jsClass.prototype,
                    '__dualbox__type',
                    {
                        value:params.name,
                        writable:false
                    }
                );
            }else{
                //console.log(params.name);
            }
        }

        this.typesKeys.push(name);

        // sort by native types, ensuring "object" is at the end
        this.typesKeys = _.sortBy(this.typesKeys, [
            (o) => {
                return this.types[o].native;
            },
            (o) => {
                return this.types[o].name == "object";
            }
        ]);
    }

    clone( o ) {
        var res = null;

        if( o == null ) return null;
        if( typeof o == "object" ) {
            // check if it matches our registered types
            /*
            var tk = this.typesKeys;
            for(var i=0; i<tk.length; ++i){
                var type = this.types[tk[i]];
                if( type.matchData(o) ) {
                    res = type.clone(o);
                    break;
                }
            }
            */

            var type = this._findTypeFromValue(o);
            if( type ) {
                res = type.clone(o);
            }

            if( res ){
                return res;
            }else{
                throw new errors.RuntimeError('Could not clone object ' + o + ' of type ' + (typeof o) + ' : unrecognized type structure');
            }
        }
        else {
            return o;
        }
    }

    toJSON( o ) {
        var res = null;

        if( o == null ) return null;
        if( typeof o == "object" ) {
            var type = this._findTypeFromValue(o);
            if( type ) {
                res = type.toJSON(o);
            }

            if( res ) return res;
            throw new errors.RuntimeError('Could not serialize object ' + o + ' of type ' + (typeof o) + ' : unrecognized type structure');
        }
        else {
            return o;
        }
    }

    fromJSON( json ) {
        return this.loadFromJSON(json);
    }

    toWorkerData( o ) {
        var res = null;

        if( o == null ) return null;
        if( typeof o == "object" ) {
            var type = this._findTypeFromValue(o);
            if( type ) {
                res = type.toWorkerData(o);
            }

            if( res ) return res;
            throw new errors.RuntimeError('Could not serialize object ' + o + ' of type ' + (typeof o) + ' : unrecognized type structure');
        }
        else {
            return o;
        }
    }

    fromWorkerData( o ) {
        var res = null;

        if( o == null ) return null;
        if( typeof o == "object" ) {
            var type = this._findTypeFromJSON(o);
            if (type) {
                res = type.fromWorkerData(o);
            } else {
                var tk = this.typesKeys;
                for (var i = 0; i < tk.length; ++i) {
                    var t = this.types[tk[i]];
                    if (t.matchJSON(o)) {
                        res = t.fromWorkerData(o);
                        break;
                    }
                }
            }

            if( res ) return res;
            throw new errors.RuntimeError('Could not serialize object ' + o + ' of type ' + (typeof o) + ' : unrecognized type structure');
        }
        else {
            return o;
        }
    }

    serialize( o ){
        return this.toJSON(o);
    }

    deserialize( o ){
        return this.fromJSON(o);
    }

    // don't break, no exceptions
    safeSerialize( o ) {
        try {
            return this.serialize(o);
        }
        catch(e) {
            // serialization failed
            console.error(e);
            return "[[serialization failed]]";
        }
    }

    _findTypeFromValue( o ) {
        var type = typeof o;
        switch(type) {
        case "number":
            return this.types["number"];
        case "boolean":
            return this.types["boolean"];
        case "string":
            return this.types["string"];
        case "object":
            /*
            if( o === undefined ) return undefined;
            if( o === null ) return null;
            */

            var objectType = o.__dualbox__type && o.__dualbox__type.toLowerCase();
            if( !objectType ) {
                throw new errors.RuntimeError("Object " + JSON.stringify(o) + " has no __dualbox__type field");
            }
            else if( !this.types[objectType] ) {
                throw new errors.RuntimeError("Type " + objectType + " is not defined in the application. Defined types are " + _.keys(this.types));
            }
            else {
                return this.types[objectType];
            }
        default:
            throw new errors.RuntimeError("Cant find type of object: " + o);
        }
    }

    _findTypeFromJSON( json ) {
        var type = typeof json;
        switch(type) {
        case "number":
            return this.types["number"];
        case "boolean":
            return this.types["boolean"];
        case "string":
            return this.types["string"];
        case "object":
            if( Array.isArray(json) ) {
                return this.types["array"];
            }
            else {
                if( json.metadata && json.metadata.__dualbox && json.metadata.__dualbox.type){
                    return this.types[json.metadata.__dualbox.type.toLowerCase()];
                }else if(json.metadata && json.metadata.type ){
                    return this.types[json.metadata.type.toLowerCase()];
                }
                else {
                    return this.types["json"];
                }
            }
        default:
            throw new errors.RuntimeError("Cant find type of json of type " + type + ": " + JSON.stringify(json));
        }
    }

    /**
     *  Test if parameter is valid JSON
     */
    isJson( json ) {
        try {
            JSON.stringify(json);
            return true;
        }
        catch (e) {
            return false;
        }
    }

    /**
     *   Convert a map to object
     */
    map2obj( map ) {
        if( map === undefined ) return {};
        var res = {};
        map.forEach((v, k, map) => {
            res[k] = v;
        });
        return res;
    }
};

Type.__instance = null;

module.exports = Type.getInstance();
