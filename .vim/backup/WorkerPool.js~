"use strict";

const Workify = require('./Workify');
const LoggerObject = require('../../LoggerObject.js');
const Type = require('../../Type.js')
const env = require('../../Env');
const _ = require('lodash');

const WorkerStatus = {
    "STARTING"     : 0,
    "READY"        : 1,
    "COMPUTING"    : 3,
    "STOPPING"     : 4,
    "STOPPED"      : 5
}

class WorkerPool extends LoggerObject {
    constructor() {
        super("WorkerPool", { logLevel: env.getLogLevel() });

        // w contains a list of workers, with their state (WorkerStatus) and the worker object
        this.w = [];

        // a task is the module object that launched the task
        this.tasks = [];

        // mapping of commands -> methods
        this.commands = {
            "log"         : this.onLog.bind(this),
            "initialized" : this.onInitialized.bind(this),
            "computed"    : this.onComputed.bind(this)
        }
    }

    onLog( response ) {
        let i = response.id;

        if( this.w[i].task !== null ) {
            // module log
            this.w[i].task[response.level].apply(this.w[i].task, response.args);
        }
        else {
            response.args[0] = "[Worker:" + i + "] " + response.args[0];
            this[response.level].apply(this, response.args);
        }
    }

    onInitialized( response ) {
        let i = response.id;

        this.debug("Worker " + i + " has been initialized");
        this.w[i].state = WorkerStatus.READY;

        this.assignTasks();
    }

    onComputed( response ) {
        let i = response.id;
        let task = this.w[i].task;
        this.debug("Worker " + i + " has sent result");

        // deserialize the worker response
        var keys = Object.keys(response.data);
        var data = {};
        for(var j=0; j<keys.length; j++) {
            let k = keys[j];
            data[k] = Type.fromWorkerData(response.data[k]);
        }
        task.emit('data', data);

        // overwrite node execTimes with worker execTimes
        task.execTimes = response.execTimes;

        // clean the worker
        this.w[i].task  = null;
        this.w[i].state = WorkerStatus.READY;

        // assign left tasks
        this.assignTasks();
    }

    initWorker( i ) {
        // init worker object and launch worker
        this.w[i] = {
            state  : WorkerStatus.STARTING,
            task   : null,
            worker : Workify( require('./ModuleWorker.js') ),
        };

        // add event listener
        var that = this;
        this.w[i].worker.addEventListener('message', function(e) {
            var response = e.data;
            if( response.origin == 'worker' ) {
                if( that.commands[response.cmd] === undefined ) {
                    that.error("Can't recognize command from worker: " + response.cmd);
                    that.debug("response object: " + JSON.stringify(response, null, 2));
                    return;
                }
                else {
                    that.commands[response.cmd](response);
                }
            }
            else if(response.origin == "workerpool") {
                // one of our own message, discard
            }
            else {
                this.error("Received message with unspecified origin");
            }
        });

        // init the worker with it's worker ID
        this.w[i].worker.postMessage({
            cmd:    'init',
            id :    i,
            origin: 'workerpool',
            envOptions: env.getOptions(),
        });
    }

    // allocate and initialize n workers
    alloc( n ) {
        if( n === undefined ) {
            // 1 worker for each parallel module, with limit of
            // navigator.hardwareConcurrency
            if( env.worker ) {
                if(window === undefined){
                    throw "following alloc won't work, for some reason window is not defined.";
                }
                n = Math.min(window.DualBox.app.nbParallelModules, navigator.hardwareConcurrency);
            }
            if( n === undefined ) n = 2;
        }

        for(var i=0; i<n; i++) {
            this.initWorker(i);
        }

        return this; // so we can do: var pool = new WorkerPool().alloc();
    }

    // add a task from a module object
    launchTask( module ) {
        this.addTask( module );
        this.assignTasks();
    }

    addTask( module ) {
        // kill task if already present from previous computation
        this.killTask( module );
        this.tasks.push( module );
    }

    killTask( module ) {
        this.removeFromTasks( module );
        this.killWorkerComputation( module );
    }

    removeFromTasks( module ) {
        for(let i=0; i<this.tasks.length; i++) {
            let task = this.tasks[i];

            if( task.id == module.id ) {
                this.info("task already in task list: removing %s",module.id);
                this.tasks.splice( i, 1 );
            }
        }
    }

    killWorkerComputation( module ) {
        let workerKilled = 0;
        for(let i=0; i<this.w.length; i++) {
            let workerInfo = this.w[i];

            if(workerInfo.state == WorkerStatus.COMPUTING && workerInfo.task && workerInfo.task.id == module.id ) {
                console.warn("hard killing worker (task: " + module.id + ")");
                workerInfo.worker.terminate();
                this.initWorker(i);
            }
        }
    }

    // assign the existing tasks to the available workers
    assignTasks() {
        for(let i=0; i<this.w.length; i++) {
            if( this.w[i].state == WorkerStatus.READY ) {
                if( this.tasks.length != 0 ) {
                    var task = this.tasks.shift();

                    this.w[i].task  = task;
                    this.w[i].state = WorkerStatus.COMPUTING;
                    this.log("assigning task %s to worker %s",this.w[i].task.id, i);

                    var inputValue = [];
                    _.each(task.inputValue, (v, k) => {
                        inputValue[k] = Type.toWorkerData(v);
                    });

                    this.w[i].worker.postMessage({
                        cmd:         'compute',
                        id:          task.id,
                        jobId:       task.execJobId,
                        rootApp:     null,
                        desc:        task.desc,
                        inputValid:  task.inputValid,
                        inputValue:  inputValue,
                        origin:      'workerpool',
                    });
                }
            }
        }
    }

    interrupt() {
        for(let i=0; i<this.w.length; i++) {
            if( this.w[i].state == WorkerStatus.COMPUTING ) {
                this.log('interrupting computing worker %s',i);
                this.w[i].worker.terminate();
                this.initWorker(i);
            }
        }
    }

    /**
     *   Return the current instance or create one if needed
     */
    static getInstance() {
        if( WorkerPool.__instance === null ) {
            WorkerPool.__instance = new WorkerPool();
        }

        return WorkerPool.__instance;
    }
}
WorkerPool.__instance = null;

module.exports = WorkerPool.getInstance().alloc();
