var pjson = require('../package.json');
var colors = require('colors');
var shelljs = require('shelljs');
var yargs = require('yargs');
var request = require('request');
var _ = require('lodash');
var fs = require('fs-extra');
var path = require('path');
var cp = require('child_process');

var AppParser = require('@dualbox/dualbox-lib-appparser');
var DpmCache = require('../lib/dpmcache');
var File = require('@dualbox/dualbox-lib-file');

// show helper for this command
var help = function() {
    var helper = require('./help.js');
    helper.handle(['bundle']);
    process.exit(1);
}

var getArgs = function() {
    return yargs
        .alias('a','app')
        .alias('v','version')
        .alias('i','input')
        .alias('o','output')
        .argv;
}

var checkInputFormat = function( input ) {
    if( !input ) {
        throw "No input provided";
    }
    if( !input.app ) {
        throw "malformed input: 'app' not found in JSON";
    }
    if( !input.version ) {
        throw "malformed input: 'version' not found in JSON";
    }
    if( !input.input ) {
        throw "malformed input: 'input' not found in JSON";
    }
}

var loadAppScript = function(app, version, cb) {
    var url = pjson.dualboxEndpoint + "/api/app/" + app + "/v/" + version;
    request(url, function( err, res, body ) {
        if( err ) {
            throw "Could not resolve application " + app + " version " + version + " on url " + url + " : " + err;
        }

        // Response here is JSON with the script location. Resolve it
        try {
            var json = JSON.parse(body);

            request(json.Location, function(err, res, body) {
                if( err ) {
                    throw "Could not resolve application " + app + " version " + version + " on url " + json.Location + " : " + err;
                }

                cb(body);
            });
        }
        catch(e) {
            console.error('Could not resolve application ' + app + ' version ' + version + '.\n' +
                'Please contact support (providing the application json to resolve).');
        }
    });
}

var loadAppJson = function(app, version, cb) {
    var url = pjson.dualboxEndpoint + "/api/app/" + app + "/v/" + version + "/json";
    request(url, function( err, res, body ) {
        if( err ) {
            cb( new Error("Could not resolve json for application " + app + " version " + version + " on url " + url + ": " + err) );
        }
        else {
            cb( null, JSON.parse(body) );
        }
    });
}

// Determine the DualBox type of an object
// return "native", "File" or "unknown" for now
var getObjectType = function( o ) {
    if( typeof o === "object" ) {
        var objectType = o.constructor && o.constructor.name;
        if( objectType ) {
            return objectType;
        }
        else {
            return "unknown";
        }
    }
    else {
        return "native";
    }
}

var printOutput = function( output, outputDest ) {
    if( outputDest == "stdout" ) {
        // print to console
        var outputFunction = function( o ) {
            switch( getObjectType(o) ) {
            case "native" :
                console.log(o);
                break;
            case "File" :
                var b = new Buffer(o.toArrayBuffer());
                process.stdout.write(b);
                break;
            case "unkown":
                console.error("Unrecognized object type for requested output");
                require('util').inspect(o);
                break;
            default:
                // serialize as json
                if( o.toJson ) {
                    console.log( JSON.stringify(o.toJson()) );
                }
                else {
                    console.error(require("util").inspect(o));
                    throw "Could not serialize unknown type";
                }
                break;
            }
        };
    }
    else {
        // write to a file
        var outputFunction = function( o ) {
            switch( getObjectType(o) ) {
            case "native" :
                fs.writeFileSync(outputDest, o);
                break;
            case "File" :
                fs.writeFileSync(outputDest, new Buffer(o.toArrayBuffer()), "binary");
                break;
            default:
                // serialize as json
                if( o.toJson ) {
                    fs.writeFileSync(outputDest, new Buffer(JSON.stringify(o.toJson())), "utf8");
                }
                else {
                    console.error(require("util").inspect(o));
                    throw "Could not serialize unknown type";
                }
            }
        }
    }

    outputFunction(output);
}

var matchJSON = function(type, json) {
    return json && json.metadata && ((json.metadata.__dualbox && json.metadata.__dualbox.type === type) || (!json.metadata.__dualbox && json.metadata.type === type));
}

// handle only File casting for now
var castResult = function( o ) {
    if( typeof o === "object" ) {
        if( matchJSON("File", o) ) {
            return File.fromJSON(o);
        }
        else {
            return o;
        }
    }
    else {
        // native type, just return
        return o;
    }
}

// Update an app.json file to the versions locally present
var removeParallel = function( json ) {
    var parser = new AppParser(json);
    parser.eachNode((json) => {
        if( json.parallel ) {
            json.parallel = false;
        }
    });
    return json;
}

// app: name of the app
// version: version
// json: the app.json file
// parameters: all app inputs to set
// output: the output we want to resolve on the app
// strictVersioning: true if we want to execute the app with the exact versions of components
var execApp = function(appName, version, json, parameters, output, strictVersioning, cb) {
    // get dependencies and install them
    console.warn('[*] Checking app dependencies'.green);
    var dpmCache = new DpmCache(null, appName, version);
    var appJson = strictVersioning ? json : dpmCache.toCacheVersion(json);

    dpmCache.installApp(appJson, strictVersioning, function(err) {
        if(err) {
            console.warn(('[*] ' + err).yellow);
            cb(err, null);
        }

        // Add our install path in top of NODE_PATH
        var np = process.env.NODE_PATH ? process.env.NODE_PATH.split(':') : [];
        np.unshift( dpmCache.path );
        process.env.NODE_PATH = np.join(':');

        // to handle all require correctly from the new cache folder, we must copy this file
        // in the new created folder
        fs.copySync(path.join(__dirname, '../lib/runapp.js'), path.join(dpmCache.path, "runapp.js"));
        var child = cp.fork(path.join(dpmCache.path, 'runapp.js'), { 'cwd' : dpmCache.path });
        child.on('message', result => {
            console.warn('[*] computing done!'.green);
            child.kill('SIGINT');
            var res = castResult( result );
            cb(null, res);
        });
        child.send({
            appJson: appJson,
            strictVersioning: strictVersioning,
            parameters: parameters,
            output: output
        });
    });
}

var getInputValue = function( s ) {
    if( s[0] == '@' ) {
        // our value is a file
        s = s.substr(1);

        var filePath = s[1]=='/' ? s : process.cwd() + '/' + s;
        var ext  = path.extname(s).replace(".", "");
        if( ext.toLowerCase() == "json" ) {
            return require(filePath);
        }
        else {
            var buf = fs.readFileSync(filePath);
            var name = path.basename(s, ext);
            var file = File.buildFromBuffer(buf, ext, name);
            return file.toJSON();
        }
    }
    else {
        return s;
    }
}

var resolveInputs = function( input ) {
    var res = {
        input: {}
    };

    var handleInput = function( input ) {
        // it's either a file or 1 argument
        if( input[0] == '@' ) {
            if( input[1] == '/' ) {
                res = require(input.substr(1));
            }
            else {
                res = require(process.cwd() + '/' + input.substr(1));
            }

            // from a file, we need to check that all the data is here
            checkInputFormat(res);
        }
        else {
            var split = input.split(':');
            res.input[ split[0] ] = getInputValue(split[1]);
        }
    }

    if( typeof input == "string" ) {
        // it's either a file or 1 argument
        handleInput(input);
    }
    else if( Array.isArray(input) ) {
        // it's several arguments
        _.each(input, (s) => {
            handleInput(s);
        });
    }

    return res;
}

var handleCommand = function(args) {
    // get and check args
    var args = getArgs();

    // load the input arg if it's a file
    var input = resolveInputs( args['i']);

    // check if we forced the application or version
    var app = args['a'] || input.app;
    var version = args['v'] || input.version;
    var appInputs = input.input;
    var appOutput = args['o'];
    var strictVersioning = args['strict-versioning'] === undefined;

    if( args['help'] ) {
        help();
        return;
    }

    // parse output to resolve app output name and destination
    var output = args['o'];
    if( output.indexOf(':') !== -1 ) {
        var split = output.split(':');
        var appOutput  = split[0];
        var outputDest = split[1].substr(1);
    }
    else {
        var appOutput  = output;
        var outputDest = "stdout";
    }

    if( args['appfile'] ) {
        console.warn(('[*] Reading app file ' + args['appfile']).green);
        var jsonStr = fs.readFileSync( args['appfile'], 'utf8');
        var json = JSON.parse(jsonStr);
        execApp(app, version, json, appInputs, appOutput, strictVersioning, function(err, res) {
            if( err ) {
                return -1;
            }
            else {
                printOutput(res, outputDest);
            }
        });
    }
    else {
        console.warn(('[*] Resolving application ' + app + ' version ' + version).green);
        loadAppJson(app, version, function(err, json) {
            execApp(app, version, json, appInputs, appOutput, strictVersioning, function(err, res) {
                if( err ) {
                    return -1;
                }
                else {
                    printOutput(res, outputDest);
                }
            });
        });
    }
};

exports.handle = handleCommand;
exports.description = "Run a dualbox.io deployed application to get an output";
exports.help =
`
Run a deployed application version with a set of parameters to get an output to a file:
Application name and version are provided in the JSON input
{0} run --input [json_parameters|@json_file] --output [output name]:@file

Example: To convert your export file "parameters.json" into a "result.stl" file
{0} run --input @parameters.json --output MyAppOutput:@result.stl



Run a deployed application version with a set of parameters to get an output to a file while forcing the application and version:
{0} run -a [appName] -v [version] --input [json_parameters|@json_file] --output [output name]:@file

Example: If you have an application "mergeSTL" in version 1.2.1 that, provided in inputs "file1" and "file2" 2 STL files, can give a merged STL file on its output "mergedFile", you can use it directly from commande line:
{0} run -a mergeSTL -v 1.2.1 --input file1:@mylocalfile1.stl --input file2:mylocalfile2.stl --output mergedFile:@merged.stl


`.format(pjson.name);
