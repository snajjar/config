import { $, env, Widget3D, TypeManager, utils } from '@dualbox/dualbox';
import { SphereBufferGeometry, BufferTriGeometry, BufferGeometry, Geometry, Mesh, MeshBasicMaterial, Object3D, Vector3, Plane, VertexColors, MeshStandardMaterial, Color} from '@dualbox/dualbox-lib-xthree';
var pkgDesc = require('../../package.json');

const JSONObject = require('@dualbox/dualbox-type-json');
var DualBoxTypesAll3D = require('@dualbox/dualbox-type-all3d');

const Widget3DPositions = require('@dualbox/dualbox-ui-widget3d-positions');

if( env.browser ) {
    require('@dualbox/dualbox-lib-bootstrap');  // require bootstrap to work
    require('./Widget3DRichPositions.css'); // for bundle compilation
}

/**
 *  Widget to set and move positions on a scene mesh and attach more information to this position.
 *  Note that this class is almost copied from widget3D-positions but can also handle color and size.
 *
 *  Improvement notes :
 *      - add possibility to restrict the dragging to some objects in the scene.
 *        It could be an input array of mesh names on which dragging is allowed.
 */
class Widget3DRichPositions extends Widget3DPositions {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options);

        // Color picker div
        this.cp_div = null;
        // Scale slider div
        this.sc_div = null;

        this.colors = [];
        this.scales = [];

        // initialized the override
        this.overrideInputs = ["positions", "colors", "scales", "limit", "restrict"];
        this.onOverride({});
    }

    registerEvents() {
        super.registerEvents();
        this.registerUIEvent("hideControls", this.hideControls.bind(this));
        this.registerUIEvent("showControls", this.showControls.bind(this));
    }

    hideControls(){
        $(this.cp_div).hide();
        $(this.sc_div).hide();
    }
    showControls(){
        $(this.cp_div).show();
        $(this.sc_div).show();
    }

    hide(){
        super.hide();
        hideControls();
    }
    show(){
        super.show();
        showControls();
    }

    setPersistentInputValues(){
        super.setPersistentInputValues();
        var pin = this.inputPersist;
        var valid = this.inputValid;
        var value = this.inputValue;

        pin.scale = valid.scale ? value.scale : pin.scale;
        pin.color = valid.color ? value.color : pin.color;
        pin.metalness = valid.metalness ? value.metalness : pin.metalness;
        pin.roughness = valid.roughness ? value.roughness : pin.roughness;
    }

    init3D(){
        super.init3D();

        this.inputPersist.scale = Vector3.fromJSON(pkgDesc.dualbox.input.scale.value);
        this.inputPersist.color = Color.fromJSON(pkgDesc.dualbox.input.color.value);

        // The material for widget will show the color of the material by default
        this.inputPersist.mat = new MeshBasicMaterial({vertexColors:VertexColors});
        this.mesh.material = this.inputPersist.mat;
    }

    buildOutput(){
        var res = {
            positions:[],
            colors:[],
            scales:[]
        };
        for(var i=0; i<this.positions.length; ++i){
            res.positions.push(this.positions[i].toJSON());
            res.colors.push(this.colors[i].toJSON());
            res.scales.push(this.scales[i].toJSON());
        }
        return new JSONObject(res);
    }
    doTrigger(){
        this.trigger({ "positions" : this.buildOutput() });
    }

    import( v ) {

        var v = v instanceof JSONObject ? v.get() : v;

        this.selected = {};
        this.positions = [];
        this.colors = [];
        this.scales = [];
        this.g = [];

        var p = utils.struct.deserialize( v.positions );
        var m = utils.struct.deserialize( v.colors );
        var s = utils.struct.deserialize( v.scales );
        for(var i=0; i<p.length; ++i){
            this.addManipulator(p[i], m[i], s[i]);
        }
        this.updateGeometries();
        this.override = null;
        this.doTrigger();
    }

    clearValue(){
        this.selected = {};
        this.positions = [];
        this.colors = [];
        this.scales = [];
        this.g = [];
        this.updateGeometries();
        this.doTrigger();
    }

    // This will override the current positions (set by the user)
    // with the positions determined from the inputs.
    // this.override contains which inputs must override the current position.
    overrideUserInputs(){
        var inVal = this.inputValue;
        var changed = this.override;

        if(changed.positions || changed.colors || changed.scales){
            this.selected = {};
            this.g = [];
            this.positions = [];
            this.colors = [];
            this.scales = [];
            for(var i=0; i<inVal.positions.length; ++i){
                this.addManipulator(inVal.positions[i], inVal.colors[i],inVal.scales[i]);
            }
            this.updateGeometries();
        }
        if(changed.limit){
            this.limit = inVal.limit;
            if(this.positions.length>this.limit){
                for(var i=this.limit; i<this.positions.length; ++i){
                    delete this.selected[i];
                }
                this.positions.slice(0,this.limit);
                this.colors.slice(0,this.limit);
                this.scales.slice(0,this.limit);
                this.g.slice(0,this.limit);
                this.updateGeometries();
            }
        }
        if(changed.restrict){
            this.restrict = new Function('p', inVal.restrict);
            for(var i=0; i<this.positions.length; ++i){
                this.positions[i] = this.restrict(this.positions[i]);
            }
            this.updateGeometries();
        }
    }

    setGeometryColor(g,c){
        g.addVertexAttribute('color',Float32Array,3);
        var colors = new Float32Array(g.vertexCount()*3);
        for(var i=0; i<colors.length; i+=3){
            colors[i] = c.r;
            colors[i+1] = c.g;
            colors[i+2] = c.b;
        }
        g.setVertexAttribute('color', colors);
    }

    updateGeometries() {

        var shape = this.inputPersist.shape;

        var arr_g = [];
        var arr_g_s = [];
        for(var i=0; i<this.positions.length; ++i){
            var g = this.inputPersist.shape.clone();
            this.g[i] = g;
            this.updateGeometryId(g, i);
            this.resetVerticesPositions(g,shape);
            var p = this.positions[i];
            var s = this.scales[i];
            g.scale(s.x,s.y,s.z);
            g.translate(p.x,p.y,p.z);
            this.setGeometryColor(g,this.colors[i]);
            if(this.selected[i]){
                arr_g_s.push(g);
            }else{
                arr_g.push(g);
            }
        }
        this.mesh.geometry.dispose();
        this.selectMesh.geometry.dispose();

        this.mesh.geometry = BufferTriGeometry.merge(arr_g);
        this.selectMesh.geometry = BufferTriGeometry.merge(arr_g_s);
    }

    // protected
    deletePositionAtIndex(idx){
        delete this.selected[idx];
        for(var i=idx; i<this.positions.length-1; ++i){
            this.positions[i] = this.positions[i+1];
            this.scales[i] = this.scales[i+1];
            this.colors[i] = this.colors[i+1];
            this.g[i] = this.g[i+1];
            this.updateGeometryId(this.g[i], i);
        }
        this.positions.length = this.positions.length-1;
        this.colors.length = this.colors.length-1;
        this.scales.length = this.scales.length-1;
        this.g.length = this.g.length-1;
        this.updateGeometries();
    }

    // For this widget, the closer element is searched with respect to the scale.
    findCloserPosition(point){
        var tmp = new Vector3();
        var min_dist = tmp.subVectors(point, this.positions[0]).divide(this.scales[0]).length();
        var min_i = 0;
        for(var i=1; i<this.positions.length; ++i){
            var d = tmp.subVectors(point, this.positions[i]).divide(this.scales[i]).length();
            if(d < min_dist){
                min_dist = d;
                min_i = i;
            }
        }
        return min_i;
    }

    // position / material / scale
    addManipulator(p, c, s){
        this.positions.push(this.restrict(p.clone()));
        this.colors.push(c.clone());
        this.scales.push(s.clone());
        this.g.push(this.inputPersist.shape.clone());
        this.updateGeometryId(this.g[this.g.length-1], this.g.length-1);
    }

    // API Function
    setNewPosition(event){
        if(this.dragging === null && this.limit > this.positions.length){
            this.override = null;
            this.selected = {};
            this.addManipulator(event.cvs3dEvent.mouseData.underMouse.first.point, this.inputPersist.color, this.inputPersist.scale);
            this.updateGeometries();
            this.doTrigger();
        }else{
            // resume propagation, as we have finally not captured this event.
            event.cvs3dEvent.doPropagate();
        }
    }

    emitData(){
        this.emit('data', { "positions" : this.buildOutput() });
    }

    static attachTo(appDesc, attrs, div) {
        var dt = new Widget3DRichPositions(pkgDesc, appDesc, attrs);
        return dt;
    }
}

module.exports = Widget3DRichPositions;
