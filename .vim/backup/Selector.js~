class Selector {
    constructor(parent, container) {
        this.parent = parent;
        this.container = container;
        // translateZ(0) avoid paint glitches in chrome as it forces a repaint every time
        this.div = $('<div/>', { id: 'selector', hidden: true, style: "border: 1px dotted #000; position: absolute; z-index: 100; transform: translateZ(0);" });
        this.x1 = 0;
        this.x2 = 0;
        this.y1 = 0;
        this.y2 = 0;

        this.startEventHandler = this.onSelectionStart.bind(this);
        this.moveEventHandler  = this.onSelectionMove.bind(this);
        this.stopEventHandler  = this.onSelectionStop.bind(this);

        // offset difference relative to pageX/Y
        // we can't use offsetX and offsetY directly cause their value will be 0
        // if we go over another div
        this.diffX = null;
        this.diffY = null;

        this.onSelectCb = null;
        this.onSelectingCb = null;
        this.onDeselectCb = null;

        this.selection = []; // list of selected divs

        this.initialize();
    }

    initialize() {
        this.container.append(this.div);
        this.container.off('mousedown', this.startEventHandler);
        this.container.off('mousemove', this.moveEventHandler);
        this.container.off('mouseup',   this.stopEventHandler);
        this.container.on('mousedown', this.startEventHandler);
        this.container.on('mousemove', this.moveEventHandler);
        this.container.on('mouseup',   this.stopEventHandler);
    }

    getSelection() {
        return this.selection;
    }

    deselect() {
        this.onDeselectCb(this.selection);
        this.selection = [];
    }

    isSelected(div) {
        var selected = false;
        _.each(this.selection, (selectedDiv) => {
            if( $(div).is( $(selectedDiv) ) ) {
                selected = true;
                return false; // end of loop
            }
        });
        return selected;
    }

    addToSelection(div) {
        this.selection.push(div);
        this.onSelectCb(this.selection);
    }

    removeFromSelection(div) {
        var i = 0;

        // find the index
        _.each(this.selection, (selectedDiv, index) => {
            if( $(div).is( $(selectedDiv) ) ) {
                i = index;
                return false; // end of loop
            }
        });

        this.selection.splice(i, 1);
        this.onDeselectCb([div]);
    }

    toggleSelection(div) {
        if( this.isSelected(div) ) {
            this.removeFromSelection(div);
        }
        else {
            this.addToSelection(div);
        }
        this.handleSelectionMenu();
    }

    onSelect( cb ) {
        this.onSelectCb = cb;
    }

    onSelecting( cb ) {
        this.onSelectingCb = cb;
    }

    onDeselect( cb ) {
        this.onDeselectCb = cb;
    }

    reCalc() {
        var x3 = Math.min(this.x1,this.x2);
        var x4 = Math.max(this.x1,this.x2);
        var y3 = Math.min(this.y1,this.y2);
        var y4 = Math.max(this.y1,this.y2);

        this.div[0].style.left = (x3 - this.diffX) + 'px';
        this.div[0].style.top = (y3 - this.diffY) + 'px';
        this.div[0].style.width = (x4 - x3) + 'px';
        this.div[0].style.height = (y4 - y3) + 'px';
    }

    onSelectionStart(e) {
        // capture only if:
        // - it's left click
        // - it's over the container
        // - it's not over a container's button
        // - it's not over a "capture-left-click" item
        if( e.which === 1 &&
            this.container.find('.btn:hover').length == 0 &&
            this.container.find('.nodrag:hover').length == 0 &&
            this.container.find('.jsplumb-connector:hover').length == 0 &&
            this.container.find('.capture-left-click:hover').length == 0
        ) {
            if( this.container.is(':hover') ) {
                // we're starting a selection
                e.preventDefault();
                e.stopPropagation();

                // remove previous selection
                if( this.onDeselectCb ) {
                    this.onDeselectCb(this.selection);
                    this.selection = [];
                }

                this.selecting = true;
                this.div[0].hidden = 0;
                this.x1 = this.x2 = e.pageX;
                this.y1 = this.y2 = e.pageY;


                var rect = e.currentTarget.getBoundingClientRect();
                this.diffX = rect.left;
                this.diffY = rect.top;
                this.reCalc();
            }
        }
    }

    onSelectionMove(e) {
        if( this.selecting ) {
            e.preventDefault();
            e.stopPropagation();

            //console.log('[SELECTION] moving');
            this.x2 = e.pageX;
            this.y2 = e.pageY;
            this.reCalc();

            if( this.onSelectingCb ) {
                // now we have our area, find all divs in it and return
                // result to the onSelectCb
                this.findCardDivs({
                    left   : Math.min(this.x1, this.x2),
                    right  : Math.max(this.x1, this.x2),
                    top    : Math.min(this.y1, this.y2),
                    bottom : Math.max(this.y1, this.y2)
                }, (divs) => {
                    this.selection = divs;
                    this.handleSelectionMenu();
                    this.onSelectingCb(this.selection);
                });
            }
        }
    }

    onSelectionStop(e) {
        if( this.selecting && e.which === 1 ) {
            e.preventDefault();
            e.stopPropagation();

            //console.log('[SELECTION] stop');
            this.selecting = false;
            this.div[0].hidden = 1;

            if( this.onSelectCb ) {
                // now we have our area, find all divs in it and return
                // result to the onSelectCb
                this.findCardDivs({
                    left   : Math.min(this.x1, this.x2),
                    right  : Math.max(this.x1, this.x2),
                    top    : Math.min(this.y1, this.y2),
                    bottom : Math.max(this.y1, this.y2)
                }, (divs) => {
                    this.selection = divs;
                    this.handleSelectionMenu();
                    this.onSelectCb(this.selection);
                });
            }
        }
    }

    findCardDivs( area, cb ) {
        var self = this;
        var selectedCards = [];
        this.container.find('.card, .connection-control').each(function() {
            if( self._intersects( $(this), area ) ) {
                selectedCards.push($(this));
            }
        });

        cb(selectedCards);
    }

    // utilities
    _intersects( div, area ) {
        var r1 = $(div)[0].getBoundingClientRect();
        var r2 = area;
        var res = !(r2.left > r1.right ||
           r2.right < r1.left ||
           r2.top > r1.bottom ||
           r2.bottom < r1.top);
        return res;
    }

    // show/hide the selection menu if we have more than 2 divs selected
    handleSelectionMenu() {
        if( this.selection.length > 1 ) {
            this.parent.view.div.find('.selection-menu').show();
        }
        else {
            this.parent.view.div.find('.selection-menu').hide();
        }
    }
}

export default Selector;
