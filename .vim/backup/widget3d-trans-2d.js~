import { $, env, Widget3D, Type } from '@dualbox/dualbox';
import { SphereBufferGeometry, BufferTriGeometry, BufferGeometry, Geometry, Mesh, MeshBasicMaterial, Object3D, Segment3, Vector3, Matrix4, Plane, Quaternion} from '@dualbox/dualbox-lib-xthree';
var pkgDesc = require('../package.json');

var DualboxTypesAll3D = require('@dualbox/dualbox-type-all3d');

var specialBindings = {
    rotate:     ["initRotate", "runRotate", "stopRotate"],
    scale:      ["initScale", "runScale", "stopScale"],
    translate:  ["initTranslate", "runTranslate", "stopTranslate"]
};

var sbMeshes = {
    translate:"transmesh",
    rotate:"rotmesh",
    scale:"scalemesh"
};

var pAOV = Widget3D.pushArrObjVal;
var rmIAO = Widget3D.rmIdxInArrObj;

/**
 *  Widget to set and move position on a scene mesh.
 *
 *  Improvement notes :
 *      - add possibility to restrict the transforming to some objects in the scene.
 *        It could be an input array of mesh names on which transforming is allowed.
 */
class Widget3DTrans2D extends Widget3D {
    constructor(pkgDesc, appDesc, options) {
        super(pkgDesc, appDesc, options);

        // clone appDesc to be able to redefine the special events.
        this.appDesc = JSON.parse(JSON.stringify(this.appDesc));
        var evts = this.appDesc.attr.mouse || {};
        var to_rm = {};
        var that = this;
        Object.keys(evts).forEach(function (key) {
            for(var i=0; i<evts[key].length; ++i){
                var bind = evts[key][i];
                var buffered = key.search("buffered") === 0;
                var buff_tag = "";
                if(buffered){
                    var seq = key.split("_");
                    buff_tag = seq[0]+"_";
                    key = key.replace(buff_tag,"");
                }
                if(specialBindings[bind]){
                    switch(bind){
                        case "rotate":
                        case "scale":
                        case "translate":
                            {
                                var touch = key.search("touchstart") === 0;
                                var butt = touch || key[9] === ":" || key[9] === undefined ? "" : key[9];
                                // Number of touches, if relevant
                                var nt = touch && key.length > 10 ? key[10] : "";
                                if( (key.search("mousedown") !== 0 ||  (butt !== "0" && butt !== "1" && butt !=="2")) && !touch){
                                    throw "Error : Widget3DTrans2D special binding 'slide' has not been made to handle something else than mousedown0, mousdown1 or mousdown2 and touchstart. Please refer to documentation.";
                                }
                                var st_evt = buff_tag+(touch ? "touchstart" : "mousedown") + nt;
                                var stop_evt = buff_tag+(touch ? "touchend" : "mouseup") + nt;
                                var mv_evt = buff_tag+(touch ? "touchmove" : "mousemove") + nt;
                                pAOV(to_rm,key,i);
                                pAOV(evts,st_evt+butt+":widget:"+that.id+":"+sbMeshes[bind],specialBindings[bind][0]);
                                pAOV(evts,mv_evt,specialBindings[bind][1]);
                                pAOV(evts,stop_evt+butt,specialBindings[bind][2]);
                            }
                        break;
                        default:
                            throw "Error : bind "+bind+" is in the special binding list but is not recognized in the constructor.";
                        break;
                    }
                }
                key = buff_tag + key;
            }
        });
        // remove all the special bindings that have been found
        Object.keys(to_rm).forEach(function (key) {
            var arr = to_rm[key];
            for(var i=0; i<arr.length; ++i){
                rmIAO(evts, key, i);
            }
        });

        var tag = 'mousemove:widget:'+this.id;
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageHover");
        tag = 'mousemove:scene';
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageOut");
        tag = 'mousemove:background';
        if(!evts[tag]){
            evts[tag] = [];
        }
        evts[tag].push("manageOut");

        this.overrideInputs = ["matrix"];
        this.initOverride();
    }

    registerEvents() {
        super.registerEvents();
        this.registerUIEvent("setValue", this.setValue.bind(this));
    }

    init3D(){

        this.initialValues = {
            matrix:new Matrix4()
        };

        this.inputPersist = {
            visible:true,
            mat:{
                rot:null,
                trans:null,
                scale:null,
                hover:{
                    rot:null,
                    trans:null,
                    scale:null
                }
            }
        };

        // We use an Object3D to store the current transformation since
        // it has some handly transformation functions
        this.transfo = new Object3D();

        // Mesh for the pointer of the slider.
        this.transMesh = new Mesh(
            new BufferTriGeometry(),
            new MeshBasicMaterial()
        );
        this.scaleMesh = new Mesh(
            new BufferTriGeometry(),
            new MeshBasicMaterial()
        );
        this.rotMesh = new Mesh(
            new BufferTriGeometry(),
            new MeshBasicMaterial()
        );

        this.setSceneMeshNames();

        this.canvas3d.widgetGroup.add(this.transMesh);
        this.canvas3d.widgetGroup.add(this.scaleMesh);
        this.canvas3d.widgetGroup.add(this.rotMesh);

        // for now the plane is always X/Y
        // could be an input
        this.plane = new Plane(new Vector3(0,0,1), 0);
        this.plane.normalize();

        this.translating = false;
        this.rotating = false;
        this.scaling = false;

        // the point and transformation after a click triggering an init.
        // Will be used to have a better accuracy when running the transformations.
        this.initClic = new Vector3();
        this.initTransfo = new Object3D();

        this.timeoutTrigger =  null;
    }


    setValue(data){
        var m = data.args instanceof Matrix4 ? data.args : Matrix4.fromJSON(data.args);
        if(!m.equals(this.transfo.matrix)){
            this.setTransformationFromMatrix(m);
            this.trigger({ "matrix" : this.transfo.matrix });
            this.override = null;
            console.profile("translation");
        }
    }

    computeVisibility(){
        var v = this.visible && this.inputPersist.visible;
        this.transMesh.visible = v;
        this.scaleMesh.visible = v;
        this.rotMesh.visible = v;
    }

    triggerWithTimeout(){
        if(this.timeoutTrigger === null){
            var that = this;
            this.timeoutTrigger = setTimeout(
                function(){
                    clearTimeout(that.timeoutTrigger);
                    that.timeoutTrigger = null;
                    that.trigger({ "matrix" : this.transfo.matrix });
                },
                60
            );
        }
    }

    isTransforming(){
        return this.translating || this.rotating || this.scaling;
    }

    // Set scenenodes names.
    // All meshes children of those nodes will have their names
    // concat with this.id+"#"+"transMesh"/sclaenode/rotMesh+"#";
    setSceneMeshNames(){
        this.transMesh.name = this.id+"#"+"transmesh";
        this.scaleMesh.name = this.id+"#"+"scalemesh";
        this.rotMesh.name = this.id+"#"+"rotmesh";
        this.computeVisibility();
    }

    // private
    setTransformationFromMatrix(m){
        var dec = {
            translation : new Vector3(),
            quaternion : new Quaternion(),
            scale : new Vector3()
        };
        m.decompose(dec.translation, dec.quaternion, dec.scale);
        dec.quaternion.normalize();
        var compare_obj = new Object3D();
        compare_obj.position.copy(dec.translation);
        compare_obj.rotation.setFromQuaternion(dec.quaternion);
        compare_obj.scale.copy(dec.scale);

        this.transfo.position.copy(compare_obj.position);
        this.transfo.rotation.copy(compare_obj.rotation);
        this.transfo.scale.copy(compare_obj.scale);

        this.transfo.updateMatrix();
    }

    updateMeshesTransfo(){
        var keys = ['transMesh','scaleMesh','rotMesh'];
        for(var i=0; i<keys.length; ++i){
            // Set according to build matrix
            this[keys[i]].position.copy(this.transfo.position);
            this[keys[i]].rotation.copy(this.transfo.rotation);
            this[keys[i]].scale.copy(this.transfo.scale);
            // Three js will not update matrices before the next render,
            // so we do it here to ensure any following computation
            // (like ray tracing) will take the transformation into account
            this[keys[i]].updateMatrix();
            this[keys[i]].updateMatrixWorld();
        }
    }

    setPersistentInputValues(){
        var inVal = this.inputValue;

        this.inputPersist.visible = inVal.visible;

        this.inputPersist.mat = {
            rot:inVal.matRot,
            trans:inVal.matTrans,
            scale:inVal.matScale,
            hover:{
                rot:inVal.matHoverRot,
                trans:inVal.matHoverTrans,
                scale:inVal.matHoverScale,
            }
        };

        this.transMesh.geometry = inVal.shapeTrans;
        this.scaleMesh.geometry = inVal.shapeScale;
        this.rotMesh.geometry = inVal.shapeRot;

        this.transMesh.material = inVal.matTrans;
        this.scaleMesh.material = inVal.matScale;
        this.rotMesh.material = inVal.matRot;

        this.updateMeshesTransfo();

        // ensure the plane is normalized
        this.plane = this.inputValue.plane.clone();
        this.plane.normalize();

        this.computeVisibility();
    }

    // This will override the current position (set by the user)
    // with the position determined from the inputs.
    // this.override contains which inputs must override the current position.
    overrideUserInputs(){
        var inVal = this.inputValue;
        var changed = this.override;

        if(changed.matrix){
            this.setTransformationFromMatrix(inVal.matrix);
            this.initialValues.matrix.copy(inVal.matrix)
        }
    }

    hide(){
        super.hide();
        this.computeVisibility();
    }
    show(){
        super.show();
        this.computeVisibility();
    }

    import(val) {
        this.initialValues = { matrix: Type.deserialize(val) };
        this.setTransformationFromMatrix(Type.deserialize(val));
        this.trigger({ "matrix" : this.transfo.matrix });

        this.override = null;
    }

    manageHover(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){
            this.transMesh.material = this.inputPersist.mat.trans;
            this.rotMesh.material = this.inputPersist.mat.rot;
            this.scaleMesh.material = this.inputPersist.mat.scale;
            if(under.on[0] === "widget" && under.on[1] === this.id){
                switch(under.on[2]){
                    case "transmesh":
                        this.transMesh.material = this.inputPersist.mat.hover.trans;
                    break;
                    case "rotmesh":
                        this.rotMesh.material = this.inputPersist.mat.hover.rot;
                    break;
                    case "scalemesh":
                        this.scaleMesh.material = this.inputPersist.mat.hover.scale;
                    break;
                }
            }else{

            }
        }
        event.cvs3dEvent.doPropagate();
    }
    manageOut(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){
            this.transMesh.material = this.inputPersist.mat.trans;
            this.rotMesh.material = this.inputPersist.mat.rot;
            this.scaleMesh.material = this.inputPersist.mat.scale;
        }
        event.cvs3dEvent.doPropagate();
    }

    // API Function
    initTranslate(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){

            this.override = null;

            //if(under.on.length < 3 || under.on[0] !== "widget" || under.on[1] !== this.id){
            //    throw "Error : cannot translate position since the clicked element is not the expected widget or widget element ("+this.id+").";
            //}else{
                this.canvas3d.enslaveWidget3D(this);
                this.translating = true;

                var canvasX = event.cvs3dEvent.mouseData.canvasX;
                var canvasY = event.cvs3dEvent.mouseData.canvasY;

                var caman = this.canvas3d.getCameraMan();

                var ray = caman.getRay(canvasX, canvasY);

                ray.intersectPlane(this.plane, this.initClic);
                this.initTransfo.copy(this.transfo);
            //}
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runTranslate(event){
        if(this.translating){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            var trans = ray.intersectPlane(this.plane, new Vector3());
            if(trans !== null){
                trans.sub(this.initClic);

                this.transfo.copy(this.initTransfo);
                this.transfo.position.add(trans);
                this.transfo.updateMatrix();

                this.updateMeshesTransfo();

                if(this.attr.triggerOnMove){
                    this.trigger({ "matrix" : this.transfo.matrix });
                }
            }
        }
    }

    // API Function
    stopTranslate(event){
        if(this.translating){
            this.canvas3d.freeWidget3D(this);
            this.translating = false;
            if(!this.attr.triggerOnMove){
                this.trigger({ "matrix" : this.transfo.matrix });
            }
        }
    }

    // API Function
    initRotate(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){

            this.override = null;

            //if(under.on.length < 3 || under.on[0] !== "widget" || under.on[1] !== this.id){
            //    throw "Error : cannot rotate position since the clicked element is not the expected widget or widget element ("+this.id+").";
            //}else{
                this.canvas3d.enslaveWidget3D(this);
                this.rotating = true;

                var canvasX = event.cvs3dEvent.mouseData.canvasX;
                var canvasY = event.cvs3dEvent.mouseData.canvasY;

                var caman = this.canvas3d.getCameraMan();

                var ray = caman.getRay(canvasX, canvasY);

                ray.intersectPlane(this.plane, this.initClic);
                this.initTransfo.copy(this.transfo);
            //}
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runRotate(event){
        if(this.rotating){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            var curr = ray.intersectPlane(this.plane, new Vector3());
            if(curr !== null){

                var vec1 = this.initClic.clone().sub(this.initTransfo.position);
                var vec2 = curr.clone().sub(this.initTransfo.position);

                var cross = (new Vector3()).crossVectors(vec1, vec2);
                var dot = vec1.dot(vec2);
                if(cross.length()> 0.0001){ // do not rotate if approximation can fuck everything
                    var angle = Math.sign(cross.z)*Math.acos(dot/(vec1.length()*vec2.length()));

                    this.transfo.copy(this.initTransfo);
                    this.transfo.rotateOnAxis(this.plane.normal, angle);
                    this.transfo.updateMatrix();

                    this.updateMeshesTransfo();

                    if(this.attr.triggerOnMove){
                        this.trigger({ "matrix" : this.transfo.matrix });
                    }
                }
            }
        }
    }

    // API Function
    stopRotate(event){
        if(this.rotating){
            this.canvas3d.freeWidget3D(this);
            this.rotating = false;
            if(!this.attr.triggerOnMove){
                this.trigger({ "matrix" : this.transfo.matrix });
            }
        }
    }

    // API Function
    initScale(event){
        var under = event.cvs3dEvent.mouseData.underMouse;
        if(!this.isTransforming()){

            this.override = null;

            //if(under.on.length < 3 || under.on[0] !== "widget" || under.on[1] !== this.id){
            //    throw "Error : cannot rotate position since the clicked element is not the expected widget or widget element ("+this.id+").";
            //}else{
                this.canvas3d.enslaveWidget3D(this);
                this.scaling = true;

                var canvasX = event.cvs3dEvent.mouseData.canvasX;
                var canvasY = event.cvs3dEvent.mouseData.canvasY;

                var caman = this.canvas3d.getCameraMan();

                var ray = caman.getRay(canvasX, canvasY);

                ray.intersectPlane(this.plane, this.initClic);
                this.initTransfo.copy(this.transfo);
            //}
        }
    }

    // API Function
    // Always drag on scene for now. See improvement notes.
    runScale(event){
        if(this.scaling){
            var canvasX = event.cvs3dEvent.mouseData.canvasX;
            var canvasY = event.cvs3dEvent.mouseData.canvasY;

            var caman = this.canvas3d.getCameraMan();

            var ray = caman.getRay(canvasX, canvasY);

            var curr = ray.intersectPlane(this.plane, new Vector3());
            if(curr !== null){

                var vec1 = this.initClic.clone().sub(this.initTransfo.position);
                var vec2 = curr.clone().sub(this.initTransfo.position);
                var vec2 = curr.clone().sub(this.initTransfo.position);

                var dot = vec1.dot(vec2);

                var scale = Math.sign(dot)*vec2.length()/vec1.length();

                this.transfo.copy(this.initTransfo);
                this.transfo.scale.multiplyScalar(scale);
                this.transfo.updateMatrix();

                this.updateMeshesTransfo();

                if(this.attr.triggerOnMove){
                    this.trigger({ "matrix" : this.transfo.matrix });
                }
            }
        }
    }

    // API Function
    stopScale(event){
        if(this.scaling){
            this.canvas3d.freeWidget3D(this);
            this.scaling = false;
            if(!this.attr.triggerOnMove){
                this.trigger({ "matrix" : this.transfo.matrix });
            }
        }
    }

    onReady() {

        if(this.override){
            this.overrideUserInputs();
        }
        this.setPersistentInputValues();

        this.emit('data', { "matrix" : this.transfo.matrix });

    }

    static attachTo(appDesc, attrs, div) {
        var dt = new Widget3DTrans2D(pkgDesc, appDesc, attrs);
        return dt;
    }
}

module.exports = Widget3DTrans2D;
