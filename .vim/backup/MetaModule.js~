"use strict";

const LoopModule = require('./LoopModule');
const errors = require('../Errors');
const env = require('../Env');
const _ = require('lodash');

// build a meta module "package" description from application's json
var buildMetaModulePackageDescription = function( name, appDesc ) {
    return {
        "name": name,
        "version": "*",
        "description": appDesc.desc,
        "dualbox" : {
            "input"  : appDesc.input,
            "output" : appDesc.output,
        }
    }
}

class MetaModule extends LoopModule {
    /**
     *  @constructor
     *  @param {Object} description The package decription of the module.
     *  @param {string} id A unique id for the module in the graph-browserify.
     */
    constructor( name, metaModuleDesc, moduleDesc, rootApp ) {

        // clone moduleDesc to avoid deep patching the App's json
        var clonedJson = JSON.parse(JSON.stringify(metaModuleDesc));
        var desc = buildMetaModulePackageDescription(name, clonedJson);

        var attrs = {
            'id'           : moduleDesc.id,
            'tag'          : "MetaModule(" + moduleDesc.id + ")",
            'loggerOptions': { userOrigin: true, logLevel: env.getLogLevel() },
            'rootApp'      : rootApp,
            'appDesc'      : moduleDesc
        }
        super(desc, attrs);

        // create an internal DualBox app with with the Json definition
        const App = require('../App'); // require here to avoid circular deps
        this.debug("Creating an internal app", { userOrigin: false });
        this.app = new App( clonedJson, this.id, this.getRootApp() );

        // keep theses data for cloning
        this.name = name;
        this.metaModuleDesc = metaModuleDesc;
        this.moduleDesc = moduleDesc;

        // metamodule specific output gatherers
        this.outputValues = {};
        this.outputReady = {};
        this.outputListeners = {};
    }

    // clone itself with different attributes (but actually, only id matters)
    clone(attributes){
        var moduleDesc = JSON.parse(JSON.stringify(this.moduleDesc));
        moduleDesc.id = attributes.id;

        var node = (new this.constructor(this.name, this.metaModuleDesc, moduleDesc, this.getRootApp()));
        return node;
    }

    reduce(f) {
        super.reduce(f);
        this.app.reduce(f);
    }

    reduceApps(f) {
        super.reduceApps(f);
        f(this.app);
    }

    // Metamodule won't restart if computing (a submodule will)
    // It won't restart when waiting either
    canRestart() {
        return this.isStatus(MetaModule.status.READY, MetaModule.status.AWAITING_DATA);
    }

    stop() {
        this.app.stop();
        super.stop();
    }

    // when we change root app, also change it in the app
    setRootApp(app) {
        super.setRootApp(app);
        this.app.rootApp = app; // dont use setRootApp, it will reduce again
    }

    /*
     *  Debug function to analyze the state of an application.
     *  If the application is stuck, will output the responsible nodes
     */
    analyzeState(spacing = 0) {
        var missingInputs = super.analyzeState(spacing);

        if( !missingInputs ) {
            this.getApp().analyzeState(spacing);
        }
    }

    setLogLevel( logLevel ) {
        super.setLogLevel( logLevel );
        this.getApp().setLogLevel( logLevel );
    }

    setProfiler( b ) {
        super.setProfiler( b );
        this.getApp().setProfiler( b );
    }

    getApp() {
        // return this.loop ? this.looperNode.getApp() : this.app;
        return this.app;
    }

    setAppInput(key, value) {
        // set to app input if we have no loop
        // (the loop will do it itself with deserialized values)
        if( this.loop == null ) {
            this.getApp().setInput(key, value);
        }
    }

    unsetAppInput(key) {
        this.getApp().unsetInput(key);
    }

    // Set up default values into the app
    setDefaultInput( key, value, forceClone){
        // set the default input like usual
        super.setDefaultInput( key, value, false );
        this.setAppInput(key, value);
    }

    // redefine initLooperNode to use this app
    initLooperNode(...args) {
        super.initLooperNode(...args);
        this.looperNode.app = this.app;
    }

    /**
     *  Overwritten from Module
     *  A metamodule never clone.
     */
    shouldCloneInputOnData(node, output, outkey, inkey){
        return false;
    }

    // On data event, set the right input on the app
    onData(data) {
        if( this.isStatus(MetaModule.status.AWAITING_DATA) ) {
            // get keys that were validated
            if( data === null ) console.log('>>> ' + this.id + ' received null data !');
            var keys = this.validateNewKeys(data);

            // for each new valid key, set up the corresponding input
            for(var i=0; i<keys.length; i++) {
                var name  = keys[i];
                var value = this.inputValue[name];
                var valid = this.inputValid[name];

                if( !valid ) {
                    throw new errors.RuntimeError("Parameter '" + name + "' in metamodule '"
                        + this.id + "' should be valid but isn't. Valid: " + valid);
                }
                this.info("setting submodule %s value to %s", this.getApp().getInputModuleName(name), value, { userOrigin: false });
                this.setAppInput(name, value);
            }
        }

        super.onData(data); // launch computation if we're ready
    }

    /*
    clear() {
        super.clear();

        // we should also remove the values from the inputs of the app
        // without triggering invalidations
        var keys = this.app.getInputParameters();
        for(var i=0; i<keys.length; i++) {
            var key = keys[i];
            var nodeName = this.app.getInputModuleName(key);
            var node = this.app.nodes[nodeName];
            node.inputValid["value"] = false;
            delete node.inputValue["value"];
        }
    }
    */

    // remove a previously set app output listener
    removeOutputListener( key ) {
        if( this.outputListeners[key] ) {
            this.getApp().removeOutputListener(key, this.outputListeners[key]);
            delete this.outputListeners[key];
        }
    }

    computeSequential(){
        if( this.isCacheValid() ) {
            // return cached result
            this.emit('data', this.outputValues);
        }
        else {
            this.setStatus(LoopModule.status.COMPUTING);

            // listen on the output nodes
            var keys = this.getApp().getOutputParameters();
            for(var i=0; i<keys.length; i++) {
                this.debug("Binding output function to %s", this.getApp().getOutputModuleName(keys[i]), { userOrigin: false });
                var self = this;
                var key = keys[i];

                // remove previous data listener if existing
                this.removeOutputListener(key);

                this.outputListeners[key] = (function(){ // closure
                    var name = key;
                    return self.interruptible(function(data) {
                        self.debug("[METAMODULE] Reading output from %s: %s", self.app.getOutputModuleName(name), data, { userOrigin: false });
                        self.removeOutputListener(name); // delete this listener
                        self.onOutputReady(name, data);
                    });
                })();

                this.getApp().readOutput(key, this.outputListeners[key]);
            }
        }
    }

    computeParallel() {
        this.error("Metamodules cannot perform any parallel computation (Error occured in " + this.id + ")");
    }

    onOutputReady( name, data ) {
        this.outputReady[name] = true;
        this.outputValues[name] = data;
        var data = {};

        var keys = this.getApp().getOutputParameters();
        for(var i=0; i<keys.length; i++) {
            var name = keys[i];
            if( this.outputReady[name] !== true ) {
                return;
            }
            else {
                data[name] = this.outputValues[name];
            }
        }

        // if we're here, all outputs are collected. Emit the data event
        this.outputReady = {};
        this.outputValues = {};
        this.emit('data', data);
    }

    interrupt(invalidKeys) {
        // removing all output listeners
        var keys = Object.keys(this.outputListeners);
        for(var i=0; i<keys.length; i++) {
            this.removeOutputListener(keys[i]);
        }

        // get the list of invalid keys that are valid here (i.e: not interrupted already)
        // and interrupt the intern app with this list
        var newInvalidKeys = _.filter(invalidKeys, (k) => { return this.inputValid[k] });
        this.getApp().interrupt(newInvalidKeys);

        super.interrupt(invalidKeys);
    }
}

module.exports = MetaModule;
