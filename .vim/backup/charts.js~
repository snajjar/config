/**
 *   Fetch data and Build a Morris.js chart from the attributes:
 *   - div: the target div
 *   - attrs:
 *       - period (mandatory): "day", "week", or "month"
 *       - app (optional): the application name. All apps from this user if unset
 *       - version (optional): the application version. All versions if unset
 */
LineChart = function( div, attrs ) {
    if( !div ) {
        console.error('You didnt provide a valid div for the chart');
    }
    this.div = div;

    if( attrs.period != "day" && attrs.period != "week" && attrs.period != "month" ) {
        console.error('attrs.period should be "day", "week" or "month"');
    }
    this.period = attrs.period;
    this.targetCollectionName = "Instanciations" + this.period[0].toUpperCase() + this.period.substr(1);
    this.targetCollection = window[this.targetCollectionName];
    this.targetSubscription = "select_" + this.targetCollectionName;

    this.timeInterval = 0;

    if( attrs.type ) {
        this.type = attrs.type;
    }
    else {
        this.type = "Area";
    }

    if( attrs.app ) {
        this.app = attrs.app;
    }

    if( attrs.version ) {
        this.version = attrs.version;
    }

    if( attrs.ownerId ) {
        this.ownerId = attrs.ownerId;
    }

    if( attrs.from ) {
        if( moment(attrs.from, "DD/MM/YYYY") < moment("01/02/2018", "DD/MM/YYYY") ) {
            this.from = moment("01/02/2018", "DD/MM/YYYY")
        }
        else {
            this.from = moment(attrs.from, "DD/MM/YYYY");
        }
    }
    else {
        this.from = moment("01/02/2018", "DD/MM/YYYY");
    }

    if( attrs.to ) {
        if( moment(attrs.to, "DD/MM/YYYY") > moment() ) {
            this.to = moment().endOf('day'); // dont search after now
        }
        else {
            this.to = moment(attrs.to, 'DD/MM/YYYY').endOf('day');
        }
    }
    else {
        this.to = moment().endOf('day');
    }

    this.data = [];
}

// subscribe to needed collections
LineChart.prototype.subscribe = function(cb) {
    var self = this;
    Meteor.subscribe(this.targetSubscription, this.buildDataSelector(), {
        onReady: () => { cb.apply(self) },
        onError: (err) => { console.log("Error subscribing to " + this.targetCollectionName + ": " + err); }
    });
}

// build the selector to fetch the right data, depending on the params 
LineChart.prototype.buildDataSelector = function(cb) {
    var selector = {};
    if( this.app ) selector.appName = this.app;
    if( this.version ) selector.appVersion = this.version;

    if( this.from && this.to ) {
        selector.createdAt = {
            $gte: this.from.toDate(),
            $lte: this.to.toDate(),
        }
    }
    else {
        selector.year = moment().year();
    }

    if( this.ownerId ) {
        selector.ownerId = this.ownerId;
    }
    else {
        selector.ownerId = Meteor.userId();
    }

    return selector;
}

// fetch the data needed to display the graph
LineChart.prototype.source = function(cb) {
    this.subscribe(() => {
        // build the selector
        var selector = {};

        // fetch the datas
        this.instanciations = this.targetCollection.find(this.buildDataSelector()).fetch();
        cb();
    });
}

// Data is either an instance of InstanciationDay, InstanciationWeek or InstanciationMonth
LineChart.prototype.getLabelFromData = function( data ) {
    if( this.app ) {
        // we are inside an app, return app name and version
        return data.appName + ' (v: ' + data.appVersion + ')';
    }
    else {
        return data.appName;
    }
}

// Data is either an instance of InstanciationDay, InstanciationWeek or InstanciationMonth
LineChart.prototype.getYKeyFromData = function( data ) {
    if( this.app ) {
        return data.versionId;
    }
    else {
        return data.appId;
    }
}

// Data is either an instance of InstanciationDay, InstanciationWeek or InstanciationMonth
LineChart.prototype.getPeriodFromData = function( data ) {
    if( data.day ) {
        return moment([data.year, data.month, data.day]).format('YYYY-MM-DD');
    }
    else if( data.week ) {
        return data.year + ' W' + (data.week+1);
    }
    else if( data.month ) {
        return moment([data.year, data.month]).format('YYYY-MM');
    }
    else {
        console.error('Could not parse date object ' + JSON.stringify(data));
    }
}

LineChart.prototype.extractData = function(cb) {
    var labels = [];
    var ykeys = [];
    var data = {};

    // extract labels and ykeys
    _.each( this.instanciations, (d) => {
        var label = this.getLabelFromData(d);
        var ykey = this.getYKeyFromData(d);
        var period = this.getPeriodFromData(d);

        // Push label and ykey if it's new ones
        if( ykeys.indexOf(ykey) === -1 ) {
            ykeys.push(ykey);
            labels.push(label);
        }

        if( !data[period] ) {
            data[period] = {};
        }

        // aggregate data on apps/versions
        if( data[period][ykey] ) {
            data[period][ykey] += d.count;
        }
        else {
            data[period][ykey] = d.count;
        }
    });

    // fill missing dates
    if( this.from && this.to ) {
        var now = moment(this.from, "DD/MM/YYYY");
        var to = moment(this.to, "DD/MM/YYYY").endOf('day');

        while( now < to ) {
            // generate fake entity to add a period to the data array
            var entity = {};
            entity.year = now.year();
            entity.month = now.month();

            if( this.period === "week" ) {
                entity.week = now.week();
            }
            else if( this.period === "day" ) {
                entity.day = now.date();
            }

            var period = this.getPeriodFromData(entity);
            if( data[period] === undefined ) {
                data[period] = {};
            }

            now = now.add(1, "day");
        }
    }

    // format data as an array
    var darray = [];
    _.each( data, (val, key) => {
        var o = val;
        o.period = key;
        darray.push(o);
    });


    // fill darray with 0 for missing key values
    _.each(darray, (val) => {
        _.each( ykeys, (ykey) => {
            if( !val[ykey] ) val[ykey] = 0;
        });
    });

    return {
        labels: labels,
        ykeys: ykeys,
        data: darray
    }
}

// compute the fetched data and build the morris chart
LineChart.prototype.buildChart = function(cb) {
    this.source(() => {
        var extracted = this.extractData();
        var params = {
            element: this.div,
            data: extracted.data,
            xkey: "period",
            ykeys: extracted.ykeys,
            labels: extracted.labels,
            pointSize: 2,
            hideHover: true,
            resize: true
        }

        if( window.debugChart ) {
            console.log(JSON.stringify(params, null, 2));
        }

        if( params.ykeys.length > 0 ) {
            try {
                Morris[this.type](params);
                this.forceRender();
            }
            catch(e) {
                console.error(e);
            }
        }
        else {
            $("#" + this.div).append(
                $('<span/>', {
                    class: 'mx-auto d-block text-muted',
                    style: 'font-size: 12px; width: 150px; margin: 100px auto; text-align: center; font-family: monospace;'
                }).text('No data to display')
            );
        }
        cb();
    });
}

// chrome SVG display bug ?
LineChart.prototype.forceRender = function( cb ) {
    setTimeout(() => { $(this.div).resize(); }, 500);
}



/**
 *  Pie chart
 */
PieChart = function( div, attrs ) {
    if( !div ) {
        console.error('You didnt provide a valid div for the chart');
    }
    this.div = div;

    if( attrs.ownerId ) {
        this.ownerId = attrs.ownerId;
    }

    this.year  = attrs.year;
    this.month = attrs.month;

    this.instanciations = {};
}

// subscribe to needed collections
PieChart.prototype.subscribe = function(cb) {
    var self = this;
    Meteor.subscribe("user_InstanciationsMonth", this.buildDataSelector(), {
        onReady: () => { cb.apply(self) },
        onError: (err) => { console.log("Error subscribing to InstanciationsMonth : " + err); }
    });
}

// build the selector to fetch the right data, depending on the params 
PieChart.prototype.buildDataSelector = function(cb) {
    var selector = {};
    if( this.year ) selector.year = this.year;
    if( this.month ) selector.month = this.month;
    if( this.ownerId ) {
        selector.ownerId = this.ownerId;
    }
    else {
        selector.ownerId = Meteor.userId();
    }

    return selector;
}

PieChart.prototype.source = function( cb ) {
    this.subscribe(() => {
        // build the selector
        var selector = {};

        // fetch the datas
        this.instanciations = InstanciationsMonth.find(this.buildDataSelector()).fetch();
        cb();
    });
}

// compute the fetched data and build the morris chart
PieChart.prototype.buildChart = function(cb) {
    this.source(() => {
        var data = this.extractData();
        console.log( JSON.stringify(data, null, 2) );

        Morris.Donut({
            element: 'instanciations-pie-chart',
            data : data
              /*
            data: [
                {label: "Download Sales", value: 12},
                {label: "In-Store Sales", value: 30},
                {label: "Mail-Order Sales", value: 20}
            ]
            */
        });

        cb();
    });
}

PieChart.prototype.extractData = function() {
    var data = {};

    // extract labels and ykeys
    _.each( this.instanciations, (d) => {
        if( !data[d.appName] ) {
            data[d.appName] = 0;
        }

        data[d.appName] += d.count;
    });

    // build as an array
    var d = [];
    _.each( data, (count, appName) => {
        d.push( { label: appName, value: count } );
    });
    return d;
}

