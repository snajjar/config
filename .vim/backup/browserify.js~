var fs = require('fs-extra');
var path = require('path');
var _ = require('lodash');
var colors = require('colors');

var browserify = require('browserify');
var babelify = require('babelify');
var browserifycss = require('browserify-css');
var rollupify = require('rollupify');
var uglifyify = require('uglifyify');
var uglify = require('uglify-js');

// Mecanism to add transform links to this repository when it's missing
var transforms = ["babelify", "browserify-css", "rollupify", "imgurify", "svgify", "uglifyify", "@babel/core", "@babel/preset-env", "urify", "treeify" ];
var transformLinks = [];
var ensureTransforms = function(component) {
    var pkg = require(component + '/package.json');

    _.each( transforms, (transform) => {
        var hasTransform =
            (pkg.dependencies && pkg.dependencies[transform]) ||
            (pkg.devDependencies && pkg.devDependencies[transform]);

        if( hasTransform ) {
            var componentPath = path.dirname(require.resolve(component+'/package.json'));

            // ensure node_modules exists
            fs.ensureDirSync(path.join(componentPath, "node_modules"));
            var linkPath = path.join(componentPath, "node_modules", transform);

            if( transform.indexOf('@babel/') != -1 ) {
                fs.ensureDirSync( path.join(componentPath, "node_modules", "@babel") );
            }

            var targetTransform = path.join(process.cwd(), "node_modules", transform);

            if( !fs.existsSync(linkPath) ) {
                // create a symlink to the root node_modules
                console.log(('{*] Missing dependency "' + component + '" from ' + componentPath +
                    ': creating temporary symlink to build folder').yellow);
                fs.symlinkSync(targetTransform, linkPath, 'dir');
                transformLinks.push(linkPath);
            }
        }
   });
}

var cleanTransforms = function() {
    _.each(transformLinks, (linkPath) => {
        fs.removeSync(linkPath);
    });
}

var removeLocalDualboxLink = function() {
    var localNpmPath = path.join(process.cwd(), 'node_modules', this.name);
    fs.removeSync(localNpmPath);
}

var browserifyBuild = function(args, app, deps, buildDir, cwd) {
    // path for browserify to look for modules (will also look on global npm folder, as we did set NODE_PATH)
    var outputFile = path.join(cwd, args['o']);
    var sourcePaths = process.env['NODE_PATH'].split(':') || [];
    sourcePaths.push(path.join(buildDir, "node_modules"));
    var debug = args['debug'] !== undefined;
    var minify = !debug || args['minify']==true;

    // create browserify with options
    var opts = {
        'fullPaths' : !debug,
        'debug' : debug,
        'paths' : sourcePaths, // search for modules in spm cache path
        'baseDir' : buildDir
    }
    var b = browserify(null, opts);

    // add app.json
    var jsonPath = path.join(buildDir, 'app.json');
    fs.copySync(args['_'][0], jsonPath);
    b.require(jsonPath, { expose: 'app.json' });

    // add other scripts (or dualbox init.js)
    if( args["_"].length > 1 ) {
        for(var i=1; i<args["_"].length; i++) {
            // user provided scripts, copy into build directory
            var fname = args["_"][i];
            fs.copySync(fname, buildDir);
            //console.log('adding file ' + path.join(buildDir,fname));
            b.add(path.join(buildDir,fname));
        }
    }
    else {
        var initFilePath = path.join(__dirname, '_dualbox_init.js');
        //console.log('adding file ' + initFilePath)
        b.add(initFilePath);
    }

    // add all dependencies
    _.each(deps, function(depList, listName) {
        _.each(depList, (version, component) => {
            if( component.indexOf('dualbox-core') !== 0 ) {
                ensureTransforms(component);
                b.require(component, { paths : sourcePaths });
            }
        });
    });

    b.transform(rollupify, { global: true });

    // apply babelify - UNECESSARY: should be done at build time
    b.transform(babelify, { presets: ['@babel/preset-env'], compact: false, global: true })

    // apply browserify-css transform
    b.transform(browserifycss, { autoInject: true, global: true })

    // if not built in debug mode, minify the bundle
    // apply uglifyjs transform AND apply uglify transform at the end
    if( minify ) {
        // pre-transform for compression
        b.transform('uglifyify', { global: true, sourceMap: false });
    }

    // build bundle
    return new Promise((resolve, reject) => {
        try {
            var outputStream = fs.createWriteStream(outputFile);
            var onError = function(err) {
                cleanTransforms();
                reject(err);
            };

            if( minify ) {
                b.bundle(function(err, buf) {
                    if( err ) {
                        onError(err);
                        return;
                    }

                    // minify the result
                    var minified = uglify.minify(buf.toString());
                    outputStream.write(minified.code);
                    outputStream.end();
                });
            }
            else {
                b.bundle().pipe(outputStream);
            }

            outputStream.on('finish', () => {
                cleanTransforms();
                resolve();
            });
        }
        catch(e) {
            reject(e);
        }
    });
}

process.on('message', async message => {
    try {
        var result = await browserifyBuild(message.args, message.app, message.deps, message.buildDir, message.cwd );
        process.send("");
    }
    catch(e) {
        console.error(e.message.red);
        console.error(e.stack.red);
        process.exit(-1);
    }
});


