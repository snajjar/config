<style>
.card-ui {
    background-color: #bff2ca!important;
}

.card-loop {
    /* background-color: #e5e8ea!important; */
    border: 5px double #dddddd;
    border-width: 4px;
}

.card-input {
    background-color: #f5d76e!important;
}

.card-output {
    background-color: #ffb3a7!important;
}

.box-inputs {
    float: left;
    padding-left: 2px;
    padding-right: 5px;
    vertical-align: top;
    text-align: left;
}

.box-outputs {
    float: right;
    padding-left: 5px;
    padding-right: 2px;
    vertical-align: top;
    text-align: right;
}

.dualbox-graph-canvas .card, .card-node {
    /*border: 1px solid #dddddd;*/
    box-shadow: 1px 1px 5px #716f6f;
    opacity: 1;
    cursor: pointer;
    z-index: 20;
    position: absolute;

    -webkit-transition: -webkit-box-shadow 0.15s ease-in;
    -moz-transition: -moz-box-shadow 0.15s ease-in;
    -o-transition: -o-box-shadow 0.15s ease-in;
    transition: box-shadow 0.15s ease-in;

    color: #4d4d4d;
    user-select: none;
    padding: 0px 8px 0px 8px;
    overflow:hidden;
    background-color: #fff;
    -moz-border-radius: 3px;
    border-radius:3px;
    font-size: 14px;
    font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
}

.card-node .card-top {
    padding-top: 2px;
}

.card-node .card-bottom {
    padding-bottom: 2px;
    text-align: center;
    line-height: 14px;
    white-space: nowrap;
}

.card-node hr {
    margin-top: 2px;
    margin-bottom: 2px;
    border-color: rgba(0,0,0,0.1);
    margin-left: -8px;
    margin-right: -8px;
}

.card-node:hover {
    border-color: #80b2fc;
    box-shadow: 1px 1px 10px #80b2fc;
}

.card-node.selected, .card-node.selected:hover {
    border-color: #0066ff;
    box-shadow: 1px 1px 10px #0066ff;
}


.card-node .title {
    vertical-align:top;
    font-weight: bold;
}

.card-node .subtitle {
    color:#929292;
    font-size: 11px;
    font-style: italic;
    vertical-align:center;
    font-family: tahoma, sans-serif;
}

.card-node .input {
    font-size: 13px;
    color: #8c8c8c;
}

.card-node .output {
    font-size: 13px;
    color: #8c8c8c;
    text-align:right;
}

.card-node .jsplumb-endpoint.active svg circle {
    /* fill: #99ff33 */
    stroke: #59b300;
}

.point {
    /* display: inline-block; */
    display: none;
    position: relative;
    top: 3px;
    margin-right: 5px;
    margin-left: 5px;
}

.dualbox-io {
    overflow: visible;
    margin-left: -8px;
    margin-right: -8px;
}

.box-inputs {
    display: flex;
    justify-content: space-between;
    position: relative;
    padding: 0;
    pointer-events: none;
}

.types {
    color: #6c757d!important;
    opacity: 0.7;
    pointer-events: none;
}

.box-inputs .types {
    display: inline-block;
}

.box-inputs .name {
    display: inline-block;
}

.box-inputs .type {
    display: block;
    text-align: right;
}

.box-inputs .point {
    display: block;
}

.box-inputs .name {
    display: block;
}

.box-outputs {
    display: flex;
    justify-content: center;
    position: relative;
    padding: 0;
    pointer-events: none;
}

.box-outputs .types {
    display: inline-block;
}

.box-outputs .point {
    display: inline-block;
}

.box-outputs .name {
    display: inline-block;
}

.box-outputs .type {
    display: block;
    text-align: left;
}

.box-outputs .point {
    display: block;
}

.box-outputs .name {
    display: block;
}

span.feedback {
    font-weight: bold;
}

.event-dock {
    background-color: rgb(136, 137, 138);
    background-color:   #a6a6a6;
    width: calc(100% + 18px);
    height: 12px;
    z-index: 3!important;
}

.event-dock-top {
    margin-left: -9px;
    margin-right: -9px;
    margin-top: -3px;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    margin-bottom: 4px;
}

.event-dock-bottom {
    margin-left: -9px;
    margin-right: -9px;
    margin-bottom: -3px;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    margin-top: 4px;
    height: 11px; /* shorter because of box-shadow */
}

.event-label {
    z-index: 21;
    padding-left: 15px;
    transform: rotate(-90deg) translate(0%, -50%)!important;
    transform-origin: 0% 0%;
    color: #6c757d!important;
    font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
    font-size: 14px;
    opacity: 0.7;
    cursor: pointer;
}

.transparent {
    opacity: 0.3!important;
}

.card-node {
    position: relative;
}

.card-comment {
    position: absolute;
    top: 0;
    right: 0;
    margin-top: -22px;
    color: #f4ad42!important;
}

.card-problem {
    position: absolute;
    top: 0;
    left: 0;
    margin-top: -22px;
    color: red!important;
}

.card-snapshot {

}

.card-snapshot-idle {
    border: 2px solid gray!important;
    box-shadow: 1px 1px 5px gray!important;
    opacity: 0.7!important;
}

.card-snapshot-computing {
    border: 2px solid darkgreen!important;
    box-shadow: 1px 1px 5px darkgreen!important;
    opacity: 1!important;
}

.card-snapshot-awaiting-data {
    border: 2px solid blue!important;
    box-shadow: 1px 1px 5px blue!important;
    opacity: 0.7!important;
}

.card-snapshot-ready {
    border: 2px solid lightgreen!important;
    box-shadow: 1px 1px 5px lightgreen!important;
    opacity: 1!important;
}

.card-status {
    position: absolute;
    bottom: 0;
    right: 0;
    left: 0;
    margin-bottom: -26px;
    color: #f4ad42!important;
    font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
    font-weight: bold;
    text-align: center;
}

.card-status-idle {
    color: gray!important;
    min-width: 85px;
}

.card-status-computing {
    color: darkgreen!important;
    min-width: 110px;
}

.card-status-awaiting-data {
    color: blue!important;
    min-width: 85px;
}

.card-status-ready {
    color: lightgreen!important;
    min-width: 85px;
}

.btn-snapshot-details {
    position: relative;
    margin-top: -2px;
    color: inherit;
}
</style>

<template>
    <div class="jtk-node card card-node contextmenu" v-bind:class="{ 'card-loop': n.hasLoop(), 'card-ui': n.isUI(), 'card-metanode': n.isMetanode(), 'card-input': n.isInput(), 'card-output': n.isOutput(), 'card-snapshot': n.hasSnapshot(), 'card-snapshot-idle': n.hasSnapshot() && n.isSnapshotStatus(0), 'card-snapshot-computing': n.hasSnapshot() && n.isSnapshotStatus(1), 'card-snapshot-awaiting-data': n.hasSnapshot() && n.isSnapshotStatus(2), 'card-snapshot-ready': n.hasSnapshot() && n.isSnapshotStatus(3) }" v-bind:id="getId()" v-bind:data-id="getId()" v-bind:data-name="pkg.name" style="overflow: visible;">
        <div v-if="n.hasComment()">
            <div class="card-comment">
                <i class="fas fa-comment-alt" data-container="body" data-toggle="popover" data-placement="top" :data-content="n.getComment()"></i>
            </div>
        </div>

        <div v-if="n.hasSnapshot()">
            <div class="card-status">
                <div v-if="n.isSnapshotStatus(0)">
                    <div class="card-status-idle">
                        <span>IDLE</span>
                        <button class="btn btn-editor-xs btn-outline-secondary btn-outline-discrete btn-snapshot-details d-inline-block" data-id="getId()" v-on:click="openSnapshotDetails"><i class="fas fa-info-circle"></i></button>
                    </div>
                </div>

                <div v-if="n.isSnapshotStatus(1)">
                    <div class="card-status-computing">
                        <span>COMPUTING</span>
                        <button class="btn btn-editor-xs btn-outline-secondary btn-outline-discrete btn-snapshot-details d-inline-block" data-id="getId()" v-on:click="openSnapshotDetails"><i class="fas fa-info-circle"></i></button>
                    </div>
                </div>

                <div v-if="n.isSnapshotStatus(2)">
                    <div class="card-status-awaiting-data">
                        <span>WAITING</span>
                        <button class="btn btn-editor-xs btn-outline-secondary btn-outline-discrete btn-snapshot-details d-inline-block" data-id="getId()" v-on:click="openSnapshotDetails"><i class="fas fa-info-circle"></i></button>
                    </div>
                </div>

                <div v-if="n.isSnapshotStatus(3)">
                    <div class="card-status-ready">
                        <span>READY</span>
                        <button class="btn btn-editor-xs btn-outline-secondary btn-outline-discrete btn-snapshot-details d-inline-block" data-id="getId()" v-on:click="openSnapshotDetails"><i class="fas fa-info-circle"></i></button>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="!example && n.isUI() && !n.isOnAPanel()">
            <div class="card-problem">
                <i class="fas fa-exclamation-circle" data-container="body" data-toggle="popover" data-placement="top" data-content="This UI is not set in a panel. It won't have any effect. Go to the Interface tab to add it to a panel."></i>
            </div>
        </div>

        <div class="card-top">
            <div class="d-flex">
                <span class="title" style="white-space: nowrap; margin-right: 5px;">
                    <span v-if="n.isMetanode()" class="badge badge-secondary"><b>META</b></span>
                    {{n.graphId}}
                    <i v-if="n.isParallel()" class="fas fa-server" style="color: orange;" title="this module is computed in a web worker"></i>
                </span>

                <div class="ml-auto">
                    <button class="btn btn-outline-secondary btn-outline-discrete btn-editor-xs btn-settings" v-on:click="openNodeSettings"><i class="fas fa-cog"></i></button>
                </div>
            </div>
        </div>
        <div v-if="!n.isInput() && !n.isOutput()" class="card-center">
            <hr style="margin-bottom: 5px;"/>
            <div class="dualbox-io" style="overflow: visible;">
                <div class="inputs" style="display: inline-block; float: left;">
                    <div class="box-inputs">
                        <div class="types">
                            <span class="type" v-for="key in getVisibleInputs()" v-bind:data-key="key">
                                {{ n.getInputType(key) }}
                            </span>
                        </div>
                        <div class="points">
                            <div class="point" v-for="key in getVisibleInputs()" v-bind:data-key="key" v-bind:data-type="n.getInputDef(key).type" v-html="point"></div>
                        </div>
                        <div class="names">
                            <span class="name" v-for="key in getVisibleInputs()" v-bind:class="{feedback: n.isFeedbackTarget(key)}" v-bind:data-input="key">
                                <span v-if="n.hasIterator(key)">&lt;{{key}}&gt;</span>
                                <span v-else>{{key}}</span>
                                <small v-if="n.isInputConst(key)"><i class="fas fa-clone transparent"></i></small>
                            </span>
                        </div>
                    </div>
                </div>
                <div class="outputs" style="display: inline-block; float: right">
                    <div class="box-outputs">
                        <div class="names">
                            <span class="name" v-for="key in getVisibleOutputs()" v-bind:class="{feedback: n.isFeedbackTarget(key)}" v-bind:data-output="key">
                                <span v-if="n.hasLoop() && n.hasFeedback(key)">{{key}}</span>
                                <span v-else-if="n.hasLoop() && !n.hasFeedback(key)" v-html='"&lt;"+key+"&gt;"'></span>
                                <span v-else>{{key}}</span>

                                <span v-if="n.hasCacheActivated()">
                                    &nbsp;<i class="fa fa-hdd" title="This module has cache activated"></i>
                                </span>
                            </span>
                        </div>
                        <div class="points">
                            <div class="point" v-for="key in getVisibleOutputs()" v-bind:data-key="key" v-bind:data-type="n.getOutputDef(key).type" v-html="point"></div>
                        </div>
                        <div class="types">
                            <span class="type" v-for="key in getVisibleOutputs()" v-bind:data-key="key">
                                {{ n.getOutputType(key) }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <hr style="margin-top: 5px;"/>
        <div class="card-bottom">
            <span class="subtitle">{{ shortName }}</span>

            <div v-if="n.isMetanode()" class="d-inline-block">
                <button class="btn btn-outline-secondary btn-outline-discrete btn-editor-xs btn-enter-metanode" v-on:click="enterMetanode"><i class="fas fa-sign-in-alt"></i></button>
            </div>

            <!--
                <div v-if="n.isUI()" class="event-dock event-dock-bottom"></div>
            -->
        </div>
    </div>
</template>

<script>
import ContextMenu from '../ContextMenu';
import _ from 'lodash';
import dbutils from '../../m/DualboxUtils';

// fix inputs types and output types position relatively to the div
$.fn.fixCardDisplay = function() {
    var offsetPoint = 12;
    var offsetBorder = parseInt($(this).css("border-top-width"));

    if( $(this).find('.box-inputs').height() === 0 && $(this).find('.box-outputs').height() === 0 ) {
        // if this card has no input/output, remove the card center
        $(this).find('.card-center').remove();
    }
    else {
        // else, adjust the input/output display for endpoints
        // 1) translate inputs by the right amount of pixels to have the circle on the line
        var boxInputs = $(this).find('.box-inputs');

        // fix css names width
        var namesDiv = boxInputs.find('.names');
        namesDiv.css('width', (namesDiv.width()+1) + 'px');

        // translate inputs to the left
        var translateLeft = boxInputs.find('.types').width() + offsetPoint + offsetBorder/2;
        $(this).find('.box-inputs').css('transform', 'translateX(-' + translateLeft + 'px)');

        // adjust inputs main div width
        $(this).find('.inputs').width( $(this).find('.inputs').width() - translateLeft + 10 /* margin */ );


        // 2) translate outputs by the right amount of pixels to have the circle on the line
        var boxOutputs = $(this).find('.box-outputs');

        // fix css names with
        var namesDiv = boxOutputs.find('.names');
        namesDiv.css('width', (namesDiv.width() + 1) + 'px');

        // translate inputs to the right
        var translateRight = boxOutputs.find('.types').width() + offsetPoint + offsetBorder/2;
        $(this).find('.box-outputs').css('transform', 'translateX(' + translateRight + 'px)');

        // adjust output main div width
        $(this).find('.outputs').width( $(this).find('.outputs').width() - translateRight + 10 /* margin */ );

        // fix io width
        //$('.dualbox-io').css('width', (($(this).find('.inputs').width() + $(this).find('.outputs').width()) + "px"));
    }
}

// take the current width and add it as a css property
$.fn.fixWidth = function() {
    var width = $(this).width();
    width += parseInt($(this).css('padding-right'));
    width += parseInt($(this).css('padding-left'));
    width += parseInt($(this).css('border-left-width'));
    width += parseInt($(this).css('border-right-width'));
    $(this).css('width', width + 'px');
}

// find position of element relative to an ancestor matching selector
$.fn.positionFrom = function( selector ) {
    var ancestor = $(this).closest(selector);
    var offset = $(this).offset();
    var ancestorOffset = ancestor.offset();
    return {
        top:  offset.top - ancestorOffset.top,
        left: offset.left - ancestorOffset.left,
    }
}

export default {
    props: [
        "id",     // the module id
        "pkg",    // the module package.json
        "def",    // the module app definition
        "n",      // the GraphNode object (from model)
        "example", // true if this vue is used as an example display (no need to connect)
    ],
    data: function () {
        return {
            shortName: "",
            point: '<svg width="14" height="14" pointer-events="all" position="absolute" version="1.1" xmlns="http://www.w3.org/1999/xhtml"><circle cx="7" cy="7" r="5" version="1.1" xmlns="http://www.w3.org/1999/xhtml" fill="#ffffff" stroke="#727272" style="" stroke-width="2"></circle></svg>',
        }
    },
    beforeUpdate: function() {
        //console.log('[UPDATING] ' + this.n.getUniqId());
    },
    destroyed: function() {
        console.log('[DESTROYED] ' + this.n.getUniqId());
    },
    created: function() {
        this.view = window.dualboxEditor.v;

        //console.log('[CREATED] ' + this.n.getUniqId());
        // We compute the shortname of our box
        if( this.n.isInput() || this.n.isOutput() ) {
            this.shortName = this.n.getType();
        }
        else {
            this.shortName = dbutils.shortName(this.pkg.name);
        }

        this.initializeJsPlumb = () => {
            var self = this;
            var div = $(this.$el);
            var id = this.getId();
            var view = this.view;

            if( !this.example ) {
                if( this.n.isInput() || this.n.isOutput() ) {
                    var type = "*";
                    var input = "value";
                    var output = "value";
                    var offsetTop = $(div).find('.card-top').height() + 12 /* hr size */  - 3;

                    var uuid = [ id, "input",  input].join('#');
                    var ep = this.$parent.jsPlumbInstance.addEndpoint(id,  {
                        isSource : false,
                        isTarget : true,
                        uuid     : uuid,
                        anchor   : [0,0,-1,0,0,offsetTop],
                        maxConnections : 1,
                        parameters : {
                            type: "data",
                            target : {
                                id  : id,
                                input : output
                            }
                        }
                    }, this.$parent.style.inputEndpoint);

                    // add data to the endpoint div so we can identify it easier
                    $(ep.canvas).attr('data-node', id);
                    $(ep.canvas).attr('data-type', 'input');
                    $(ep.canvas).attr('data-input', input);

                    // bind tooltip
                    $(ep.canvas).attr('data-toggle', "tooltip");
                    $(ep.canvas).attr('data-trigger', "hover");
                    $(ep.canvas).attr('data-placement', "left");
                    $(ep.canvas).attr('data-html', "true");
                    var inputType = view.m.getNode(id).getInputType("value");
                    $(ep.canvas).attr('title', "Type: <b>" + inputType + "</b>");
                    $(ep.canvas).tooltip();

                    // bind context menu to the endpoint
                    $(ep.canvas).addClass('capture-right-click');
                    $(ep.canvas).ready(function() {
                        var menu = new ContextMenu(".jsplumb-endpoint-anchor[data-node='"+id.trim()+"'][data-input='" + input + "']", [
                            {
                                name: 'Create input for here',
                                fn: () => {
                                    view.c.createInputFromConnection(id, input);
                                }
                            },
                        ]);
                    });

                    var uuid = [ id, "output", output].join('#');
                    var ep = this.$parent.jsPlumbInstance.addEndpoint(id, {
                        isSource : true,
                        isTarget : false,
                        uuid     : uuid,
                        anchor   : [1,0,1,0,0,offsetTop],
                        parameters : {
                            type: "data",
                            source : {
                                id  : id,
                                output : output
                            }
                        }
                    }, this.$parent.style.outputEndpoint);

                    // add data to the endpoint div so we can identify it easier
                    $(ep.canvas).attr('data-node', id);
                    $(ep.canvas).attr('data-type', "output");
                    $(ep.canvas).attr('data-output', output);

                    // bind tooltip
                    $(ep.canvas).attr('data-toggle', "tooltip");
                    $(ep.canvas).attr('data-trigger', "hover");
                    $(ep.canvas).attr('data-placement', "right");
                    $(ep.canvas).attr('data-html', "true");
                    var outputType = view.m.getNode(id).getOutputType("value");
                    $(ep.canvas).attr('title', "Type: <b>" + outputType + "</b>");
                    $(ep.canvas).tooltip();

                    // bind context menu to the endpoint
                    $(ep.canvas).addClass('capture-right-click');
                    $(ep.canvas).ready(function() {
                        var menu = new ContextMenu(".jsplumb-endpoint-anchor[data-node='"+id.trim()+"'][data-output='" + output.trim() + "']", [
                            {
                                name: 'Create output for here',
                                fn: () => {
                                    view.c.createOutputFromConnection(id, output);
                                }
                            },
                        ]);
                    });
                }
                else {
                    // add input endoints
                    div.find('.box-inputs').find('.point').each( function(index) {
                        $(this).css('visibility', 'hidden').css('opacity', '0'); // replaced by jsPlumb point

                        var input = div.find('.box-inputs').find('.name').eq(index).attr('data-input').trim();
                        var type = view.m.getNode(id).getInputType(input);

                        var offsetTop = $(this).positionFrom('.card').top + $(this).height()/2 - 3;
                        var uuid = [ id, "input",  $(this).data('key')].join('#');
                        var ep = self.$parent.jsPlumbInstance.addEndpoint(id,  {
                            isSource : false,
                            isTarget : true,
                            uuid     : uuid,
                            anchor   : [0,0,-1,0,0,offsetTop],
                            maxConnections : 1,
                            parameters : {
                                type: "data",
                                target : {
                                    id  : id,
                                    input : $(this).data('key')
                                }
                            }
                        }, self.$parent.style.inputEndpoint);

                        // add data to the endpoint div so we can identify it easier
                        $(ep.canvas).attr('data-node', id);
                        $(ep.canvas).attr('data-type', 'input');
                        $(ep.canvas).attr('data-input', input);

                        // bind tooltip
                        $(ep.canvas).attr('data-toggle', "tooltip");
                        $(ep.canvas).attr('data-trigger', "hover");
                        $(ep.canvas).attr('data-placement', "left");
                        $(ep.canvas).attr('data-html', "true");
                        $(ep.canvas).attr('title', "Type:  <b>" + type + "</b>");
                        $(ep.canvas).tooltip();

                        // bind context menu to the endpoint
                        $(ep.canvas).addClass('capture-right-click');
                        $(ep.canvas).ready(function() {
                            var menu = new ContextMenu(".jsplumb-endpoint-anchor[data-node='"+id.trim()+"'][data-input='" + input.trim() + "']", [
                                {
                                    name: 'Create input for here',
                                    fn: () => {
                                        view.c.createInputFromConnection(id, input);
                                    }
                                },
                            ]);
                        });
                    });

                    // add output endpoints
                    div.find('.box-outputs').find('.point').each( function(index) {
                        $(this).css('visibility', 'hidden').css('opacity', '0'); // replaced by jsPlumb point

                        var output = div.find('.box-outputs').find('.name').eq(index).attr('data-output').trim();
                        var type = view.m.getNode(id).getOutputType(output);

                        var offsetTop = $(this).positionFrom('.card').top + $(this).height()/2 - 3;
                        var uuid = [ id, "output", $(this).data('key')].join('#');
                        var ep = self.$parent.jsPlumbInstance.addEndpoint(id, {
                            isSource : true,
                            isTarget : false,
                            uuid     : uuid,
                            anchor   : [1,0,1,0,0,offsetTop],
                            parameters : {
                                type: "data",
                                source : {
                                    id  : id,
                                    output : $(this).data('key')
                                }
                            }
                        }, self.$parent.style.outputEndpoint);

                        // add data to the endpoint div so we can identify it easier
                        $(ep.canvas).attr('data-node', id);
                        $(ep.canvas).attr('data-type', "output");
                        $(ep.canvas).attr('data-output', output);

                        // bind tooltip
                        $(ep.canvas).attr('data-toggle', "tooltip");
                        $(ep.canvas).attr('data-trigger', "hover");
                        $(ep.canvas).attr('data-placement', "right");
                        $(ep.canvas).attr('data-html', "true");
                        $(ep.canvas).attr('title', "Type: <b>" + type + "</b>");
                        $(ep.canvas).tooltip();

                        // bind context menu to the endpoint
                        $(ep.canvas).addClass('capture-right-click');
                        $(ep.canvas).ready(function() {
                            var menu = new ContextMenu(".jsplumb-endpoint-anchor[data-node='"+id.trim()+"'][data-output='" + output.trim() + "']", [
                                {
                                    name: 'Create output for here',
                                    fn: () => {
                                        view.c.createOutputFromConnection(id, output);
                                    }
                                },
                            ]);
                        });
                    });

                    if( this.n.isUI() && view.showEvents ) {
                        // Make this a target for events
                        this.$parent.jsPlumbInstance.makeTarget(id, {
                            isSource:false,
                            isTarget:true,
                            uniqueEndpoint: false,
                            anchor:"Continuous",
                            uuid: id + "#event-in",
                            paintStyle:{ fill:"green" },
                            parameters: {
                                type: "event",
                                target: { "id" : id }
                            },
                        }, self.$parent.style.eventEndpoint);

                        // Create an enpoint to create a new event
                        var ep = this.$parent.jsPlumbInstance.addEndpoint(id,  {
                            isSource : true,
                            isTarget : false,
                            uuid     : id + "#event-out",
                            anchor   : [1, 1, 0, 1, 0, -10],
                            parameters : {
                                type: "event",
                                source: { "id" : id }
                            },
                        }, this.$parent.style.eventEndpoint);

                        // Add overlay here so we don't mess with splitConnection
                        ep.addOverlay(["PlainArrow", { width:15, length:15, location:1, id:"arrow" }]);

                        $(ep.canvas).attr('data-toggle', "tooltip");
                        $(ep.canvas).attr('data-trigger', "hover");
                        $(ep.canvas).attr('data-placement', "bottom");
                        $(ep.canvas).attr('data-html', "true");
                        $(ep.canvas).attr('title', "Connect from here ito add an event that will be triggered when this box is done computing.");
                        $(ep.canvas).tooltip();
                    }
                }

                // Make the div draggable
                this.$parent.jsPlumbInstance.draggable(div, {
                    //containment:true, // not allowed outside of container div
                    drag: function(e) {
                        // TODO: bug. After a repaint(), jsPlumb seems to be broken (connections dont follow on div drag)
                        // It doesn't occur on jsPlumb.reset() instead of creating another instance on beforeUpdate(),
                        // (as it should be), but we can't do that, because JsPlumb is broken on zoom otherwise...
                        // One of thoses problem may be fixed later by updating jsPlumb...
                        // Note: this "fix" may affect performances on drag
                        self.$parent.jsPlumbInstance.repaintEverything();
                    },
                    stop: function(e) {
                        // resize the canvas if necessary
                        self.$parent.canvasSizeHandler.debouncedResize();

                        // set the new position in the graph model
                        var el = self.$parent.jsPlumbInstance.getElement(id);
                        $(el).ready(function() {
                            var pos = self.$parent.jsPlumbInstance.getPosition(el);
                            view.m.getNode(id).setPosition(pos);
                        });
                    }
                });
            }

            return new Promise((resolve) => jsPlumb.ready(resolve));
        };

        this.initialize = async () => {
            var self = this;
            var div = $(this.$el);
            var jsPlumbInstance = this.$parent.jsPlumbInstance;
            var id = this.getId();
            var view = this.view;

            if( !this.example ) {
                // if we have a position, set it
                var position = this.def && this.def.graph && this.def.graph.position;
                if( position ) {
                    var jsPlumbElement = self.$parent.jsPlumbInstance.getElement(id);
                    self.$parent.jsPlumbInstance.setPosition(jsPlumbElement, position);
                }

                // This needs to be registered before draggable
                div.on('mousedown', function(e) {
                    // if this div is not selected already, deselect the other divs
                    if( !self.$parent.selector.isSelected(this) ) {
                        self.$parent.selector.deselect();
                    }
                });

                await this.initializeJsPlumb();

                div.click(function(e) {
                    if( e.ctrlKey ) {
                        view.selector.toggleSelection(this);
                    }
                });

                // enable tooltips
                div.find('[data-toggle="popover"]').popover();

                // Create a contextmenu for the div
                var contextOptions = [
                    {
                        name: 'Remove this box',
                        fn: () => {
                            view.c.removeBox(id);
                        }
                    }
                ];
                if( this.n.isModule() || this.n.isUI() ) {
                    contextOptions.push({
                        name: 'Duplicate this box',
                        fn: () => {
                            view.c.duplicateBox(id);
                        }
                    });
                }
                var nodeMenu = new ContextMenu("#" + id, contextOptions);
            }

            return new Promise(resolve => {
                div.ready(() => {
                    console.log('[INITIALIZED] ' + this.n.getUniqId());
                    resolve();
                });
            });
        };
    },
    updated: async function() {
        console.log('[UPDATED] ' + this.n.getUniqId());

        // we reset jsPlumb before app update (in graph.vue)
        // so we need to initialize again
        return await this.initializeJsPlumb();
    },
    mounted: async function() {
        console.log('[MOUNTED] ' + this.n.getUniqId());
        var div = $(this.$el);
        div.fixCardDisplay();
        div.ready(() => {
            if( !this.example ) {
                div.fixWidth();
            }
        });
        return await this.initialize();
    },
    methods: {
        getId: function() {
            // if this is an example graphNode, change our "id" to "id-junk"
            // to avoid connection jsplumb conflicts with the real node
            return this.example ? this.id + '-junk' : this.id;
        },

        htmlentities: function( s ) {
            return this.view.utils.htmlentities(s);
        },

        getVisibleInputs: function() {
            return this.n.getInputsNames().filter((inputName) => {
                return this.n.isInputVisible(inputName);
            })
        },

        getVisibleOutputs: function() {
            return this.n.getOutputsNames().filter((outputName) => {
                return this.n.isOutputVisible(outputName);
            })
        },

        enterMetanode: function(e) {
            e.preventDefault();
            e.stopPropagation();

            this.view.c.enterMetanode(this.id);
        },

        openNodeSettings: function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.view.openBoxSettings(this.id);
        },

        openSnapshotDetails: function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.view.openDebug(this.id);
        }
    },
    watch: {
        'app': {
            handler: () => {
                console.log('graphVue.app changed');
            },
            deep: true
        }
    }
}

</script>
