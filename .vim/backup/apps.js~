import { Template } from 'meteor/templating';
import { _ } from 'lodash';
import swal from 'sweetalert2'

////////////////////////////////////////////////////
//  AppsPage
//  page that display all applications groups
////

Template.AppsPage.onCreated(function() {
    // subscribe to user applications
    this.autorun(() => {
        subMgr.subscribe('user_Apps');
        subMgr.subscribe('user_AppVersions', {}, { fields: { json: 0, buildError: 0 } });
    });
});

Template.AppsPage.helpers({
    getApps : function() {
        return Apps.find().fetch();
    }
});

Template.AppsPage.events({
    'click .link-to-dashboard' : function(e, t) {
        Router.go('DashboardPage');
    },

    'click .card-app' : function(e, t) {
        Router.go('ApplicationPage', { "_appName" : this.name });
    },

    'click .card-new-app' : function(e, t) {
        swal({
            title: 'Choose a name for your application',
            input: 'text',
            showCancelButton: true,
            confirmButtonText: 'Set this name',
            showLoaderOnConfirm: true,
            preConfirm: (name) => {
                return new Promise((resolve) => {
                    Meteor.call('checkAppNameAvailable', name, function(err, result) {
                        if( !result ) {
                            // app name is taken
                            swal.showValidationError('This application name is already taken.')
                        }
                        resolve();
                    });
                })
            },
            allowOutsideClick: () => !swal.isLoading()
        }).then((result) => {
            // new app name isnt taken
            if( result.value ) {
                Apps.insert({ name: result.value }, function(err) {
                    if( err ) {
                        swal('Oh oh.', err.message, "error");
                    }
                    else {
                        swal("App created !", "", "success").then(() => {
                            Router.go('ApplicationPage', { _appName : result.value });
                        });
                    };
                });
            }
        })
    },
});


////////////////////////////////////////////////////
//  AppsCard
//  Template that display an application card
////

Template.AppCard.onCreated(function() {
    this.autorun(() => {
        var phases = this.data.phases;
        _.each(phases, (id, name) => {
            subMgr.subscribe('select_AppVersions', { '_id' : id }, { fields: { json: 0, buildError: 0 } });
        });
    });
});

Template.AppCard.helpers({
    showPhase : function(p) {
        var versionId = this.phases[p];
        if( versionId ) {
            var version = AppVersions.findOne(versionId);
            if( version ) {
                switch(version.deployStatus) {
                    case "Not deployed":
                    case "In queue":
                    case "building...":
                    case "built":
                        return '<span class="text-orange"><i class="fas fa-wrench fa-spin"></i> ' + version.appVersion + '</span>';

                    case "error":
                        return '<span class="text-red"><i class="fas fa-exclamation-triangle"></i> ' + version.appVersion + '</span>';

                    case "deployed":
                        return '<span class="text-green"><i class="fas fa-cloud-upload-alt"></i> ' + version.appVersion + '</span>';
                    default:
                        return '<span class="text-red">error</span>';
                }
            }
        }
        return '<span class="text-muted"><i class="far fa-circle"></i></span>';
    },
});

////////////////////////////////////////////////////
//  Application Page
//  page to manage an application
////

Template.ApplicationPage.onCreated(function() {

    // subscribe to user applications
    this.autorun(() => {
        this.name = Template.currentData().appName;
        subMgr.subscribe('user_Apps', { name : this.name });
        subMgr.subscribe('user_AppVersions', { appName : this.name }, { fields: { json: 0, buildError: 0 } });
    });
});

Template.ApplicationPage.onRendered(function() {
    // set a hash when we click on a tab, to load the right tab directly on F5
    var self = this;

    // load the tab that is set right now
    if( window.location.hash ) {
        setSelectedTab();
    }
});

Template.ApplicationPage.helpers({
    getApp : function() {
        return Apps.findOne({ name: Template.instance().name });
    },

    emptyApp : function() {
        return Apps.findOne({ name: Template.instance().name }) === undefined;
    },

    showDate : function() {
        return moment(this.createdAt).calendar();
    },

    isDeployedPhase: function(p) {
        return  this.phases[p] !== undefined && this.phases[p] !== null;
    },

    getVersionFromPhase: function(p) {
        var versionId = this.phases[p];
        if( versionId ) {
            var version = AppVersions.findOne(versionId);
            if( version ) return version;
        }
        return {};
    },

    // return all versions sorted by version number
    getVersions: function() {
        var versions = AppVersions.find({ appName: Template.instance().name }).fetch();
        versions = versions.sort( (a, b) => {
            var na = a.appVersion.split('.').map( n => parseInt(n,10) );
            var nb = b.appVersion.split('.').map( n => parseInt(n,10) );

            for(var i=0; i<3; i++) {
                if( na[i] < nb[i] ) {
                    return -1;
                }
                else if( na[i] > nb[i] ) {
                    return 1;
                }
                else {
                    continue
                }
            }

            return 0;
        });
        return versions;
    },
});

Template.ApplicationPage.events({
    "click .link-to-apps" : function(e, t) {
        e.preventDefault();
        Router.go('AppsPage');
    },

    "click .app-edit-name" : function(e, t) {
        var name = this.name;

        swal({
            title: 'Are you sure?',
            text: 'We don\'t recommand using name change if your application is in use. The existing links will be broken and replaced by new ones !',
            type: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, change name !',
            cancelButtonText: 'Abort',
        }).then( (confirmed) => {
            if( confirmed ) {
                swal({
                    title: 'Choose a new name for the application',
                    input: 'text',
                    showCancelButton: true,
                    confirmButtonText: 'Set this name',
                    showLoaderOnConfirm: true,
                    preConfirm: (name) => {
                        return new Promise((resolve) => {
                            Meteor.call('checkAppNameAvailable', name, function(err, result) {
                                if( !result ) {
                                    // app name is taken
                                    swal.showValidationError('This application name is already taken.')
                                }
                                resolve();
                            });
                        })
                    },
                    allowOutsideClick: () => !swal.isLoading()
                }).then((result) => {
                    // new app name isnt taken
                    if( result.value ) {
                        Meteor.call('renameApp', name, result.value, function(err) {
                            if( err ) {
                                swal({
                                  type: 'error',
                                  title: 'Could not rename your app',
                                  html: 'reason: <p style="color: red">' + err.message + '</p>'
                                })
                            }
                            else {
                                swal({
                                  type: 'success',
                                  title: 'Rename success!',
                                  html: 'Your app has been renamed to ' + result.value + '.'
                                }).then(() => {
                                    Router.go('ApplicationPage', { "_appName" : result.value });
                                });
                            }
                        });
                    }
                })
            }
        });
    },

    "click .app-edit-description" : function(e, t) {
        $('.app-description-text').hide();
        $('.app-description-edit').show();
    },

    "click .app-edit-title" : function(e, t) {
        $('.app-title-text').hide();
        $('.app-title-edit').show();
    },

    "click .app-save-description" : function(e, t) {
        var description = $('.app-description-input').val();
        var app = Apps.findOne({ 'name': this.name });
        if( app ) {
            Apps.update(app._id, { $set: { 'description' : description }});
            $('.app-description-text').show();
            $('.app-description-edit').hide();
        }
    },

    "click .app-save-title" : function(e, t) {
        var title = $('.app-title-input').val();
        var app = Apps.findOne({ 'name': this.name });
        if( app ) {
            Apps.update(app._id, { $set: { 'title' : title }});
            $('.app-title-text').show();
            $('.app-title-edit').hide();
        }
    },

    "click .btn-upload-image" : function(e, t) {
        $('.app-image-upload').click();
    },

    "change .app-image-upload": function(e, t){
        var appId = $(e.target).attr('data-appid');
        var func = this;
        var file = e.currentTarget.files[0];
        var reader = new FileReader();
        reader.onload = function(event){
            var buffer = new Uint8Array(reader.result) // convert to binary
            Meteor.call('appImageUpload', file, buffer, appId, (err, result) => {
                if( err ) console.log(err);
            });
        }
        reader.readAsArrayBuffer(file);
    },

    "click .btn-delete-app" : function(e, t) {
        var name = this.name;
        var id = this._id;
        swal({
            title: 'I hope you know what you\'re doing.',
            html: 'This will delete <i>' + name + '</i> and <b>all versions of it</b>.<p class="mt-3 mb-3" style="color: red;">BACKUP WILL NOT BE POSSIBLE</span>.',
            type: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, delete it!',
            confirmButtonColor: '#d33',
            cancelButtonText: 'Abort',
        }).then( (confirmed) => {
            if( confirmed ) {
                swal({
                    title: 'Please enter the name of the application to confirm',
                    input: 'text',
                    type: 'warning',
                    showCancelButton: true,
                    confirmButtonText: 'Delete this application',
                    confirmButtonColor: '#d33',
                    showLoaderOnConfirm: true,
                }).then((result) => {
                    // new app name isnt taken
                    if( result.value ) {
                        if( result.value === name ) {
                            Meteor.call('deleteApplication', id, function(err) {
                                if( err ) {
                                    swal({
                                      type: 'error',
                                      title: 'Could not delete app',
                                      html: 'reason: <p style="color: red">' + err.message + '</p>'
                                    })
                                }
                                else {
                                    swal({
                                      type: 'success',
                                      title: 'delete success!',
                                      html: 'Your app has been deleted.'
                                    }).then(() => {
                                        Router.go('AppsPage');
                                    });
                                }
                            });
                        }
                        else {
                            swal({
                                title: "confirmation failed",
                                text: "The application wasn\'t deleted.",
                                type: "error"
                            });
                        }
                    }
                })
            }
        });
    },

    "click a[data-toggle='tab']" : function(e, t) {
        e.preventDefault()
        $(e.target).tab('show')
        var target = $(e.target).attr("href") // activated tab
        var tab = target.substr(1);
        window.location.hash = target;
    },

    "dragstart .card-version" : function(e, t) {
        $(e.target).addClass('dragged');
        $('.card-phase').addClass('droppable');
        e.originalEvent.dataTransfer.setData('version', $(e.target).attr('data-version'));
    },

    "dragend .card-version" : function(e, t) {
        $(e.target).removeClass('dragged');
        $('.card-phase').removeClass('droppable');
    },

    "dragenter .card-phase" : function(e, t) {
        var phaseDiv = $(e.target).closest('.card-phase');
        var dragCount = phaseDiv.data('dragCount') || 0;
        dragCount++;
        $(phaseDiv).data('dragCount', dragCount);
        $(phaseDiv).addClass('dropready');
    },

    "dragover .card-phase" : function(e, t) {
        e.stopPropagation();
        e.preventDefault();
    },

    "dragleave .card-phase" : function(e, t) {
        var phaseDiv = $(e.target).closest('.card-phase');
        var dragCount = phaseDiv.data('dragCount') || 0;
        dragCount--;
        $(phaseDiv).data('dragCount', dragCount);
        if( dragCount == 0 ) {
            $(phaseDiv).removeClass('dropready');
        }
    },

    "drop .card-phase" : function(e, t) {
        $('.card-phase').removeClass('dropready').data('dragCount', 0);
        $(e.target).removeClass('dropready');

        var self = this;
        var versionName = e.originalEvent.dataTransfer.getData('version');
        var phaseName = $(e.target).closest('.card-phase').attr("data-phase").toLowerCase();

        var cleanInterface = function() {
            $('.card-phase').removeClass('dropready').removeClass('droppable');
            $('.card-version').removeClass('dragged');
        }

        swal({
            title: "Deploy " + versionName + " to " + phaseName + "?",
            type: "confirm",
            showCancelButton: true,
            closeOnConfirm: true,
            type: "warning",
        }).then((result) => {
            if( result.value ) {
                cleanInterface();

                var app = Apps.findOne({ name: self.name });
                var version = AppVersions.findOne({ appName: self.name, appVersion: versionName });

                // update the phase of the app
                var phases = app.phases || {};
                phases[phaseName] = version._id;
                Apps.update(app._id, { $set: { "phases" : phases }});
            }
        });
    },

    "click .deploy-to" : function(e, t) {
        var self = this;
        var versionName = this.appVersion;
        var phaseName = $(e.target).attr('data-phase');

        swal({
            title: "Deploy " + versionName + " to " + phaseName + "?",
            type: "confirm",
            showCancelButton: true,
            closeOnConfirm: true,
            type: "warning",
        }).then((result) => {
            if( result.value ) {
                var app = Apps.findOne({ name: self.appName });
                var version = AppVersions.findOne({ appName: self.appName, appVersion: versionName });

                // update the phase of the app
                var phases = app.phases || {};
                phases[phaseName] = version._id;
                Apps.update(app._id, { $set: { "phases" : phases }});
            }
        });
    },

    "click .card-new-version": function(e, t) {
        e.preventDefault();
        Router.go('VersionPage', { "_appName" : this.name, "_appVersion": "new" });
    },
});

////////////////////////////////////////////////////
//  Version Card
//  Template that show a version on Application Page
////
Template.VersionCard.onCreated(function() {

});

Template.VersionCard.helpers({});
Template.VersionCard.events({
    "click a.link-to-version-page" : function(e, t) {
        e.preventDefault();
        Router.go('VersionPage', { "_appName" : this.appName, "_appVersion": this.appVersion });
    },

    "click a.link-to-build-error" : function(e, t) {
        e.preventDefault();
        Router.go('BuildErrorPage', { "_appName" : this.appName, "_appVersion": this.appVersion });
    }
});


////////////////////////////////////////////////////
//  Version Page
//  page to manage/build a specific version of an app
////

Template.VersionPage.onCreated(function() {
    this.editor = new ReactiveVar(null);

    // subscribe to user applications
    this.tabshown = new ReactiveVar('configuration');
    this.showGraph = new ReactiveVar(true);

    console.log('onCreated called!');
    this.subs = [];

    this.autorun(() => {
        var data = Template.currentData();
        this.name = new ReactiveVar(data && data.appName);
        this.version = new ReactiveVar(data && data.appVersion);

        this.subs = [
            subMgr.subscribe('user_Apps', { name : this.name.get() }),
            subMgr.subscribe('user_AppVersions', { appName : this.name.get(), appVersion: this.version.get() })
        ]
    });
});


Template.VersionPage.onDestroyed(function() {
    var editor = this.editor.get();
    if( editor ) {
        editor._delete();
    }
});

Template.VersionPage.onRendered(function() {
    // create the editor
    var self = this;

    console.log('onRendered called!');

    this.setEditor = function() {
        var editor = document.getElementById("json-editor");
        if( editor && this.version.get() !== "new" ) {
            self.editor.set(new JSONEditor(editor, {
                mode: 'code',
                modes: ['code', 'tree'],
                onChange: function() {
                    $('textarea [name="json"]').val( $(editor).get() );
                },
            }));

            if( self.data.appVersion && self.data.appVersion != "new" ) {
                self.autorun(function() {
                    var version = AppVersions.findOne({ appName: self.data.appName, appVersion: self.data.appVersion });
                    if( version ) {
                        var editor = self.editor.get();
                        editor.set(JSON.parse(version.json || "{}"));
                        editor.setMode("code");
                    }
                });
            }
        }
        else {
            setTimeout(this.setEditor.bind(this), 0);
        }
    }

    this.autorun(() => {
        // check for subs in this tracker so if they changed, it's executed again
        if( !_.isEmpty(this.subs) && self.showGraph.get() == false ) {
            this.setEditor();
        }
    });

    // set a hash when we click on a tab, to load the right tab directly on F5
    var self = this;
    $('a[data-toggle="tab"]').click(function(e) {
        e.preventDefault()
        $(this).tab('show')
        var target = $(e.target).attr("href") // activated tab
        var tab = target.substr(1);
        window.location.hash = target;
        self.tabshown.set(tab);
    });

    // load the tab that is set right now
    if( window.location.hash ) {
        setSelectedTab();
    }
});

Template.VersionPage.helpers({
    getApp : function() {
        return Apps.findOne({ name: Template.instance().name.get() });
    },

    getAppName : function() {
        return Template.instance().name.get();
    },

    getVersionName: function() {
        return Template.instance().version.get();
    },

    hasJSON: function() {
        var version = AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
        if( !version ) return false;
        return version.json !== undefined && version.json !== null &&  version.json !== "";
    },

    showGraph: function() {
        return Template.instance().showGraph.get();
    },

    isDeployed: function() {
        var version = AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
        if( !version ) return false;
        return version.deployStatus == "deployed";
    },

    emptyVersion: function() {
        var app = Apps.findOne({ name: Template.instance().name.get() });
        if( Template.instance().version.get() === "new" ) return false;
        if( app === undefined ) return true;
        return AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() }) === undefined;
    },

    isNewVersion: function() {
        return Template.instance().version.get() === "new";
    },

    getFormType: function() {
        return Template.instance().version.get() === "new" ? "insert" : "update";
    },

    getLastUpdate : function() {
        return moment(this.updatedAt).calendar();
    },

    isCardHidden : function() {
        return Template.instance().version.get() === "new" ? "card-hidden" : "";
    },

    // works only when editing, not for a new version
    getVersion: function() {
        if( Template.instance().version.get() !== "new" ) {
            return AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
        }
        else {
            return undefined;
        }
    },

    isInPhases: function() {
        var p = [];
        var phaseNames = Object.keys(this.phases);
        var version = AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
        if( version ) {
            var id = version._id;

            for(var i=0; i<phaseNames.length; i++) {
                if( id == this.phases[ phaseNames[i] ] ) {
                    return true;
                }
            }
        }

        return false;
    },

    getVersionPhases: function() {
        var p = [];
        var phaseNames = Object.keys(this.phases);
        var version = AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
        if( version ) {
            var id = version._id;

            for(var i=0; i<phaseNames.length; i++) {
                if( id == this.phases[ phaseNames[i] ] ) {
                    p.push( phaseNames[i] );
                }
            }

            return p.join(' ');
        }

        return "";
    },

    getField : function( name ) {
        if( Template.instance().version.get() !== "new" ) {
            var version = AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
            return version[name];
        }
        else {
            return false;
        }
    },

    otherVersions : function() {
        return AppVersions.find({ appName: this.appName }).fetch();
    },
});

Template.VersionPage.events({
    "click .link-to-versions" : function(e, t) {
        e.preventDefault();
        Router.go('ApplicationPage', { '_appName': this.name });
    },

    "click .link-to-json" : function(e, t) {
        e.preventDefault();
        e.stopPropagation();
        t.showGraph.set(false);
    },

    "click .link-to-graph" : function(e, t) {
        e.preventDefault();
        e.stopPropagation();
        t.showGraph.set(true);
    },

    "click .btn-deploy": function(e, t) {
        Router.go('ApplicationPage', { '_appName' : this.appName });
        Meteor.call('deployVersion', this._id, function(err, r) {
            if( err ) {
                swal('Error deploying version', err.reason, "error");
            }
        });
    },

    "change #version-settings-form .form-control" : function(e, t) {
        $('.btn-submit-version-settings-form').prop('disabled', false);
    },

    "click .json-import" : function(e, t) {
        var versionFrom = $(e.target).val();
        console.log('Importing JSON from version ' + versionFrom);

        var version = AppVersions.findOne({ appName: this.appName, appVersion: versionFrom });
        if( version ) {
            var editor = Template.instance().editor.get();
            editor.set( JSON.parse(version.json) );
        }
    },

    "click .btn-delete-version" : function(e, t) {
        var v = this;
        var name = this.appName;
        var version = this.appVersion;
        swal({
            title: 'I hope you know what you\'re doing.',
            html: 'This will delete <i>' + name + '</i> version ' + version + '.<p class="mt-3 mb-3" style="color: red;">BACKUP WILL NOT BE POSSIBLE</span>.',
            type: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, delete it!',
            confirmButtonColor: '#d33',
            cancelButtonText: 'Abort',
        }).then( (confirmed) => {
            if( confirmed ) {
                swal({
                    title: 'Please enter the version of ' + name + ' to confirm',
                    input: 'text',
                    type: 'warning',
                    showCancelButton: true,
                    confirmButtonText: 'Delete this version',
                    confirmButtonColor: '#d33',
                    showLoaderOnConfirm: true,
                }).then((result) => {
                    // new app name isnt taken
                    if( result.value ) {
                        if( result.value === version ) {
                            v.delete();
                            Router.go('ApplicationPage', { '_appName' : name });
                        }
                        else {
                            swal({
                                title: "confirmation failed",
                                text: "The version wasn\'t deleted.",
                                type: "error"
                            });
                        }
                    }
                })
            }
        });
    },

});

// on form submit
AutoForm.addHooks('version-settings-form', {
    onSuccess : function(formType, result) {
        $('.btn-submit-version-settings-form').prop('disabled', true);

        var modifiers = formType == "insert" ? this.insertDoc : this.updateDoc.$set;
        var t = this.template.findParent('VersionPage');
        t.name.set(modifiers.appName);
        t.version.set(modifiers.appVersion);

        if( formType == "insert" ) {
            Router.go('VersionPage', {
                '_appName' : modifiers.appName,
                '_appVersion' : modifiers.appVersion
            });
        }
        return false;
    },

    onError : function(formType, result) {
        swal('Error', result, 'error');
    }
});

// on form submit
AutoForm.addHooks('version-code-form', {
    before : {
        "insert" : function(doc) {
            var json = Template.instance().findParent("VersionPage").editor.get().get();
            doc.json = JSON.stringify(json);
            return doc;
        },

        "update": function(doc) {
            // get the json string from the template
            var t = this.template.findParent("VersionPage");
            var json = t.editor.get().get();
            doc.$set.json = JSON.stringify(json || {});
            return doc;
        },
    },

    onSuccess : function(formType, result) {
        $('#version-code-form .btn-submit').prop('disabled', false); // enable the submit button again
        return false;
    },

    onError : function(formType, result) {
        swal('Error', result, 'error');
    }
});

////////////////////////////////////////////////////
//  Build Error Page
//  Page that display build errors
////

Template.BuildErrorPage.onCreated(function() {
    // subscribe to user applications
    this.name = new ReactiveVar(this.data.appName);
    this.version = new ReactiveVar(this.data.appVersion);

    this.autorun( () => {
        subMgr.subscribe('user_Apps', { name : this.name.get() });
        subMgr.subscribe('user_AppVersions', { appName : this.name.get(), appVersion: this.version.get() }, { fields: { json: 0, buildError: 0 } });
    });
});

Template.BuildErrorPage.helpers({
    getApp : function() {
        return Apps.findOne({ name: Template.instance().name.get() });
    },

    // works only when editing, not for a new version
    getVersion: function() {
        return AppVersions.findOne({ appName: Template.instance().name.get(), appVersion: Template.instance().version.get() });
    },
});

Template.BuildErrorPage.events({
    "click .link-to-version-page" : function(e, t) {
        e.preventDefault();
        Router.go('VersionPage', { "_appName" : t.name.get(), "_appVersion": t.version.get() });
    },
});


////////////////////////////////////////////////////
//  Installation guide
////
Template.InstallationGuide.onCreated(function() {
    var self = this;
    this.appName = new ReactiveVar(null);
    this.appVersion = new ReactiveVar(null);

    this.autorun(function() {
        var data = Template.currentData();
        self.appName.set(data.app);
        self.appVersion.set(data.version);

        if( data ) {
            killApp();
            subMgr.subscribe('select_Apps', { 'name' : self.appName.get() });
            subMgr.subscribe('select_AppVersions', { 'appName' : self.appName.get(), 'appVersion': self.appVersion.get() }, { fields: { json: 0, buildError: 0 } });
        }
    });
});

Template.InstallationGuide.helpers({
    getAppName : function() {
        var v = AppVersions.findOne({ 'appName': Template.instance().appName.get(), 'appVersion': Template.instance().appVersion.get() });
        return v.appName;
    },

    getVersion : function() {
        return AppVersions.findOne({ 'appName': Template.instance().appName.get(), 'appVersion': Template.instance().appVersion.get() });
    },

    getId : function() {
        var v = AppVersions.findOne({ 'appName': Template.instance().appName.get(), 'appVersion': Template.instance().appVersion.get() });
        return v._id;
    },

    getInputs : function() {
        var v = AppVersions.findOne({ 'appName': Template.instance().appName.get(), 'appVersion': Template.instance().appVersion.get() });
        var json = JSON.parse(v.json);

        var inputs = [];
        _.each(json.input, (val, key) => {
            val.name = key;
            inputs.push(val);
        });
        return inputs;
    },

    getEvents : function() {
        var v = AppVersions.findOne({ 'appName': Template.instance().appName.get(), 'appVersion': Template.instance().appVersion.get() });
        var json = JSON.parse(v.json);

        var events = [];
        _.each(json.events, (val, key) => {
            val.name = key;
            events.push(val);
        });
        return events;
    },

    getPanels : function() {
        var v = AppVersions.findOne({ 'appName': Template.instance().appName.get(), 'appVersion': Template.instance().appVersion.get() });
        var json = JSON.parse(v.json);

        var panels = [];
        _.each(json.interface, (val, key) => {
            panels.push({
                name: key,
                description: val.description
            });
        });
        return panels;
    }
});


////////////////////////////////////////////////////
//  Show Version Template
//  Instanciate a DualBox App Version
////

Template.ShowVersion.onCreated(function() {
    this.autorun(function() {
        var data = Template.currentData();
        if( data ) {
            killApp();
            subMgr.subscribe('select_Apps', { 'name' : data.appName });
            subMgr.subscribe('select_AppVersions', { 'appName' : data.appName, 'appVersion': data.appVersion }, { fields: { json: 0, buildError: 0 } });
        }
    });
});

Template.ShowVersion.onRendered(function() {
    var self = this;
    this.loaded = false;
    this.autorun(function() {
        var data = Template.currentData();
        if( data ) {
            var version = AppVersions.findOne({ 'appName': data.appName, 'appVersion': data.appVersion });
            if( version !== undefined ) {
                // define the load app function
                self.load = function() {
                    if( !self.loaded ) {
                        var loadApp = function() {
                            DualBox.load({
                                "app"  : data.appName,
                                "version": data.appVersion,
                                "loaderDiv": $('#dualbox-app'),
                                "endpoint": Meteor.absoluteUrl()
                            }, function() {
                                window.app = DualBox.start({
                                    "logLevel": "warn",
                                    "profiler": "false",
                                    "div" : $('#dualbox-app'),
                                });
                                window.app.start();
                            });
                        }

                        if( window.DualBox ) {
                            // loadapp.js has already been added
                            loadApp();
                        }
                        else {
                            (function(callback) {
                                var s = document.createElement('script');
                                s.setAttribute( 'src', Meteor.absoluteUrl("loadapp.js"));
                                s.onload=callback; document.body.appendChild( s );
                            })(function() {
                                loadApp();
                            });
                        }

                        self.loaded = true;
                    }
                }

                var versionTemplate = self.findParent('VersionPage');
                if( versionTemplate ) {
                    /* if we have loaded or are loading the right tab */
                    if( versionTemplate.tabshown.get() == "application" ||
                        window.location.hash === "#application" ) {
                        $('#dualbox-app').ready(() => {
                            self.load();
                        });
                    }
                }
                else {
                     $('#dualbox-app').ready(() => {
                         self.load();
                     });
                }
            }
        }
    });
});

killApp = function() {
    if( window.app ) {
        window.app.kill();
        delete window.app;
    }
    $('#dualbox-app').empty();
}

Template.ShowVersion.onDestroyed(function() {
    killApp();
});

////////////////////////////////////////////////////
//  ApplicationPhasePage
//  Page that shows an app for the selected phase
//  (dev, alpha, beta, production)
////
Template.ApplicationPhasePage.onCreated(function() {
    var self = this;
    this.autorun(() => {
        var data = Template.currentData();
        if( data ) {
            this.appName = this.data._appName;
            this.appPhase = this.data._appPhase;

            subMgr.subscribe('Apps_by_name', data.appName, function() {
                var app = Apps.findOne({ 'name' : data.appName });
                if( app && app.phases ) {
                    self.versionId = app.phases[data.appPhase];
                    subMgr.subscribe('AppVersions_by_id', self.versionId);
                }
            });
        }
    });
});

Template.ApplicationPhasePage.helpers({
    getVersion : function() {
        return AppVersions.findOne();
    },

    getApp : function() {
        return Apps.findOne();
    }
});



////////////////////////////////////////////////////
//  AppsBuildingPage
//  Page that all apps/versions currently building
////
Template.AppsBuildingPage.onCreated(function() {
    var self = this;
    this.targetStatus = new ReactiveVar('building...');
    this.autorun(() => {
        subMgr.subscribe('select_AppVersions', { 'deployStatus': Template.instance().targetStatus.get() }, { fields: { json: 0, buildError: 0 } });
    });
});

Template.AppsBuildingPage.helpers({
    getVersions : function() {
        return AppVersions.find(
            { 'deployStatus': Template.instance().targetStatus.get() },
            { sort : { updatedAt: -1, appName: 1, appVersion: 1 } }
        ).fetch();
    },

    getLastUpdate: function() {
        return moment(this.updatedAt).calendar();
    }
});


Template.AppsBuildingPage.events({
    "click .link-to-dashboard" : function(e, t) {
        Router.go('DashboardPage');
    },

    "change .select-status" : function(e, t) {
        t.targetStatus.set( $(e.target).val() );
    }
});

/*
 *   Template for the graph
 */
Template.AppGraph.onCreated(function() {
    this.debugMode = false; // Let's handle that later
    this.editorInitialized = false;
    this.editorLoaded = new ReactiveVar(false);
    this.appDependenciesLoaded = new ReactiveVar(false);
    window.subs = this.subs = [];

    // index of components, to avoid resolving them multiple times
    this.components = {};
    window.components = this.components;

    // index of sources scripts
    this.sources = {};
    window.sources = this.sources;

    this.autorun(() => {
        subMgr.subscribe('all_Packages');
        var data = Template.currentData();
        subMgr.subscribe('select_AppVersions', { appName: data.appName, appVersion: data.appVersion });
    });

    this.addSource = function(name, path, cb) {
        var self = this;
        if( !self.sources[path] ) {
            self.sources[path] = { ready: false, cbs : [] };
            var s = document.createElement('script');
            s.setAttribute('src', path);
            s.setAttribute('charset', 'utf-8');
            s.onload = function() {
                self.sources[path].ready = true;
                _.each(self.sources[path].cbs, (cb) => {
                    cb();
                });
                self.sources[path].cbs = null;
            };
            self.sources[path].cbs.push(cb);
            document.body.appendChild(s);
        }
        else {
            if( self.sources[path].ready ) {
                //console.log('Not adding source for: ' + path + ', already loaded');
                cb();
            }
            else {
                //console.log('Not adding source for: ' + path + ', currently loading');
                self.sources[path].cbs.push(cb);
            }
        }
    };

    this.getPackageVersion = function(name, version) {
        return new Promise( (resolve, reject) => {
            var index = name;
            if( this.components[index] && this.components[index].info ) {
                resolve(this.components[index].info);
                return;
            }
            else {
                if( version == "*" || version == "latest" ) {
                    var sub = subMgr.subscribe('all_Packages');
                    sub.onReady(() => {
                        var p = Packages.findOne({ name: name });
                        if( !p ) {
                            reject("Package " + name + " not found. Has it been published?");
                        }
                        else {
                            var result = {
                                name: p.name,
                                version: p.lastVersion.versionNumber,
                                pkg: p.lastVersion.pkg,
                                description: p.lastVersion.description,
                                scriptUrl: p.getScriptUrl(this.debugMode)
                            }
                            if( !this.components[index] ) {
                                this.components[index] = {};
                            }
                            this.components[index].info = result;
                            resolve(result);
                        }
                    });
                    this.subs.push(sub);
                }
                else {
                    var sub = subMgr.subscribe('select_PackagesVersions', { packageName: name, versionNumber: version });
                    if( name == "@dualbox/dualbox-type-box2" ) {
                        window.thesub = sub;
                    }
                    sub.onReady(() => {
                        var v = PackagesVersions.findOne({ packageName: name, versionNumber: version });
                        if( !v ) {
                            reject("Package " + name + "@" + version + " not found. Has it been published?");
                        }
                        else {
                            var result = {
                                name: v.packageName,
                                version: v.versionNumber,
                                pkg: v.pkg,
                                description: v.description,
                                scriptUrl: v.getScriptUrl(this.debugMode)
                            };
                            if( !this.components[index] ) {
                                this.components[index] = {};
                            }
                            this.components[index].info = result;
                            resolve(result);
                        }
                    });
                    this.subs.push(sub);
                }
            }
        });
    }
    window.getPackageVersion = this.getPackageVersion;

    // load a dualbox script, return a promise
    this.loadScript = function(name, version) {
        return new Promise( (resolve, reject) => {
            this.getPackageVersion(name, version).then((pv) => {
                this.addSource( name, pv.scriptUrl, () => {
                    resolve();
                })
            }).catch(err => reject(err));
        });
    }

    // load an array of scripts, then call cb
    // Arr:
    //   - if an array of strings (like "@dualbox/dualbox"), will load last version for each
    //   - if an array of objects { name: "@dualbox/dualbox", version: "1.0.64" }, will load the specified version
    this.loadScripts = function( arr, cb ) {
        var p = [];
        _.each(arr, (m) => {
            if( typeof m == "string" ) {
                p.push( this.loadScript(m, "*") );
            }
            else {
                p.push( this.loadScript(m.name, m.version) );
            }
        });

        return Promise.all(p);
    }

    // Non-promise version of the loadScript
    this.load = function(name, version, cb) {
        this.loadScript(name, version).then(() =>  {
            cb();
        }).catch(err => {
            cb(err);
        });
    }

    // debug function
    window.findUnresolved = function() {
        _.each(window.components, (c, k) => {
            if( c.dependenciesStatus !== "resolved" ) {
                if( c.info ) {
                    console.log('component ' + c.info.name + '@' + c.info.version + ' is status ' + c.dependenciesStatus);
                }
                else {
                    console.log('component ' + k + ' not resolved from server');
                }
            }
        });
    }

    // return promise
    this.findDependencies = function( name, version ) {
        var index = name;

        if( this.components[index] && this.components[index].dependenciesStatus == "resolved" ) {
            return new Promise(resolve => resolve(this.components[index].dependencies));
        }
        else if(this.components[index] && this.components[index].dependenciesStatus == "resolving" ) {
            return this.components[index].findDependenciesPromise;
        }
        else if(this.components[index] && this.components[index].dependenciesStatus == "rejected") {
            return this.components[index].findDependenciesPromise;
        }
        else {
            // this is the first resolve
            var p = []; // Array of promises
            if( !this.components[index] ) {
                this.components[index] = {};
            }
            //this.components[index].dependenciesPromises = p; // for debug
            this.components[index].dependenciesStatus = "resolving"

            this.components[index].findDependenciesPromise = new Promise( (resolve, reject) => {
                this.getPackageVersion(name, version).then((pv) => {
                    var dependencies = {};
                    var deps = Object.assign({}, pv.pkg.dependencies);
                    var empty = true;
                    _.each(deps, (v, n) => {
                        if( n.startsWith('@dualbox/') && !dependencies[n] ) {
                            if( v.startsWith('^') ) v = v.replace('^','');
                            dependencies[n] = v;
                            p.push( this.findDependencies(n, v) );
                            empty = false;
                        }
                    });

                    _.each(pv.pkg.optionalDependencies, (v, n) => {
                        if( n.startsWith('@dualbox/') && !dependencies[n] ) {
                            // optional dependencies always refer to latest
                            p.push( this.getPackageVersion(n, "latest").then((pv) => {
                                dependencies[n] = pv.version;
                                p.push( this.findDependencies(n, pv.version));
                            }).catch(err => {
                                console.error("Couldn't find package version for optional dep " + n + "@" + v);
                            }));
                            empty = false;
                        }
                    });

                    Promise.all(p).then((depsArray) => {
                        _.each(depsArray, (deps) => {
                            dependencies = Object.assign(dependencies, deps);
                        });
                        this.components[index].dependencies = dependencies;
                        this.components[index].dependenciesStatus = "resolved";
                        resolve(dependencies);
                    }).catch((err) => {
                        this.components[index].dependenciesStatus = "rejected";
                        this.components[index].dependencyError = err;
                        //console.error("Error fetching dependencies of " + name + ": " + err);
                        reject(err);
                    });
                }).catch(err => {
                    this.components[index].dependenciesStatus = "rejected";
                    this.components[index].dependencyError = err;
                    //console.error(err);
                    reject(err);
                });
            });

            return this.components[index].findDependenciesPromise;
        }
    }

    window.promises = {};

    // PREREQUISITE: need to have instanciated the AppParser
    // load all the dependencies needed from an app.json
    // return a Promise
    this.loadDependencies = function(json) {
        // first, list the dependencies in the app.json
        var dependencies = {};
        var appParser = new AppParser(json);
        appParser.eachPackage((name, version) => {
            dependencies[name] = version;
        });

        // thoses dependencies might have dependencies on their own.
        // We need build the complete list of dependencies
        var p = []; // list of promises
        _.each( dependencies, (version, name) => {
            p.push(this.findDependencies(name, version));
        });

        return new Promise((resolve, reject) => {
            Promise.all(p).then((depsArray) => {
                // concatenate our deps in 1 object
                _.each(depsArray, (deps) => {
                    dependencies = Object.assign(dependencies, deps);
                });

                // Now, we have listed in dependencies all our real dependencies
                // Load them.
                var d = [];
                _.each(dependencies, (version, name) => {
                    d.push({ name: name, version: version });
                });
                this.loadScripts(d).then(resolve).catch(reject);
            }).catch((e) => {
                //console.error('Error fetching dependencies of json: ' + e);
                reject(e);
            });;
        });
    }

    // return a promise with the updated Json as a parameter
    this.updateJsonDependencies = function( json ) {
        console.log('Updating json and load editor again');

        // remove all previous promises done (previous json fetched different versions)
        this.components = {};

        return new Promise( (resolve, reject) => {
            // first, list the dependencies in the app.json, build a name<->version map and a name<->dependencies map
            var versions = {};
            var dependencies = {};
            var p = []; // array of Promises

            var appParser = new AppParser(json);
            appParser.eachPackage((name, version) => {
                var dependencyPromise = this.findDependencies(name, "latest").then((d) => {
                    dependencies[name] = d;
                });
                p.push(dependencyPromise);

                var versionPromise = this.getPackageVersion(name, "latest").catch(err => {
                    reject('Error retrieving last version of package ' + name + ': ' + err);
                }).then(pv => {
                    versions[name] = pv.version;
                });
                p.push(versionPromise);
            });

            // we have found everything
            Promise.all(p).then(() => {
                var json = appParser.updateComponents(dependencies).updateVersions(versions).json;

                // check that all lib/types dependencies are present
                _.each(dependencies, (d, name) => {
                    _.each(d, (depVersion, depName) => {
                        if( depName.startsWith('@dualbox/dualbox-lib') || depName.startsWith('@dualbox/dualbox-type') ) {
                            if( !json.libs[depName] ) {
                                console.log("adding " + depName + ' in JSON libs');
                                json.libs[depName] = depVersion;
                            }
                        }
                    });
                });

                resolve(json);
            }).catch(err => reject(err));
        });
    }

    this.search = (text, cb) => {
        var sub = subMgr.subscribe('PackageSearch', text);
        sub.onReady(() => {
            let query      = {},
                projection = { limit: 10, sort: { title: 1 } };

            if ( text ) {
                let regex = new RegExp( text, 'i' );

                query = {
                  $or: [
                    { "name": regex },
                    { "lastVersion.versionNumber": regex },
                    { "lastVersion.description": regex }
                  ]
                };

                projection.limit = 100;
            }

            var packages = Packages.find( query, projection ).fetch();
            var results = []; // packages.json
            _.each(packages, (p) => {
                // remove type matching
                if( !p.name.startsWith('@dualbox/dualbox-type') ) {
                    results.push({
                        name: p.name,
                        version: p.lastVersion.versionNumber,
                        description: p.lastVersion.description,
                        dualbox: p.lastVersion.pkg.dualbox
                    });
                }
            });

            if( cb ) cb(null, results);
        });
    };

    this.find = (name, version, cb) => {
        if( name.startsWith('dualbox-core') ) {
            switch(name) {
                case "dualbox-core-if":
                    cb(null, window.DualBox.core.If);
                    break;
                case "dualbox-core-value":
                    cb(null, window.DualBox.core.Value);
                    break;
                case "dualbox-core-from-json":
                    cb(null, window.DualBox.core.FromJson);
                    break;
                case "dualbox-core-to-json":
                    cb(null, window.DualBox.core.ToJson);
                    break;
                case "dualbox-core-script":
                    cb(null, window.DualBox.core.Script);
                    break;
                case "dualbox-core-switch":
                    cb(null, window.DualBox.core.Switch);
                    break;
                default:
                    throw new Dualbox.Error("Unknown dualbox-core package: " + name);
            }
        }
        else {
            this.loadScript(name, version).then(() => {
                this.getPackageVersion(name, version).then(pv => {
                    cb(null, pv.pkg);
                }).catch(err => {
                    cb( new Meteor.Error('Error retrieving PackageVersion: ' + name + '@' + version) );
                });
            }).catch((e) => {
                console.error('Error loading package: ' + name + '@' + version + ': ' + e);
            });
        }
    }

    this.saveApp = function(json) {
        // find the actual version
        var version = AppVersions.findOne({ appName: this.data.appName, appVersion: this.data.appVersion });
        if( !version ) {
            swal("Oh oh.", "The current version has not been found.", "error");
            return;
        }

        var processToSave = function(version) {
            AppVersions.update({ _id: version._id }, { $set: { "json": JSON.stringify(json), "deployStatus": "Not deployed", "buildError": undefined, "buildId": undefined }}, () => {
                swal({
                    title: "Saved.",
                    text: "Your application has been saved. You can now deploy it from the Version management page.",
                    type: "success"
                });
            });
        }

        switch(version.deployStatus) {
            case "Not deployed":
            case "error":
                // process
                processToSave(version);
                break;
            case "in queue":
            case "building...":
            case "built":
                // cancel
                swal({
                    title: "A build is running.",
                    text: "A build is currently running on this version. You'll need to wait for it to finish before you can change this version.",
                    type: "error"
                });
                break;
            case "deployed":
                // ask for confirmation
                swal({
                    title: 'This version is already deployed!',
                    text: 'Changing it will delete the current deployment and make it unavailable until you rebuild this version. Do you want to continue ?',
                    type: 'warning',
                    showCancelButton: true,
                    confirmButtonText: 'Yes, delete deployment and save !',
                    cancelButtonText: 'Abort',
                }).then( (r) => {
                    if( r.value ) {
                        processToSave(version);
                    }
                });
                break;
            default:
                // error
                console.log('Did not recognize version status: ' + version.deployStatus);
                swal("Oh oh.", "Error trying to fetch the current version status.", "error");
                return;
        }
    }

});

var DualboxEditor;
Template.AppGraph.onCreated(function() {
    import("@dualbox/editor").then(dbEditor => {
        DualboxEditor = dbEditor;
    });
});

Template.AppGraph.onRendered(function() {
    var self = this;

    this.autorun(() => {
        if( !this.editorInitialized ) {
            var data = Template.currentData();
            var version = AppVersions.findOne({ appName: data.appName, appVersion: data.appVersion });
            if( version ) {
                // load the necessary libs for the editor to work
                try {
                    self.loadScripts([
                        "@dualbox/dualbox-lib-lodash",
                        "@dualbox/dualbox-lib-htmltool",
                        "@dualbox/dualbox-lib-appparser",
                        "@dualbox/dualbox-lib-jquery",
                        "@dualbox/dualbox-lib-font-awesome",
                        "@dualbox/dualbox",
                        '@dualbox/dualbox-type-object',
                        '@dualbox/dualbox-type-buffer',
                        '@dualbox/dualbox-type-map',
                        '@dualbox/dualbox-type-array',
                        '@dualbox/dualbox-type-nativearray',
                        '@dualbox/dualbox-type-number',
                        '@dualbox/dualbox-type-boolean',
                        '@dualbox/dualbox-type-string',
                        '@dualbox/dualbox-type-regexp',
                        '@dualbox/dualbox-type-json'
                    ]).then(() => {
                        // load htmltool for the editor to use
                        var str = "@dualbox/dualbox-lib-htmltool";
                        window.htmltool = require(str);

                        // load the AppParser
                        str = "@dualbox/dualbox-lib-appparser";
                        window.AppParser = require(str);

                        // load dualbox for the editor to use
                        str = "@dualbox/dualbox";
                        var DualBox = require(str);
                        if( window.DualBox && window.DualBox instanceof Object ) {
                            // assign all DualBox properties into the existing object
                            DualBox.$ = window.DualBox.$ || window.jQuery || require('@dualbox/dualbox-lib-jquery');
                            Object.assign(window.DualBox, DualBox);
                        }
                        else {
                            DualBox.$ = window.jQuery || require('@dualbox/dualbox-lib-jquery');
                            window.DualBox = DualBox;
                        }

                        // Initialize the editor
                        this.editorInitialized = true;

                        var json = JSON.parse(version.json);

                        // For debug purpose
                        window.getApp = function(){
                            return window.editor.v.appManager.app;
                        };

                        // Load all the dependencies of the app
                        this.loadDependencies(json).then(() => {
                            self.appDependenciesLoaded.set(true);

                            // Load the editor
                            window.editor = new window.DualboxEditor(this.$('.editor'), {
                                showLoadButton : false,
                                showSaveButton : true,
                                saveButtonFunction: this.saveApp.bind(this),
                                search : self.search.bind(self),
                                find : self.find.bind(self),
                                load : self.load.bind(self),
                                name : data.appName + '@' + data.appVersion,
                                json : json,
                                onLoaded: () => {
                                    self.editorLoaded.set(true);
                                },
                            });
                        }).catch((e) => {
                            console.error("Error loading app dependencies: " + e);
                            swal({
                                title: 'This version is out of date',
                                text: 'This version can not be loaded in the Graph Editor, since the dependencies are too old. Do you want to try to automatically update the dependencies and to load it in the editor?',
                                type: 'warning',
                                showCancelButton: true,
                                confirmButtonText: 'Yes, update dependencies and open the graph editor !',
                                cancelButtonText: 'Abort',
                            }).then( (r) => {
                                if( r.value ) {
                                    // Try to automatically update the json
                                    this.updateJsonDependencies(json).then((updatedJson) => {
                                        this.loadDependencies(updatedJson).then(() => {
                                            self.appDependenciesLoaded.set(true);

                                            // now, load the editor
                                            window.editor = new window.DualboxEditor(this.$('.editor'), {
                                                showLoadButton : false,
                                                showSaveButton : true,
                                                saveButtonFunction: this.saveApp.bind(this),
                                                search : self.search,
                                                find : self.find,
                                                name : data.appName + '@' + data.appVersion,
                                                json : updatedJson,
                                                onLoaded: () => {
                                                    self.editorLoaded.set(true);
                                                },
                                            });
                                        }).catch((e) => {
                                            console.log('Could not automatically update app dependencies: ' + e);
                                            Router.go('/apps/' + version.appName + '/v/' + version.appVersion);
                                        });
                                    }).catch(e => {
                                        console.error('Error updating json: ' + e);
                                    });

                                }
                                else {
                                    // return to previous page
                                    Router.go('/apps/' + version.appName + '/v/' + version.appVersion);
                                }
                            });
                        });

                    }).catch((e) => {
                        console.error("Error loading editor dependencies: " + e);
                    });
                }
                catch(e) {
                    console.error(e);
                }

            }
        }
    });
});

Template.AppGraph.helpers({
    editorLoaded: function() {
        return Template.instance().editorLoaded.get();
    },

    appDependenciesLoaded: function() {
        return Template.instance().appDependenciesLoaded.get();
    }
});

// redefine requirements to allow for dualbox modules
MeteorRequire = require;
require = function(id) {
    if( id.startsWith('@dualbox/') ) {
        return window.require(id);
    }
    else {
        return MeteorRequire(id);
    }
}
