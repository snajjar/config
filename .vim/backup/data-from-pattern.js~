var description = require('./package.json');
var DualBox = require('@dualbox/dualbox');
var XTHREE = require('@dualbox/dualbox-lib-xthree');
var podo3d = require('@dualbox/dualbox-lib-scientifeet-podo3d');

var dbString = require('@dualbox/dualbox-type-string');
var JSONObject = require('@dualbox/dualbox-type-json');
var DualBoxTypesAll3D = require('@dualbox/dualbox-type-all3d');

/**
 *  This module will analyze 3 points positionned on a mesh to determine which one is
 *  heel, meta1 and meta5.
 *  @constructor
 *  @extends {DualBox.Module}
 */
var DataFromPattern = function(attrs){
    DualBox.Module.call(this, description, attrs);
    this.setParallel(false);
};

DataFromPattern.prototype = Object.create(DualBox.Module.prototype);
DataFromPattern.prototype.constructor = DataFromPattern;

// [Abstract] See DualBox.Module
DataFromPattern.prototype.compute = function(input, response){
    this.debug( "Computing output of DataFromPattern" );

    var json = input.json.get();

    var output = {
        holes:      null,
        recessHole: json.recess.hole,
        contour:    null,
        zones:      new Map(), // Map<string,BufferTriGeometry>
        txtzones:   new Map(), // Map<string,BufferTriGeometry>
        contourCover: null,
        pattern:      null,
        refPoints:  new Map(),  // Map<string,Vector3>
        oMatrix: null
    };

    var dbSolePattern = json;

    // In database, we have only left foots, so inverse everything if necessary.
    if(input.side === "right"){
        // clone the json to ensure constness.
        // We could also have changed the const attribute in package.json, but it is actually necessary to clone only
        // when the side is right.
        dbSolePattern = podo3d.inverseFootSide(JSON.parse(JSON.stringify(dbSolePattern)));
    }

    ///////////////////
    // IMPORTANT NOTE
    ///////////////////
    // Since the pattern are not positioned in 0,0,0 (heel), this module will repositioned them
    // in order to have an easy positioning for all other reference files.
    var heel_p = dbSolePattern.refpts.heel;
    var op_pattern_heel = XTHREE.Vector3.fromJSON(heel_p);
    op_pattern_heel.multiplyScalar(-1);

    var rpKeys = Object.keys(dbSolePattern.refpts);
    var obj_refpts = {}; // same but not as a Map.
    for(var i=0; i<rpKeys.length; ++i) {
        var p = dbSolePattern.refpts[rpKeys[i]];
        var pnew = XTHREE.Vector3.fromJSON(p);
        pnew.add(op_pattern_heel);
        output.refPoints.set(rpKeys[i],pnew);
        obj_refpts[rpKeys[i]] = pnew;
    }

    var omat = podo3d.computeSoleOrientationMatrix(obj_refpts, input.side);
    output.oMatrix = omat;

    for(var i=0; i<rpKeys.length; ++i) {
        var p = dbSolePattern.refpts[rpKeys[i]];
        output.refPoints.get(rpKeys[i]).applyMatrix4(omat);
    }

    var holes = dbSolePattern.holes;
    output.holes = new JSONObject(holes);
    var hkeys = Object.keys(holes);
    var vec = new XTHREE.Vector3();
    for(var i=0; i<hkeys.length; ++i){
        var centers = holes[hkeys[i]];
        for(var k=0; k<centers.length; ++k){
            var cp = centers[k].p;
            vec.set(cp.x, cp.y, cp.z);
            vec.add(op_pattern_heel);
            vec.applyMatrix4(omat);
            cp.x = vec.x;
            cp.y = vec.y;
            cp.z = vec.z;
        }
    }

    var buildContourGeometryFromDB = function(db_polyline){
        var line = new XTHREE.BufferLineGeometry();
        line.setVerticesNumber(db_polyline.length/3);
        var attr = {
            position: new XTHREE.Vector3()
        };
        for(var i=0; i<line.vertexCount(); i++){
            attr.position.set(db_polyline[3*i], db_polyline[3*i+1], db_polyline[3*i+2]);
            line.setVertex(i, attr);
        }
        return line;
    };
    output.contour = buildContourGeometryFromDB(dbSolePattern.contour.polyline);
    output.contour.translate(op_pattern_heel.x,op_pattern_heel.y,op_pattern_heel.z);
    output.contour.applyMatrix(omat);

    var keys = Object.keys(dbSolePattern.zones);
    for(var i=0; i<keys.length; ++i){
        var z_mesh = (new XTHREE.BufferTriGeometry()).fromJSON(dbSolePattern.zones[keys[i]]);
        z_mesh.computeVertexNormals();
        z_mesh.translate(op_pattern_heel.x,op_pattern_heel.y,op_pattern_heel.z);
        z_mesh.applyMatrix(omat);
        output.zones.set(keys[i],z_mesh);
    }

    keys = Object.keys(dbSolePattern.txtzones);
    for(var i=0; i<keys.length; ++i){
        var g = (new XTHREE.BufferTriGeometry()).fromJSON(dbSolePattern.txtzones[keys[i]]);
        g.computeVertexNormals();
        g.translate(op_pattern_heel.x,op_pattern_heel.y,op_pattern_heel.z);
        g.applyMatrix(omat);
        output.txtzones.set(keys[i],g);
    }

    output.contourCover = (new XTHREE.BufferTriGeometry()).fromJSON(dbSolePattern.contour.cover);
    output.contourCover.computeVertexNormals();
    output.contourCover.translate(op_pattern_heel.x,op_pattern_heel.y,op_pattern_heel.z);
    output.contourCover.applyMatrix(omat);

    output.pattern = (new XTHREE.BufferTriGeometry()).fromJSON(dbSolePattern.pattern);
    output.pattern.computeVertexNormals();
    output.pattern.translate(op_pattern_heel.x,op_pattern_heel.y,op_pattern_heel.z);
    output.pattern.applyMatrix(omat);
    output.pattern.computeBoundingBox();

    // Dev Notes :
    // The sole has been reoriented here, so it's oriented in x
    var pattern_size = output.pattern.boundingBox.getSize(new XTHREE.Vector3());
    var width = pattern_size.y;
    var height = pattern_size.x;


        // Then it's only transformations.

            // podiatrySMFunc.podiatry.setupSolePositions(refpts);

            // setupAdjustPositionsAfterPatternChange();

            // setupAnteroAfterPatternChange(dbSolePattern, refpts);

            // setupCurrentCorrectionAfterPatternChange();

            // skim.engine.update_skeleton();
            // skim.engine.update_parametrics();

            // // Don't do that because race condition... Or fix the race
            // // condition between footrpint load and sole load
            // podiatrySMFunc.podiatry.centerViewOnScanMesh(skim.CAMERA_MODE.PZOrthographic);
            // $('.select-view').val("PZ");

            // $('.loading-pattern').hide();

            // var ev = {
                // complexType:"insole:imported",
                // preventDefault:function(){},
                // stopPropagation:function(){}
            // };
            // skim.instances.modeler.viewManager.mainCanvasView.trigger(ev.complexType, ev);

            // if( window.data.insole !== undefined && generate) {
                // generateInsole();
            // }

    response.send(output);
};

module.exports = DataFromPattern;

